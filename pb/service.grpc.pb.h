// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: service.proto
// Original file comments:
// Copyright (c) 2016-2017, Nefeli Networks, Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
// list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// * Neither the names of the copyright holders nor the names of their
// contributors may be used to endorse or promote products derived from this
// software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
#ifndef GRPC_service_2eproto__INCLUDED
#define GRPC_service_2eproto__INCLUDED

#include "service.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace bess {
namespace pb {

class BESSControl final {
 public:
  static constexpr char const* service_full_name() {
    return "bess.pb.BESSControl";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    //  -------------------------------------------------------------------------
    //  System
    //  -------------------------------------------------------------------------
    //
    // / Query version of bessd
    virtual ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::VersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::VersionResponse>> AsyncGetVersion(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::VersionResponse>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::VersionResponse>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::VersionResponse>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    // / Reset the current packet processing datapath to the initial state.
    // /
    // / This command is identical to the following sequence:
    // /   ResetModules()
    // /   ResetPorts()
    // /   ResetTcs()
    // /   ResetWorkers()
    // / As it clears everything, BESS should appear as if the daemon has freshly
    // / started (if not, it is a bug; please report).
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status ResetAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncResetAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncResetAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncResetAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncResetAllRaw(context, request, cq));
    }
    // / Terminate the BESS daemon.
    // /
    // / BESS daemon shuts off in a graceful manner. Note that this command is
    // / "asynchronous": this command doesn't block until the BESS daemon has
    // / shut off.
    // /
    // / NOTE: There should be no running worker to run this command.
    // / FIXME: rename (e.g., Terminate)
    virtual ::grpc::Status KillBess(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncKillBess(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncKillBessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncKillBess(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncKillBessRaw(context, request, cq));
    }
    // / Import a plugin
    // /
    // / At the moment plugins can only contain module types,
    // / but might also support drivers/hooks/schedulers in the future.
    virtual ::grpc::Status ImportPlugin(::grpc::ClientContext* context, const ::bess::pb::ImportPluginRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncImportPlugin(::grpc::ClientContext* context, const ::bess::pb::ImportPluginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncImportPluginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncImportPlugin(::grpc::ClientContext* context, const ::bess::pb::ImportPluginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncImportPluginRaw(context, request, cq));
    }
    // / Unload a plugin
    // /
    // / At the moment plugins can only contain module types,
    // / but might also support drivers/hooks/schedulers in the future.
    virtual ::grpc::Status UnloadPlugin(::grpc::ClientContext* context, const ::bess::pb::UnloadPluginRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncUnloadPlugin(::grpc::ClientContext* context, const ::bess::pb::UnloadPluginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncUnloadPluginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncUnloadPlugin(::grpc::ClientContext* context, const ::bess::pb::UnloadPluginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncUnloadPluginRaw(context, request, cq));
    }
    // / List imported plugins
    // /
    // / At the moment plugins can only contain module types,
    // / but might also support drivers/hooks/schedulers in the future.
    virtual ::grpc::Status ListPlugins(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListPluginsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListPluginsResponse>> AsyncListPlugins(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListPluginsResponse>>(AsyncListPluginsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListPluginsResponse>> PrepareAsyncListPlugins(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListPluginsResponse>>(PrepareAsyncListPluginsRaw(context, request, cq));
    }
    //  -------------------------------------------------------------------------
    //  Worker
    //  -------------------------------------------------------------------------
    //
    // / Pause all running workers temporarily
    // /
    // / Some RPC commands to BESS or individual modules/ports require that
    // / threads must be inactive, to avoid race conditions.
    // / For such commands, use PauseALl at the beginning and ResumeAll at the end.
    // /  PauseAll()
    // /   SomeCommand1()
    // /   SomeCommand2()
    // /   ...
    // /  ResumeAll()
    // / Keep the duration as short as possible, to avoid packet drops.
    virtual ::grpc::Status PauseAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncPauseAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncPauseAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncPauseAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncPauseAllRaw(context, request, cq));
    }
    // / Pause the specified worker temporarily
    // /
    // / Some RPC commands to BESS or individual modules/ports require that
    // / threads must be inactive, to avoid race conditions.
    // / For such commands, use PauseWorker at the beginning and ResumeWorker at the end.
    // /  PauseWorker(0)
    // /   SomeCommand1()
    // /   SomeCommand2()
    // /   ...
    // /  ResumeWorker(0)
    // / Keep the duration as short as possible, to avoid packet drops.
    virtual ::grpc::Status PauseWorker(::grpc::ClientContext* context, const ::bess::pb::PauseWorkerRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncPauseWorker(::grpc::ClientContext* context, const ::bess::pb::PauseWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncPauseWorkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncPauseWorker(::grpc::ClientContext* context, const ::bess::pb::PauseWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncPauseWorkerRaw(context, request, cq));
    }
    // / Resume the specified worker
    virtual ::grpc::Status ResumeWorker(::grpc::ClientContext* context, const ::bess::pb::ResumeWorkerRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncResumeWorker(::grpc::ClientContext* context, const ::bess::pb::ResumeWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncResumeWorkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncResumeWorker(::grpc::ClientContext* context, const ::bess::pb::ResumeWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncResumeWorkerRaw(context, request, cq));
    }
    // / Resume all paused workers
    virtual ::grpc::Status ResumeAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncResumeAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncResumeAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncResumeAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncResumeAllRaw(context, request, cq));
    }
    // / Remove all existing workers
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status ResetWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncResetWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncResetWorkersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncResetWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncResetWorkersRaw(context, request, cq));
    }
    // / Enumerate all existing workers
    virtual ::grpc::Status ListWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListWorkersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListWorkersResponse>> AsyncListWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListWorkersResponse>>(AsyncListWorkersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListWorkersResponse>> PrepareAsyncListWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListWorkersResponse>>(PrepareAsyncListWorkersRaw(context, request, cq));
    }
    // / Create a new worker
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status AddWorker(::grpc::ClientContext* context, const ::bess::pb::AddWorkerRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncAddWorker(::grpc::ClientContext* context, const ::bess::pb::AddWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncAddWorkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncAddWorker(::grpc::ClientContext* context, const ::bess::pb::AddWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncAddWorkerRaw(context, request, cq));
    }
    // / Remove a single worker
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status DestroyWorker(::grpc::ClientContext* context, const ::bess::pb::DestroyWorkerRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncDestroyWorker(::grpc::ClientContext* context, const ::bess::pb::DestroyWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncDestroyWorkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncDestroyWorker(::grpc::ClientContext* context, const ::bess::pb::DestroyWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncDestroyWorkerRaw(context, request, cq));
    }
    //  -------------------------------------------------------------------------
    //  Traffic classe & task
    //  -------------------------------------------------------------------------
    //
    // / Remove all existing traffic classes
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status ResetTcs(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncResetTcs(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncResetTcsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncResetTcs(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncResetTcsRaw(context, request, cq));
    }
    // / Enumerate all existing workers
    virtual ::grpc::Status ListTcs(::grpc::ClientContext* context, const ::bess::pb::ListTcsRequest& request, ::bess::pb::ListTcsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListTcsResponse>> AsyncListTcs(::grpc::ClientContext* context, const ::bess::pb::ListTcsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListTcsResponse>>(AsyncListTcsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListTcsResponse>> PrepareAsyncListTcs(::grpc::ClientContext* context, const ::bess::pb::ListTcsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListTcsResponse>>(PrepareAsyncListTcsRaw(context, request, cq));
    }
    // / Check scheduling contraints
    virtual ::grpc::Status CheckSchedulingConstraints(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::CheckSchedulingConstraintsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CheckSchedulingConstraintsResponse>> AsyncCheckSchedulingConstraints(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CheckSchedulingConstraintsResponse>>(AsyncCheckSchedulingConstraintsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CheckSchedulingConstraintsResponse>> PrepareAsyncCheckSchedulingConstraints(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CheckSchedulingConstraintsResponse>>(PrepareAsyncCheckSchedulingConstraintsRaw(context, request, cq));
    }
    // / Create a new traffic class
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status AddTc(::grpc::ClientContext* context, const ::bess::pb::AddTcRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncAddTc(::grpc::ClientContext* context, const ::bess::pb::AddTcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncAddTcRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncAddTc(::grpc::ClientContext* context, const ::bess::pb::AddTcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncAddTcRaw(context, request, cq));
    }
    // / Update parameters of an existing traffic class
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status UpdateTcParams(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParamsRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncUpdateTcParams(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncUpdateTcParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncUpdateTcParams(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncUpdateTcParamsRaw(context, request, cq));
    }
    // / Change parent (and child arguments) of an existing traffic class
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status UpdateTcParent(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParentRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncUpdateTcParent(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncUpdateTcParentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncUpdateTcParent(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncUpdateTcParentRaw(context, request, cq));
    }
    // / Collect statistics of a traffic class
    virtual ::grpc::Status GetTcStats(::grpc::ClientContext* context, const ::bess::pb::GetTcStatsRequest& request, ::bess::pb::GetTcStatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetTcStatsResponse>> AsyncGetTcStats(::grpc::ClientContext* context, const ::bess::pb::GetTcStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetTcStatsResponse>>(AsyncGetTcStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetTcStatsResponse>> PrepareAsyncGetTcStats(::grpc::ClientContext* context, const ::bess::pb::GetTcStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetTcStatsResponse>>(PrepareAsyncGetTcStatsRaw(context, request, cq));
    }
    //  -------------------------------------------------------------------------
    //  Port
    //  -------------------------------------------------------------------------
    //
    // / Enumerate all port drivers available
    virtual ::grpc::Status ListDrivers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListDriversResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListDriversResponse>> AsyncListDrivers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListDriversResponse>>(AsyncListDriversRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListDriversResponse>> PrepareAsyncListDrivers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListDriversResponse>>(PrepareAsyncListDriversRaw(context, request, cq));
    }
    // / Query detailed information of a port driver
    virtual ::grpc::Status GetDriverInfo(::grpc::ClientContext* context, const ::bess::pb::GetDriverInfoRequest& request, ::bess::pb::GetDriverInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetDriverInfoResponse>> AsyncGetDriverInfo(::grpc::ClientContext* context, const ::bess::pb::GetDriverInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetDriverInfoResponse>>(AsyncGetDriverInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetDriverInfoResponse>> PrepareAsyncGetDriverInfo(::grpc::ClientContext* context, const ::bess::pb::GetDriverInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetDriverInfoResponse>>(PrepareAsyncGetDriverInfoRaw(context, request, cq));
    }
    // / Remove all initialized ports
    // /
    // / Will fail if there are modules that are still using ports.
    // / (e.g., PortInc, PortOut, QueueInc, QueueOut)
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status ResetPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncResetPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncResetPortsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncResetPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncResetPortsRaw(context, request, cq));
    }
    // / Enumerate all initialized ports
    virtual ::grpc::Status ListPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListPortsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListPortsResponse>> AsyncListPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListPortsResponse>>(AsyncListPortsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListPortsResponse>> PrepareAsyncListPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListPortsResponse>>(PrepareAsyncListPortsRaw(context, request, cq));
    }
    // / Create a new port from the specified driver
    virtual ::grpc::Status CreatePort(::grpc::ClientContext* context, const ::bess::pb::CreatePortRequest& request, ::bess::pb::CreatePortResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CreatePortResponse>> AsyncCreatePort(::grpc::ClientContext* context, const ::bess::pb::CreatePortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CreatePortResponse>>(AsyncCreatePortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CreatePortResponse>> PrepareAsyncCreatePort(::grpc::ClientContext* context, const ::bess::pb::CreatePortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CreatePortResponse>>(PrepareAsyncCreatePortRaw(context, request, cq));
    }
    // / Remove a port
    // /
    // / The port should not be being used by a port-related module.
    // / (e.g., PortInc, PortOut, QueueInc, QueueOut)
    virtual ::grpc::Status DestroyPort(::grpc::ClientContext* context, const ::bess::pb::DestroyPortRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncDestroyPort(::grpc::ClientContext* context, const ::bess::pb::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncDestroyPortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncDestroyPort(::grpc::ClientContext* context, const ::bess::pb::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncDestroyPortRaw(context, request, cq));
    }
    // / Runtime-updatable configuration
    virtual ::grpc::Status SetPortConf(::grpc::ClientContext* context, const ::bess::pb::SetPortConfRequest& request, ::bess::pb::CommandResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>> AsyncSetPortConf(::grpc::ClientContext* context, const ::bess::pb::SetPortConfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>>(AsyncSetPortConfRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>> PrepareAsyncSetPortConf(::grpc::ClientContext* context, const ::bess::pb::SetPortConfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>>(PrepareAsyncSetPortConfRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPortConf(::grpc::ClientContext* context, const ::bess::pb::GetPortConfRequest& request, ::bess::pb::GetPortConfResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetPortConfResponse>> AsyncGetPortConf(::grpc::ClientContext* context, const ::bess::pb::GetPortConfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetPortConfResponse>>(AsyncGetPortConfRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetPortConfResponse>> PrepareAsyncGetPortConf(::grpc::ClientContext* context, const ::bess::pb::GetPortConfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetPortConfResponse>>(PrepareAsyncGetPortConfRaw(context, request, cq));
    }
    // / Collect port statistics
    // /
    // / At the moment, per-queue stats are not supported.
    virtual ::grpc::Status GetPortStats(::grpc::ClientContext* context, const ::bess::pb::GetPortStatsRequest& request, ::bess::pb::GetPortStatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetPortStatsResponse>> AsyncGetPortStats(::grpc::ClientContext* context, const ::bess::pb::GetPortStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetPortStatsResponse>>(AsyncGetPortStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetPortStatsResponse>> PrepareAsyncGetPortStats(::grpc::ClientContext* context, const ::bess::pb::GetPortStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetPortStatsResponse>>(PrepareAsyncGetPortStatsRaw(context, request, cq));
    }
    // / Query link status
    virtual ::grpc::Status GetLinkStatus(::grpc::ClientContext* context, const ::bess::pb::GetLinkStatusRequest& request, ::bess::pb::GetLinkStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetLinkStatusResponse>> AsyncGetLinkStatus(::grpc::ClientContext* context, const ::bess::pb::GetLinkStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetLinkStatusResponse>>(AsyncGetLinkStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetLinkStatusResponse>> PrepareAsyncGetLinkStatus(::grpc::ClientContext* context, const ::bess::pb::GetLinkStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetLinkStatusResponse>>(PrepareAsyncGetLinkStatusRaw(context, request, cq));
    }
    // TODO: Add PortCommand, like ModuleCommand, which performs driver-specific
    //       actions on a port.
    //
    //  -------------------------------------------------------------------------
    //  Module
    //  -------------------------------------------------------------------------
    //
    // / Enumerate all module types available
    virtual ::grpc::Status ListMclass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListMclassResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListMclassResponse>> AsyncListMclass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListMclassResponse>>(AsyncListMclassRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListMclassResponse>> PrepareAsyncListMclass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListMclassResponse>>(PrepareAsyncListMclassRaw(context, request, cq));
    }
    // / Query detailed information of a module type
    virtual ::grpc::Status GetMclassInfo(::grpc::ClientContext* context, const ::bess::pb::GetMclassInfoRequest& request, ::bess::pb::GetMclassInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetMclassInfoResponse>> AsyncGetMclassInfo(::grpc::ClientContext* context, const ::bess::pb::GetMclassInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetMclassInfoResponse>>(AsyncGetMclassInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetMclassInfoResponse>> PrepareAsyncGetMclassInfo(::grpc::ClientContext* context, const ::bess::pb::GetMclassInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetMclassInfoResponse>>(PrepareAsyncGetMclassInfoRaw(context, request, cq));
    }
    // / Remove all modules.
    // /
    // / This RPC will always succeed (unless there is a running worker)
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status ResetModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncResetModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncResetModulesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncResetModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncResetModulesRaw(context, request, cq));
    }
    // / Enumerate all initialized modules
    virtual ::grpc::Status ListModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListModulesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListModulesResponse>> AsyncListModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListModulesResponse>>(AsyncListModulesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListModulesResponse>> PrepareAsyncListModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListModulesResponse>>(PrepareAsyncListModulesRaw(context, request, cq));
    }
    // / Create a new module instance from the given module type
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status CreateModule(::grpc::ClientContext* context, const ::bess::pb::CreateModuleRequest& request, ::bess::pb::CreateModuleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CreateModuleResponse>> AsyncCreateModule(::grpc::ClientContext* context, const ::bess::pb::CreateModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CreateModuleResponse>>(AsyncCreateModuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CreateModuleResponse>> PrepareAsyncCreateModule(::grpc::ClientContext* context, const ::bess::pb::CreateModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CreateModuleResponse>>(PrepareAsyncCreateModuleRaw(context, request, cq));
    }
    // / Destroy an exsting module
    // /
    // / If the module is connected to other modules' input/output gate, they are
    // / disconnected first. All tasks created by the module will also be destoyed.
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status DestroyModule(::grpc::ClientContext* context, const ::bess::pb::DestroyModuleRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncDestroyModule(::grpc::ClientContext* context, const ::bess::pb::DestroyModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncDestroyModuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncDestroyModule(::grpc::ClientContext* context, const ::bess::pb::DestroyModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncDestroyModuleRaw(context, request, cq));
    }
    // / Fetch detailed information of an module instance
    virtual ::grpc::Status GetModuleInfo(::grpc::ClientContext* context, const ::bess::pb::GetModuleInfoRequest& request, ::bess::pb::GetModuleInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetModuleInfoResponse>> AsyncGetModuleInfo(::grpc::ClientContext* context, const ::bess::pb::GetModuleInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetModuleInfoResponse>>(AsyncGetModuleInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetModuleInfoResponse>> PrepareAsyncGetModuleInfo(::grpc::ClientContext* context, const ::bess::pb::GetModuleInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetModuleInfoResponse>>(PrepareAsyncGetModuleInfoRaw(context, request, cq));
    }
    // / Connect two modules.
    // /
    // / Connect between m1's ogate and n2's igate (i.e., ackets sent to m1's ogate
    // / will be fed to m2's igate). The oate can be connected to only one igate,
    // / while the igate can be connected to multiple output gates.
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status ConnectModules(::grpc::ClientContext* context, const ::bess::pb::ConnectModulesRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncConnectModules(::grpc::ClientContext* context, const ::bess::pb::ConnectModulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncConnectModulesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncConnectModules(::grpc::ClientContext* context, const ::bess::pb::ConnectModulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncConnectModulesRaw(context, request, cq));
    }
    // / Disconnect two modules.
    // /
    // / It removes a connection between two modules (you specify the previous one
    // / and its output gate). All packets coming out from the ogate will be
    // / dropped. Once disconnected, the ogate can be connected
    // / to any input gate.
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status DisconnectModules(::grpc::ClientContext* context, const ::bess::pb::DisconnectModulesRequest& request, ::bess::pb::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> AsyncDisconnectModules(::grpc::ClientContext* context, const ::bess::pb::DisconnectModulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(AsyncDisconnectModulesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>> PrepareAsyncDisconnectModules(::grpc::ClientContext* context, const ::bess::pb::DisconnectModulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>>(PrepareAsyncDisconnectModulesRaw(context, request, cq));
    }
    // / Dump various stats about BESS's packet pools
    virtual ::grpc::Status DumpMempool(::grpc::ClientContext* context, const ::bess::pb::DumpMempoolRequest& request, ::bess::pb::DumpMempoolResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::DumpMempoolResponse>> AsyncDumpMempool(::grpc::ClientContext* context, const ::bess::pb::DumpMempoolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::DumpMempoolResponse>>(AsyncDumpMempoolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::DumpMempoolResponse>> PrepareAsyncDumpMempool(::grpc::ClientContext* context, const ::bess::pb::DumpMempoolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::DumpMempoolResponse>>(PrepareAsyncDumpMempoolRaw(context, request, cq));
    }
    // / Send a command to the specified module instance.
    // /
    // / Each module type defines a list of modyle-specific commands, which
    // / allow external programs to communicate with the module at runtime.
    // / See module_msg.proto for details.
    // /
    // / NOTE: Some commands cannot be used if there are running workers.
    // /       For those commands you must pause all workers first.
    virtual ::grpc::Status ModuleCommand(::grpc::ClientContext* context, const ::bess::pb::CommandRequest& request, ::bess::pb::CommandResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>> AsyncModuleCommand(::grpc::ClientContext* context, const ::bess::pb::CommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>>(AsyncModuleCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>> PrepareAsyncModuleCommand(::grpc::ClientContext* context, const ::bess::pb::CommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>>(PrepareAsyncModuleCommandRaw(context, request, cq));
    }
    //  -------------------------------------------------------------------------
    //  Gate hooks
    //  -------------------------------------------------------------------------
    //
    // / Enumerate all gatehook types available
    virtual ::grpc::Status ListGateHookClass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListGateHookClassResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListGateHookClassResponse>> AsyncListGateHookClass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListGateHookClassResponse>>(AsyncListGateHookClassRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListGateHookClassResponse>> PrepareAsyncListGateHookClass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListGateHookClassResponse>>(PrepareAsyncListGateHookClassRaw(context, request, cq));
    }
    // / Query detailed information of a gatehook type
    virtual ::grpc::Status GetGateHookClassInfo(::grpc::ClientContext* context, const ::bess::pb::GetGateHookClassInfoRequest& request, ::bess::pb::GetGateHookClassInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetGateHookClassInfoResponse>> AsyncGetGateHookClassInfo(::grpc::ClientContext* context, const ::bess::pb::GetGateHookClassInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetGateHookClassInfoResponse>>(AsyncGetGateHookClassInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetGateHookClassInfoResponse>> PrepareAsyncGetGateHookClassInfo(::grpc::ClientContext* context, const ::bess::pb::GetGateHookClassInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetGateHookClassInfoResponse>>(PrepareAsyncGetGateHookClassInfoRaw(context, request, cq));
    }
    // / Enable/Disable a gate hook.
    virtual ::grpc::Status ConfigureGateHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureGateHookRequest& request, ::bess::pb::ConfigureGateHookResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ConfigureGateHookResponse>> AsyncConfigureGateHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureGateHookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ConfigureGateHookResponse>>(AsyncConfigureGateHookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ConfigureGateHookResponse>> PrepareAsyncConfigureGateHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureGateHookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ConfigureGateHookResponse>>(PrepareAsyncConfigureGateHookRaw(context, request, cq));
    }
    // / Enumerate all gatehook installed
    virtual ::grpc::Status ListGateHooks(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListGateHooksResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListGateHooksResponse>> AsyncListGateHooks(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListGateHooksResponse>>(AsyncListGateHooksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListGateHooksResponse>> PrepareAsyncListGateHooks(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListGateHooksResponse>>(PrepareAsyncListGateHooksRaw(context, request, cq));
    }
    // / Send command to gate hook instance.
    virtual ::grpc::Status GateHookCommand(::grpc::ClientContext* context, const ::bess::pb::GateHookCommandRequest& request, ::bess::pb::CommandResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>> AsyncGateHookCommand(::grpc::ClientContext* context, const ::bess::pb::GateHookCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>>(AsyncGateHookCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>> PrepareAsyncGateHookCommand(::grpc::ClientContext* context, const ::bess::pb::GateHookCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>>(PrepareAsyncGateHookCommandRaw(context, request, cq));
    }
    //  -------------------------------------------------------------------------
    //  Resume hooks
    //  -------------------------------------------------------------------------
    //
    // / Enable/Disable a resume hook.
    virtual ::grpc::Status ConfigureResumeHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureResumeHookRequest& request, ::bess::pb::CommandResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>> AsyncConfigureResumeHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureResumeHookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>>(AsyncConfigureResumeHookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>> PrepareAsyncConfigureResumeHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureResumeHookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>>(PrepareAsyncConfigureResumeHookRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      //  -------------------------------------------------------------------------
      //  System
      //  -------------------------------------------------------------------------
      //
      // / Query version of bessd
      virtual void GetVersion(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::VersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVersion(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::VersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Reset the current packet processing datapath to the initial state.
      // /
      // / This command is identical to the following sequence:
      // /   ResetModules()
      // /   ResetPorts()
      // /   ResetTcs()
      // /   ResetWorkers()
      // / As it clears everything, BESS should appear as if the daemon has freshly
      // / started (if not, it is a bug; please report).
      // /
      // / NOTE: There should be no running worker to run this command.
      virtual void ResetAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Terminate the BESS daemon.
      // /
      // / BESS daemon shuts off in a graceful manner. Note that this command is
      // / "asynchronous": this command doesn't block until the BESS daemon has
      // / shut off.
      // /
      // / NOTE: There should be no running worker to run this command.
      // / FIXME: rename (e.g., Terminate)
      virtual void KillBess(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KillBess(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Import a plugin
      // /
      // / At the moment plugins can only contain module types,
      // / but might also support drivers/hooks/schedulers in the future.
      virtual void ImportPlugin(::grpc::ClientContext* context, const ::bess::pb::ImportPluginRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ImportPlugin(::grpc::ClientContext* context, const ::bess::pb::ImportPluginRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Unload a plugin
      // /
      // / At the moment plugins can only contain module types,
      // / but might also support drivers/hooks/schedulers in the future.
      virtual void UnloadPlugin(::grpc::ClientContext* context, const ::bess::pb::UnloadPluginRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UnloadPlugin(::grpc::ClientContext* context, const ::bess::pb::UnloadPluginRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / List imported plugins
      // /
      // / At the moment plugins can only contain module types,
      // / but might also support drivers/hooks/schedulers in the future.
      virtual void ListPlugins(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListPluginsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListPlugins(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListPluginsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //  -------------------------------------------------------------------------
      //  Worker
      //  -------------------------------------------------------------------------
      //
      // / Pause all running workers temporarily
      // /
      // / Some RPC commands to BESS or individual modules/ports require that
      // / threads must be inactive, to avoid race conditions.
      // / For such commands, use PauseALl at the beginning and ResumeAll at the end.
      // /  PauseAll()
      // /   SomeCommand1()
      // /   SomeCommand2()
      // /   ...
      // /  ResumeAll()
      // / Keep the duration as short as possible, to avoid packet drops.
      virtual void PauseAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PauseAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Pause the specified worker temporarily
      // /
      // / Some RPC commands to BESS or individual modules/ports require that
      // / threads must be inactive, to avoid race conditions.
      // / For such commands, use PauseWorker at the beginning and ResumeWorker at the end.
      // /  PauseWorker(0)
      // /   SomeCommand1()
      // /   SomeCommand2()
      // /   ...
      // /  ResumeWorker(0)
      // / Keep the duration as short as possible, to avoid packet drops.
      virtual void PauseWorker(::grpc::ClientContext* context, const ::bess::pb::PauseWorkerRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PauseWorker(::grpc::ClientContext* context, const ::bess::pb::PauseWorkerRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Resume the specified worker
      virtual void ResumeWorker(::grpc::ClientContext* context, const ::bess::pb::ResumeWorkerRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResumeWorker(::grpc::ClientContext* context, const ::bess::pb::ResumeWorkerRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Resume all paused workers
      virtual void ResumeAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResumeAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Remove all existing workers
      // /
      // / NOTE: There should be no running worker to run this command.
      virtual void ResetWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Enumerate all existing workers
      virtual void ListWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListWorkersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListWorkersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Create a new worker
      // /
      // / NOTE: There should be no running worker to run this command.
      virtual void AddWorker(::grpc::ClientContext* context, const ::bess::pb::AddWorkerRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddWorker(::grpc::ClientContext* context, const ::bess::pb::AddWorkerRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Remove a single worker
      // /
      // / NOTE: There should be no running worker to run this command.
      virtual void DestroyWorker(::grpc::ClientContext* context, const ::bess::pb::DestroyWorkerRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DestroyWorker(::grpc::ClientContext* context, const ::bess::pb::DestroyWorkerRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //  -------------------------------------------------------------------------
      //  Traffic classe & task
      //  -------------------------------------------------------------------------
      //
      // / Remove all existing traffic classes
      // /
      // / NOTE: There should be no running worker to run this command.
      virtual void ResetTcs(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetTcs(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Enumerate all existing workers
      virtual void ListTcs(::grpc::ClientContext* context, const ::bess::pb::ListTcsRequest* request, ::bess::pb::ListTcsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListTcs(::grpc::ClientContext* context, const ::bess::pb::ListTcsRequest* request, ::bess::pb::ListTcsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Check scheduling contraints
      virtual void CheckSchedulingConstraints(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::CheckSchedulingConstraintsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckSchedulingConstraints(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::CheckSchedulingConstraintsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Create a new traffic class
      // /
      // / NOTE: There should be no running worker to run this command.
      virtual void AddTc(::grpc::ClientContext* context, const ::bess::pb::AddTcRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddTc(::grpc::ClientContext* context, const ::bess::pb::AddTcRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Update parameters of an existing traffic class
      // /
      // / NOTE: There should be no running worker to run this command.
      virtual void UpdateTcParams(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParamsRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateTcParams(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParamsRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Change parent (and child arguments) of an existing traffic class
      // /
      // / NOTE: There should be no running worker to run this command.
      virtual void UpdateTcParent(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParentRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateTcParent(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParentRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Collect statistics of a traffic class
      virtual void GetTcStats(::grpc::ClientContext* context, const ::bess::pb::GetTcStatsRequest* request, ::bess::pb::GetTcStatsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTcStats(::grpc::ClientContext* context, const ::bess::pb::GetTcStatsRequest* request, ::bess::pb::GetTcStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //  -------------------------------------------------------------------------
      //  Port
      //  -------------------------------------------------------------------------
      //
      // / Enumerate all port drivers available
      virtual void ListDrivers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListDriversResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListDrivers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListDriversResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Query detailed information of a port driver
      virtual void GetDriverInfo(::grpc::ClientContext* context, const ::bess::pb::GetDriverInfoRequest* request, ::bess::pb::GetDriverInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetDriverInfo(::grpc::ClientContext* context, const ::bess::pb::GetDriverInfoRequest* request, ::bess::pb::GetDriverInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Remove all initialized ports
      // /
      // / Will fail if there are modules that are still using ports.
      // / (e.g., PortInc, PortOut, QueueInc, QueueOut)
      // /
      // / NOTE: There should be no running worker to run this command.
      virtual void ResetPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Enumerate all initialized ports
      virtual void ListPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListPortsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListPortsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Create a new port from the specified driver
      virtual void CreatePort(::grpc::ClientContext* context, const ::bess::pb::CreatePortRequest* request, ::bess::pb::CreatePortResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreatePort(::grpc::ClientContext* context, const ::bess::pb::CreatePortRequest* request, ::bess::pb::CreatePortResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Remove a port
      // /
      // / The port should not be being used by a port-related module.
      // / (e.g., PortInc, PortOut, QueueInc, QueueOut)
      virtual void DestroyPort(::grpc::ClientContext* context, const ::bess::pb::DestroyPortRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DestroyPort(::grpc::ClientContext* context, const ::bess::pb::DestroyPortRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Runtime-updatable configuration
      virtual void SetPortConf(::grpc::ClientContext* context, const ::bess::pb::SetPortConfRequest* request, ::bess::pb::CommandResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPortConf(::grpc::ClientContext* context, const ::bess::pb::SetPortConfRequest* request, ::bess::pb::CommandResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPortConf(::grpc::ClientContext* context, const ::bess::pb::GetPortConfRequest* request, ::bess::pb::GetPortConfResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPortConf(::grpc::ClientContext* context, const ::bess::pb::GetPortConfRequest* request, ::bess::pb::GetPortConfResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Collect port statistics
      // /
      // / At the moment, per-queue stats are not supported.
      virtual void GetPortStats(::grpc::ClientContext* context, const ::bess::pb::GetPortStatsRequest* request, ::bess::pb::GetPortStatsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPortStats(::grpc::ClientContext* context, const ::bess::pb::GetPortStatsRequest* request, ::bess::pb::GetPortStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Query link status
      virtual void GetLinkStatus(::grpc::ClientContext* context, const ::bess::pb::GetLinkStatusRequest* request, ::bess::pb::GetLinkStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLinkStatus(::grpc::ClientContext* context, const ::bess::pb::GetLinkStatusRequest* request, ::bess::pb::GetLinkStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // TODO: Add PortCommand, like ModuleCommand, which performs driver-specific
      //       actions on a port.
      //
      //  -------------------------------------------------------------------------
      //  Module
      //  -------------------------------------------------------------------------
      //
      // / Enumerate all module types available
      virtual void ListMclass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListMclassResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListMclass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListMclassResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Query detailed information of a module type
      virtual void GetMclassInfo(::grpc::ClientContext* context, const ::bess::pb::GetMclassInfoRequest* request, ::bess::pb::GetMclassInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMclassInfo(::grpc::ClientContext* context, const ::bess::pb::GetMclassInfoRequest* request, ::bess::pb::GetMclassInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Remove all modules.
      // /
      // / This RPC will always succeed (unless there is a running worker)
      // /
      // / NOTE: There should be no running worker to run this command.
      virtual void ResetModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Enumerate all initialized modules
      virtual void ListModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListModulesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListModulesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Create a new module instance from the given module type
      // /
      // / NOTE: There should be no running worker to run this command.
      virtual void CreateModule(::grpc::ClientContext* context, const ::bess::pb::CreateModuleRequest* request, ::bess::pb::CreateModuleResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateModule(::grpc::ClientContext* context, const ::bess::pb::CreateModuleRequest* request, ::bess::pb::CreateModuleResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Destroy an exsting module
      // /
      // / If the module is connected to other modules' input/output gate, they are
      // / disconnected first. All tasks created by the module will also be destoyed.
      // /
      // / NOTE: There should be no running worker to run this command.
      virtual void DestroyModule(::grpc::ClientContext* context, const ::bess::pb::DestroyModuleRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DestroyModule(::grpc::ClientContext* context, const ::bess::pb::DestroyModuleRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Fetch detailed information of an module instance
      virtual void GetModuleInfo(::grpc::ClientContext* context, const ::bess::pb::GetModuleInfoRequest* request, ::bess::pb::GetModuleInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetModuleInfo(::grpc::ClientContext* context, const ::bess::pb::GetModuleInfoRequest* request, ::bess::pb::GetModuleInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Connect two modules.
      // /
      // / Connect between m1's ogate and n2's igate (i.e., ackets sent to m1's ogate
      // / will be fed to m2's igate). The oate can be connected to only one igate,
      // / while the igate can be connected to multiple output gates.
      // /
      // / NOTE: There should be no running worker to run this command.
      virtual void ConnectModules(::grpc::ClientContext* context, const ::bess::pb::ConnectModulesRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ConnectModules(::grpc::ClientContext* context, const ::bess::pb::ConnectModulesRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Disconnect two modules.
      // /
      // / It removes a connection between two modules (you specify the previous one
      // / and its output gate). All packets coming out from the ogate will be
      // / dropped. Once disconnected, the ogate can be connected
      // / to any input gate.
      // /
      // / NOTE: There should be no running worker to run this command.
      virtual void DisconnectModules(::grpc::ClientContext* context, const ::bess::pb::DisconnectModulesRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DisconnectModules(::grpc::ClientContext* context, const ::bess::pb::DisconnectModulesRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Dump various stats about BESS's packet pools
      virtual void DumpMempool(::grpc::ClientContext* context, const ::bess::pb::DumpMempoolRequest* request, ::bess::pb::DumpMempoolResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DumpMempool(::grpc::ClientContext* context, const ::bess::pb::DumpMempoolRequest* request, ::bess::pb::DumpMempoolResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Send a command to the specified module instance.
      // /
      // / Each module type defines a list of modyle-specific commands, which
      // / allow external programs to communicate with the module at runtime.
      // / See module_msg.proto for details.
      // /
      // / NOTE: Some commands cannot be used if there are running workers.
      // /       For those commands you must pause all workers first.
      virtual void ModuleCommand(::grpc::ClientContext* context, const ::bess::pb::CommandRequest* request, ::bess::pb::CommandResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ModuleCommand(::grpc::ClientContext* context, const ::bess::pb::CommandRequest* request, ::bess::pb::CommandResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //  -------------------------------------------------------------------------
      //  Gate hooks
      //  -------------------------------------------------------------------------
      //
      // / Enumerate all gatehook types available
      virtual void ListGateHookClass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListGateHookClassResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListGateHookClass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListGateHookClassResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Query detailed information of a gatehook type
      virtual void GetGateHookClassInfo(::grpc::ClientContext* context, const ::bess::pb::GetGateHookClassInfoRequest* request, ::bess::pb::GetGateHookClassInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGateHookClassInfo(::grpc::ClientContext* context, const ::bess::pb::GetGateHookClassInfoRequest* request, ::bess::pb::GetGateHookClassInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Enable/Disable a gate hook.
      virtual void ConfigureGateHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureGateHookRequest* request, ::bess::pb::ConfigureGateHookResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ConfigureGateHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureGateHookRequest* request, ::bess::pb::ConfigureGateHookResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Enumerate all gatehook installed
      virtual void ListGateHooks(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListGateHooksResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListGateHooks(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListGateHooksResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / Send command to gate hook instance.
      virtual void GateHookCommand(::grpc::ClientContext* context, const ::bess::pb::GateHookCommandRequest* request, ::bess::pb::CommandResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GateHookCommand(::grpc::ClientContext* context, const ::bess::pb::GateHookCommandRequest* request, ::bess::pb::CommandResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //  -------------------------------------------------------------------------
      //  Resume hooks
      //  -------------------------------------------------------------------------
      //
      // / Enable/Disable a resume hook.
      virtual void ConfigureResumeHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureResumeHookRequest* request, ::bess::pb::CommandResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ConfigureResumeHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureResumeHookRequest* request, ::bess::pb::CommandResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::VersionResponse>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::VersionResponse>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncResetAllRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncResetAllRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncKillBessRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncKillBessRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncImportPluginRaw(::grpc::ClientContext* context, const ::bess::pb::ImportPluginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncImportPluginRaw(::grpc::ClientContext* context, const ::bess::pb::ImportPluginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncUnloadPluginRaw(::grpc::ClientContext* context, const ::bess::pb::UnloadPluginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncUnloadPluginRaw(::grpc::ClientContext* context, const ::bess::pb::UnloadPluginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListPluginsResponse>* AsyncListPluginsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListPluginsResponse>* PrepareAsyncListPluginsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncPauseAllRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncPauseAllRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncPauseWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::PauseWorkerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncPauseWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::PauseWorkerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncResumeWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::ResumeWorkerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncResumeWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::ResumeWorkerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncResumeAllRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncResumeAllRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncResetWorkersRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncResetWorkersRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListWorkersResponse>* AsyncListWorkersRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListWorkersResponse>* PrepareAsyncListWorkersRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncAddWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::AddWorkerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncAddWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::AddWorkerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncDestroyWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::DestroyWorkerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncDestroyWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::DestroyWorkerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncResetTcsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncResetTcsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListTcsResponse>* AsyncListTcsRaw(::grpc::ClientContext* context, const ::bess::pb::ListTcsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListTcsResponse>* PrepareAsyncListTcsRaw(::grpc::ClientContext* context, const ::bess::pb::ListTcsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CheckSchedulingConstraintsResponse>* AsyncCheckSchedulingConstraintsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CheckSchedulingConstraintsResponse>* PrepareAsyncCheckSchedulingConstraintsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncAddTcRaw(::grpc::ClientContext* context, const ::bess::pb::AddTcRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncAddTcRaw(::grpc::ClientContext* context, const ::bess::pb::AddTcRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncUpdateTcParamsRaw(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncUpdateTcParamsRaw(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncUpdateTcParentRaw(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncUpdateTcParentRaw(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetTcStatsResponse>* AsyncGetTcStatsRaw(::grpc::ClientContext* context, const ::bess::pb::GetTcStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetTcStatsResponse>* PrepareAsyncGetTcStatsRaw(::grpc::ClientContext* context, const ::bess::pb::GetTcStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListDriversResponse>* AsyncListDriversRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListDriversResponse>* PrepareAsyncListDriversRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetDriverInfoResponse>* AsyncGetDriverInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetDriverInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetDriverInfoResponse>* PrepareAsyncGetDriverInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetDriverInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncResetPortsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncResetPortsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListPortsResponse>* AsyncListPortsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListPortsResponse>* PrepareAsyncListPortsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CreatePortResponse>* AsyncCreatePortRaw(::grpc::ClientContext* context, const ::bess::pb::CreatePortRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CreatePortResponse>* PrepareAsyncCreatePortRaw(::grpc::ClientContext* context, const ::bess::pb::CreatePortRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncDestroyPortRaw(::grpc::ClientContext* context, const ::bess::pb::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncDestroyPortRaw(::grpc::ClientContext* context, const ::bess::pb::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>* AsyncSetPortConfRaw(::grpc::ClientContext* context, const ::bess::pb::SetPortConfRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>* PrepareAsyncSetPortConfRaw(::grpc::ClientContext* context, const ::bess::pb::SetPortConfRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetPortConfResponse>* AsyncGetPortConfRaw(::grpc::ClientContext* context, const ::bess::pb::GetPortConfRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetPortConfResponse>* PrepareAsyncGetPortConfRaw(::grpc::ClientContext* context, const ::bess::pb::GetPortConfRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetPortStatsResponse>* AsyncGetPortStatsRaw(::grpc::ClientContext* context, const ::bess::pb::GetPortStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetPortStatsResponse>* PrepareAsyncGetPortStatsRaw(::grpc::ClientContext* context, const ::bess::pb::GetPortStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetLinkStatusResponse>* AsyncGetLinkStatusRaw(::grpc::ClientContext* context, const ::bess::pb::GetLinkStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetLinkStatusResponse>* PrepareAsyncGetLinkStatusRaw(::grpc::ClientContext* context, const ::bess::pb::GetLinkStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListMclassResponse>* AsyncListMclassRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListMclassResponse>* PrepareAsyncListMclassRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetMclassInfoResponse>* AsyncGetMclassInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetMclassInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetMclassInfoResponse>* PrepareAsyncGetMclassInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetMclassInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncResetModulesRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncResetModulesRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListModulesResponse>* AsyncListModulesRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListModulesResponse>* PrepareAsyncListModulesRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CreateModuleResponse>* AsyncCreateModuleRaw(::grpc::ClientContext* context, const ::bess::pb::CreateModuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CreateModuleResponse>* PrepareAsyncCreateModuleRaw(::grpc::ClientContext* context, const ::bess::pb::CreateModuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncDestroyModuleRaw(::grpc::ClientContext* context, const ::bess::pb::DestroyModuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncDestroyModuleRaw(::grpc::ClientContext* context, const ::bess::pb::DestroyModuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetModuleInfoResponse>* AsyncGetModuleInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetModuleInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetModuleInfoResponse>* PrepareAsyncGetModuleInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetModuleInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncConnectModulesRaw(::grpc::ClientContext* context, const ::bess::pb::ConnectModulesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncConnectModulesRaw(::grpc::ClientContext* context, const ::bess::pb::ConnectModulesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* AsyncDisconnectModulesRaw(::grpc::ClientContext* context, const ::bess::pb::DisconnectModulesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::EmptyResponse>* PrepareAsyncDisconnectModulesRaw(::grpc::ClientContext* context, const ::bess::pb::DisconnectModulesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::DumpMempoolResponse>* AsyncDumpMempoolRaw(::grpc::ClientContext* context, const ::bess::pb::DumpMempoolRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::DumpMempoolResponse>* PrepareAsyncDumpMempoolRaw(::grpc::ClientContext* context, const ::bess::pb::DumpMempoolRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>* AsyncModuleCommandRaw(::grpc::ClientContext* context, const ::bess::pb::CommandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>* PrepareAsyncModuleCommandRaw(::grpc::ClientContext* context, const ::bess::pb::CommandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListGateHookClassResponse>* AsyncListGateHookClassRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListGateHookClassResponse>* PrepareAsyncListGateHookClassRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetGateHookClassInfoResponse>* AsyncGetGateHookClassInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetGateHookClassInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::GetGateHookClassInfoResponse>* PrepareAsyncGetGateHookClassInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetGateHookClassInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ConfigureGateHookResponse>* AsyncConfigureGateHookRaw(::grpc::ClientContext* context, const ::bess::pb::ConfigureGateHookRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ConfigureGateHookResponse>* PrepareAsyncConfigureGateHookRaw(::grpc::ClientContext* context, const ::bess::pb::ConfigureGateHookRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListGateHooksResponse>* AsyncListGateHooksRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::ListGateHooksResponse>* PrepareAsyncListGateHooksRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>* AsyncGateHookCommandRaw(::grpc::ClientContext* context, const ::bess::pb::GateHookCommandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>* PrepareAsyncGateHookCommandRaw(::grpc::ClientContext* context, const ::bess::pb::GateHookCommandRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>* AsyncConfigureResumeHookRaw(::grpc::ClientContext* context, const ::bess::pb::ConfigureResumeHookRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bess::pb::CommandResponse>* PrepareAsyncConfigureResumeHookRaw(::grpc::ClientContext* context, const ::bess::pb::ConfigureResumeHookRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::VersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::VersionResponse>> AsyncGetVersion(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::VersionResponse>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::VersionResponse>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::VersionResponse>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    ::grpc::Status ResetAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncResetAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncResetAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncResetAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncResetAllRaw(context, request, cq));
    }
    ::grpc::Status KillBess(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncKillBess(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncKillBessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncKillBess(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncKillBessRaw(context, request, cq));
    }
    ::grpc::Status ImportPlugin(::grpc::ClientContext* context, const ::bess::pb::ImportPluginRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncImportPlugin(::grpc::ClientContext* context, const ::bess::pb::ImportPluginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncImportPluginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncImportPlugin(::grpc::ClientContext* context, const ::bess::pb::ImportPluginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncImportPluginRaw(context, request, cq));
    }
    ::grpc::Status UnloadPlugin(::grpc::ClientContext* context, const ::bess::pb::UnloadPluginRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncUnloadPlugin(::grpc::ClientContext* context, const ::bess::pb::UnloadPluginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncUnloadPluginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncUnloadPlugin(::grpc::ClientContext* context, const ::bess::pb::UnloadPluginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncUnloadPluginRaw(context, request, cq));
    }
    ::grpc::Status ListPlugins(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListPluginsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListPluginsResponse>> AsyncListPlugins(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListPluginsResponse>>(AsyncListPluginsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListPluginsResponse>> PrepareAsyncListPlugins(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListPluginsResponse>>(PrepareAsyncListPluginsRaw(context, request, cq));
    }
    ::grpc::Status PauseAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncPauseAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncPauseAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncPauseAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncPauseAllRaw(context, request, cq));
    }
    ::grpc::Status PauseWorker(::grpc::ClientContext* context, const ::bess::pb::PauseWorkerRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncPauseWorker(::grpc::ClientContext* context, const ::bess::pb::PauseWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncPauseWorkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncPauseWorker(::grpc::ClientContext* context, const ::bess::pb::PauseWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncPauseWorkerRaw(context, request, cq));
    }
    ::grpc::Status ResumeWorker(::grpc::ClientContext* context, const ::bess::pb::ResumeWorkerRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncResumeWorker(::grpc::ClientContext* context, const ::bess::pb::ResumeWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncResumeWorkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncResumeWorker(::grpc::ClientContext* context, const ::bess::pb::ResumeWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncResumeWorkerRaw(context, request, cq));
    }
    ::grpc::Status ResumeAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncResumeAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncResumeAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncResumeAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncResumeAllRaw(context, request, cq));
    }
    ::grpc::Status ResetWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncResetWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncResetWorkersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncResetWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncResetWorkersRaw(context, request, cq));
    }
    ::grpc::Status ListWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListWorkersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListWorkersResponse>> AsyncListWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListWorkersResponse>>(AsyncListWorkersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListWorkersResponse>> PrepareAsyncListWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListWorkersResponse>>(PrepareAsyncListWorkersRaw(context, request, cq));
    }
    ::grpc::Status AddWorker(::grpc::ClientContext* context, const ::bess::pb::AddWorkerRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncAddWorker(::grpc::ClientContext* context, const ::bess::pb::AddWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncAddWorkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncAddWorker(::grpc::ClientContext* context, const ::bess::pb::AddWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncAddWorkerRaw(context, request, cq));
    }
    ::grpc::Status DestroyWorker(::grpc::ClientContext* context, const ::bess::pb::DestroyWorkerRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncDestroyWorker(::grpc::ClientContext* context, const ::bess::pb::DestroyWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncDestroyWorkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncDestroyWorker(::grpc::ClientContext* context, const ::bess::pb::DestroyWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncDestroyWorkerRaw(context, request, cq));
    }
    ::grpc::Status ResetTcs(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncResetTcs(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncResetTcsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncResetTcs(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncResetTcsRaw(context, request, cq));
    }
    ::grpc::Status ListTcs(::grpc::ClientContext* context, const ::bess::pb::ListTcsRequest& request, ::bess::pb::ListTcsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListTcsResponse>> AsyncListTcs(::grpc::ClientContext* context, const ::bess::pb::ListTcsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListTcsResponse>>(AsyncListTcsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListTcsResponse>> PrepareAsyncListTcs(::grpc::ClientContext* context, const ::bess::pb::ListTcsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListTcsResponse>>(PrepareAsyncListTcsRaw(context, request, cq));
    }
    ::grpc::Status CheckSchedulingConstraints(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::CheckSchedulingConstraintsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CheckSchedulingConstraintsResponse>> AsyncCheckSchedulingConstraints(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CheckSchedulingConstraintsResponse>>(AsyncCheckSchedulingConstraintsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CheckSchedulingConstraintsResponse>> PrepareAsyncCheckSchedulingConstraints(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CheckSchedulingConstraintsResponse>>(PrepareAsyncCheckSchedulingConstraintsRaw(context, request, cq));
    }
    ::grpc::Status AddTc(::grpc::ClientContext* context, const ::bess::pb::AddTcRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncAddTc(::grpc::ClientContext* context, const ::bess::pb::AddTcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncAddTcRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncAddTc(::grpc::ClientContext* context, const ::bess::pb::AddTcRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncAddTcRaw(context, request, cq));
    }
    ::grpc::Status UpdateTcParams(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParamsRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncUpdateTcParams(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncUpdateTcParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncUpdateTcParams(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncUpdateTcParamsRaw(context, request, cq));
    }
    ::grpc::Status UpdateTcParent(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParentRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncUpdateTcParent(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncUpdateTcParentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncUpdateTcParent(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncUpdateTcParentRaw(context, request, cq));
    }
    ::grpc::Status GetTcStats(::grpc::ClientContext* context, const ::bess::pb::GetTcStatsRequest& request, ::bess::pb::GetTcStatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetTcStatsResponse>> AsyncGetTcStats(::grpc::ClientContext* context, const ::bess::pb::GetTcStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetTcStatsResponse>>(AsyncGetTcStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetTcStatsResponse>> PrepareAsyncGetTcStats(::grpc::ClientContext* context, const ::bess::pb::GetTcStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetTcStatsResponse>>(PrepareAsyncGetTcStatsRaw(context, request, cq));
    }
    ::grpc::Status ListDrivers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListDriversResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListDriversResponse>> AsyncListDrivers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListDriversResponse>>(AsyncListDriversRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListDriversResponse>> PrepareAsyncListDrivers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListDriversResponse>>(PrepareAsyncListDriversRaw(context, request, cq));
    }
    ::grpc::Status GetDriverInfo(::grpc::ClientContext* context, const ::bess::pb::GetDriverInfoRequest& request, ::bess::pb::GetDriverInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetDriverInfoResponse>> AsyncGetDriverInfo(::grpc::ClientContext* context, const ::bess::pb::GetDriverInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetDriverInfoResponse>>(AsyncGetDriverInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetDriverInfoResponse>> PrepareAsyncGetDriverInfo(::grpc::ClientContext* context, const ::bess::pb::GetDriverInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetDriverInfoResponse>>(PrepareAsyncGetDriverInfoRaw(context, request, cq));
    }
    ::grpc::Status ResetPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncResetPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncResetPortsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncResetPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncResetPortsRaw(context, request, cq));
    }
    ::grpc::Status ListPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListPortsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListPortsResponse>> AsyncListPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListPortsResponse>>(AsyncListPortsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListPortsResponse>> PrepareAsyncListPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListPortsResponse>>(PrepareAsyncListPortsRaw(context, request, cq));
    }
    ::grpc::Status CreatePort(::grpc::ClientContext* context, const ::bess::pb::CreatePortRequest& request, ::bess::pb::CreatePortResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CreatePortResponse>> AsyncCreatePort(::grpc::ClientContext* context, const ::bess::pb::CreatePortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CreatePortResponse>>(AsyncCreatePortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CreatePortResponse>> PrepareAsyncCreatePort(::grpc::ClientContext* context, const ::bess::pb::CreatePortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CreatePortResponse>>(PrepareAsyncCreatePortRaw(context, request, cq));
    }
    ::grpc::Status DestroyPort(::grpc::ClientContext* context, const ::bess::pb::DestroyPortRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncDestroyPort(::grpc::ClientContext* context, const ::bess::pb::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncDestroyPortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncDestroyPort(::grpc::ClientContext* context, const ::bess::pb::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncDestroyPortRaw(context, request, cq));
    }
    ::grpc::Status SetPortConf(::grpc::ClientContext* context, const ::bess::pb::SetPortConfRequest& request, ::bess::pb::CommandResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>> AsyncSetPortConf(::grpc::ClientContext* context, const ::bess::pb::SetPortConfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>>(AsyncSetPortConfRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>> PrepareAsyncSetPortConf(::grpc::ClientContext* context, const ::bess::pb::SetPortConfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>>(PrepareAsyncSetPortConfRaw(context, request, cq));
    }
    ::grpc::Status GetPortConf(::grpc::ClientContext* context, const ::bess::pb::GetPortConfRequest& request, ::bess::pb::GetPortConfResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetPortConfResponse>> AsyncGetPortConf(::grpc::ClientContext* context, const ::bess::pb::GetPortConfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetPortConfResponse>>(AsyncGetPortConfRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetPortConfResponse>> PrepareAsyncGetPortConf(::grpc::ClientContext* context, const ::bess::pb::GetPortConfRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetPortConfResponse>>(PrepareAsyncGetPortConfRaw(context, request, cq));
    }
    ::grpc::Status GetPortStats(::grpc::ClientContext* context, const ::bess::pb::GetPortStatsRequest& request, ::bess::pb::GetPortStatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetPortStatsResponse>> AsyncGetPortStats(::grpc::ClientContext* context, const ::bess::pb::GetPortStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetPortStatsResponse>>(AsyncGetPortStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetPortStatsResponse>> PrepareAsyncGetPortStats(::grpc::ClientContext* context, const ::bess::pb::GetPortStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetPortStatsResponse>>(PrepareAsyncGetPortStatsRaw(context, request, cq));
    }
    ::grpc::Status GetLinkStatus(::grpc::ClientContext* context, const ::bess::pb::GetLinkStatusRequest& request, ::bess::pb::GetLinkStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetLinkStatusResponse>> AsyncGetLinkStatus(::grpc::ClientContext* context, const ::bess::pb::GetLinkStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetLinkStatusResponse>>(AsyncGetLinkStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetLinkStatusResponse>> PrepareAsyncGetLinkStatus(::grpc::ClientContext* context, const ::bess::pb::GetLinkStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetLinkStatusResponse>>(PrepareAsyncGetLinkStatusRaw(context, request, cq));
    }
    ::grpc::Status ListMclass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListMclassResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListMclassResponse>> AsyncListMclass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListMclassResponse>>(AsyncListMclassRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListMclassResponse>> PrepareAsyncListMclass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListMclassResponse>>(PrepareAsyncListMclassRaw(context, request, cq));
    }
    ::grpc::Status GetMclassInfo(::grpc::ClientContext* context, const ::bess::pb::GetMclassInfoRequest& request, ::bess::pb::GetMclassInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetMclassInfoResponse>> AsyncGetMclassInfo(::grpc::ClientContext* context, const ::bess::pb::GetMclassInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetMclassInfoResponse>>(AsyncGetMclassInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetMclassInfoResponse>> PrepareAsyncGetMclassInfo(::grpc::ClientContext* context, const ::bess::pb::GetMclassInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetMclassInfoResponse>>(PrepareAsyncGetMclassInfoRaw(context, request, cq));
    }
    ::grpc::Status ResetModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncResetModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncResetModulesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncResetModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncResetModulesRaw(context, request, cq));
    }
    ::grpc::Status ListModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListModulesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListModulesResponse>> AsyncListModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListModulesResponse>>(AsyncListModulesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListModulesResponse>> PrepareAsyncListModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListModulesResponse>>(PrepareAsyncListModulesRaw(context, request, cq));
    }
    ::grpc::Status CreateModule(::grpc::ClientContext* context, const ::bess::pb::CreateModuleRequest& request, ::bess::pb::CreateModuleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CreateModuleResponse>> AsyncCreateModule(::grpc::ClientContext* context, const ::bess::pb::CreateModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CreateModuleResponse>>(AsyncCreateModuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CreateModuleResponse>> PrepareAsyncCreateModule(::grpc::ClientContext* context, const ::bess::pb::CreateModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CreateModuleResponse>>(PrepareAsyncCreateModuleRaw(context, request, cq));
    }
    ::grpc::Status DestroyModule(::grpc::ClientContext* context, const ::bess::pb::DestroyModuleRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncDestroyModule(::grpc::ClientContext* context, const ::bess::pb::DestroyModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncDestroyModuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncDestroyModule(::grpc::ClientContext* context, const ::bess::pb::DestroyModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncDestroyModuleRaw(context, request, cq));
    }
    ::grpc::Status GetModuleInfo(::grpc::ClientContext* context, const ::bess::pb::GetModuleInfoRequest& request, ::bess::pb::GetModuleInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetModuleInfoResponse>> AsyncGetModuleInfo(::grpc::ClientContext* context, const ::bess::pb::GetModuleInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetModuleInfoResponse>>(AsyncGetModuleInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetModuleInfoResponse>> PrepareAsyncGetModuleInfo(::grpc::ClientContext* context, const ::bess::pb::GetModuleInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetModuleInfoResponse>>(PrepareAsyncGetModuleInfoRaw(context, request, cq));
    }
    ::grpc::Status ConnectModules(::grpc::ClientContext* context, const ::bess::pb::ConnectModulesRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncConnectModules(::grpc::ClientContext* context, const ::bess::pb::ConnectModulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncConnectModulesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncConnectModules(::grpc::ClientContext* context, const ::bess::pb::ConnectModulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncConnectModulesRaw(context, request, cq));
    }
    ::grpc::Status DisconnectModules(::grpc::ClientContext* context, const ::bess::pb::DisconnectModulesRequest& request, ::bess::pb::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> AsyncDisconnectModules(::grpc::ClientContext* context, const ::bess::pb::DisconnectModulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(AsyncDisconnectModulesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>> PrepareAsyncDisconnectModules(::grpc::ClientContext* context, const ::bess::pb::DisconnectModulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>>(PrepareAsyncDisconnectModulesRaw(context, request, cq));
    }
    ::grpc::Status DumpMempool(::grpc::ClientContext* context, const ::bess::pb::DumpMempoolRequest& request, ::bess::pb::DumpMempoolResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::DumpMempoolResponse>> AsyncDumpMempool(::grpc::ClientContext* context, const ::bess::pb::DumpMempoolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::DumpMempoolResponse>>(AsyncDumpMempoolRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::DumpMempoolResponse>> PrepareAsyncDumpMempool(::grpc::ClientContext* context, const ::bess::pb::DumpMempoolRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::DumpMempoolResponse>>(PrepareAsyncDumpMempoolRaw(context, request, cq));
    }
    ::grpc::Status ModuleCommand(::grpc::ClientContext* context, const ::bess::pb::CommandRequest& request, ::bess::pb::CommandResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>> AsyncModuleCommand(::grpc::ClientContext* context, const ::bess::pb::CommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>>(AsyncModuleCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>> PrepareAsyncModuleCommand(::grpc::ClientContext* context, const ::bess::pb::CommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>>(PrepareAsyncModuleCommandRaw(context, request, cq));
    }
    ::grpc::Status ListGateHookClass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListGateHookClassResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListGateHookClassResponse>> AsyncListGateHookClass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListGateHookClassResponse>>(AsyncListGateHookClassRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListGateHookClassResponse>> PrepareAsyncListGateHookClass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListGateHookClassResponse>>(PrepareAsyncListGateHookClassRaw(context, request, cq));
    }
    ::grpc::Status GetGateHookClassInfo(::grpc::ClientContext* context, const ::bess::pb::GetGateHookClassInfoRequest& request, ::bess::pb::GetGateHookClassInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetGateHookClassInfoResponse>> AsyncGetGateHookClassInfo(::grpc::ClientContext* context, const ::bess::pb::GetGateHookClassInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetGateHookClassInfoResponse>>(AsyncGetGateHookClassInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetGateHookClassInfoResponse>> PrepareAsyncGetGateHookClassInfo(::grpc::ClientContext* context, const ::bess::pb::GetGateHookClassInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::GetGateHookClassInfoResponse>>(PrepareAsyncGetGateHookClassInfoRaw(context, request, cq));
    }
    ::grpc::Status ConfigureGateHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureGateHookRequest& request, ::bess::pb::ConfigureGateHookResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ConfigureGateHookResponse>> AsyncConfigureGateHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureGateHookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ConfigureGateHookResponse>>(AsyncConfigureGateHookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ConfigureGateHookResponse>> PrepareAsyncConfigureGateHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureGateHookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ConfigureGateHookResponse>>(PrepareAsyncConfigureGateHookRaw(context, request, cq));
    }
    ::grpc::Status ListGateHooks(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::bess::pb::ListGateHooksResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListGateHooksResponse>> AsyncListGateHooks(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListGateHooksResponse>>(AsyncListGateHooksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListGateHooksResponse>> PrepareAsyncListGateHooks(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::ListGateHooksResponse>>(PrepareAsyncListGateHooksRaw(context, request, cq));
    }
    ::grpc::Status GateHookCommand(::grpc::ClientContext* context, const ::bess::pb::GateHookCommandRequest& request, ::bess::pb::CommandResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>> AsyncGateHookCommand(::grpc::ClientContext* context, const ::bess::pb::GateHookCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>>(AsyncGateHookCommandRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>> PrepareAsyncGateHookCommand(::grpc::ClientContext* context, const ::bess::pb::GateHookCommandRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>>(PrepareAsyncGateHookCommandRaw(context, request, cq));
    }
    ::grpc::Status ConfigureResumeHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureResumeHookRequest& request, ::bess::pb::CommandResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>> AsyncConfigureResumeHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureResumeHookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>>(AsyncConfigureResumeHookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>> PrepareAsyncConfigureResumeHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureResumeHookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>>(PrepareAsyncConfigureResumeHookRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetVersion(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::VersionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetVersion(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::VersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResetAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void ResetAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void KillBess(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void KillBess(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ImportPlugin(::grpc::ClientContext* context, const ::bess::pb::ImportPluginRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void ImportPlugin(::grpc::ClientContext* context, const ::bess::pb::ImportPluginRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UnloadPlugin(::grpc::ClientContext* context, const ::bess::pb::UnloadPluginRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void UnloadPlugin(::grpc::ClientContext* context, const ::bess::pb::UnloadPluginRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListPlugins(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListPluginsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListPlugins(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListPluginsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PauseAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void PauseAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PauseWorker(::grpc::ClientContext* context, const ::bess::pb::PauseWorkerRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void PauseWorker(::grpc::ClientContext* context, const ::bess::pb::PauseWorkerRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResumeWorker(::grpc::ClientContext* context, const ::bess::pb::ResumeWorkerRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void ResumeWorker(::grpc::ClientContext* context, const ::bess::pb::ResumeWorkerRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResumeAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void ResumeAll(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResetWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void ResetWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListWorkersResponse* response, std::function<void(::grpc::Status)>) override;
      void ListWorkers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListWorkersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AddWorker(::grpc::ClientContext* context, const ::bess::pb::AddWorkerRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void AddWorker(::grpc::ClientContext* context, const ::bess::pb::AddWorkerRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DestroyWorker(::grpc::ClientContext* context, const ::bess::pb::DestroyWorkerRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void DestroyWorker(::grpc::ClientContext* context, const ::bess::pb::DestroyWorkerRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResetTcs(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void ResetTcs(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListTcs(::grpc::ClientContext* context, const ::bess::pb::ListTcsRequest* request, ::bess::pb::ListTcsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListTcs(::grpc::ClientContext* context, const ::bess::pb::ListTcsRequest* request, ::bess::pb::ListTcsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CheckSchedulingConstraints(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::CheckSchedulingConstraintsResponse* response, std::function<void(::grpc::Status)>) override;
      void CheckSchedulingConstraints(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::CheckSchedulingConstraintsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AddTc(::grpc::ClientContext* context, const ::bess::pb::AddTcRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void AddTc(::grpc::ClientContext* context, const ::bess::pb::AddTcRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateTcParams(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParamsRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateTcParams(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParamsRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateTcParent(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParentRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateTcParent(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParentRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTcStats(::grpc::ClientContext* context, const ::bess::pb::GetTcStatsRequest* request, ::bess::pb::GetTcStatsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTcStats(::grpc::ClientContext* context, const ::bess::pb::GetTcStatsRequest* request, ::bess::pb::GetTcStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListDrivers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListDriversResponse* response, std::function<void(::grpc::Status)>) override;
      void ListDrivers(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListDriversResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetDriverInfo(::grpc::ClientContext* context, const ::bess::pb::GetDriverInfoRequest* request, ::bess::pb::GetDriverInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GetDriverInfo(::grpc::ClientContext* context, const ::bess::pb::GetDriverInfoRequest* request, ::bess::pb::GetDriverInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResetPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void ResetPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListPortsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListPorts(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListPortsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreatePort(::grpc::ClientContext* context, const ::bess::pb::CreatePortRequest* request, ::bess::pb::CreatePortResponse* response, std::function<void(::grpc::Status)>) override;
      void CreatePort(::grpc::ClientContext* context, const ::bess::pb::CreatePortRequest* request, ::bess::pb::CreatePortResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DestroyPort(::grpc::ClientContext* context, const ::bess::pb::DestroyPortRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void DestroyPort(::grpc::ClientContext* context, const ::bess::pb::DestroyPortRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetPortConf(::grpc::ClientContext* context, const ::bess::pb::SetPortConfRequest* request, ::bess::pb::CommandResponse* response, std::function<void(::grpc::Status)>) override;
      void SetPortConf(::grpc::ClientContext* context, const ::bess::pb::SetPortConfRequest* request, ::bess::pb::CommandResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPortConf(::grpc::ClientContext* context, const ::bess::pb::GetPortConfRequest* request, ::bess::pb::GetPortConfResponse* response, std::function<void(::grpc::Status)>) override;
      void GetPortConf(::grpc::ClientContext* context, const ::bess::pb::GetPortConfRequest* request, ::bess::pb::GetPortConfResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPortStats(::grpc::ClientContext* context, const ::bess::pb::GetPortStatsRequest* request, ::bess::pb::GetPortStatsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetPortStats(::grpc::ClientContext* context, const ::bess::pb::GetPortStatsRequest* request, ::bess::pb::GetPortStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLinkStatus(::grpc::ClientContext* context, const ::bess::pb::GetLinkStatusRequest* request, ::bess::pb::GetLinkStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void GetLinkStatus(::grpc::ClientContext* context, const ::bess::pb::GetLinkStatusRequest* request, ::bess::pb::GetLinkStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListMclass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListMclassResponse* response, std::function<void(::grpc::Status)>) override;
      void ListMclass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListMclassResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetMclassInfo(::grpc::ClientContext* context, const ::bess::pb::GetMclassInfoRequest* request, ::bess::pb::GetMclassInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GetMclassInfo(::grpc::ClientContext* context, const ::bess::pb::GetMclassInfoRequest* request, ::bess::pb::GetMclassInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResetModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void ResetModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListModulesResponse* response, std::function<void(::grpc::Status)>) override;
      void ListModules(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListModulesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateModule(::grpc::ClientContext* context, const ::bess::pb::CreateModuleRequest* request, ::bess::pb::CreateModuleResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateModule(::grpc::ClientContext* context, const ::bess::pb::CreateModuleRequest* request, ::bess::pb::CreateModuleResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DestroyModule(::grpc::ClientContext* context, const ::bess::pb::DestroyModuleRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void DestroyModule(::grpc::ClientContext* context, const ::bess::pb::DestroyModuleRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetModuleInfo(::grpc::ClientContext* context, const ::bess::pb::GetModuleInfoRequest* request, ::bess::pb::GetModuleInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GetModuleInfo(::grpc::ClientContext* context, const ::bess::pb::GetModuleInfoRequest* request, ::bess::pb::GetModuleInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ConnectModules(::grpc::ClientContext* context, const ::bess::pb::ConnectModulesRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void ConnectModules(::grpc::ClientContext* context, const ::bess::pb::ConnectModulesRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DisconnectModules(::grpc::ClientContext* context, const ::bess::pb::DisconnectModulesRequest* request, ::bess::pb::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void DisconnectModules(::grpc::ClientContext* context, const ::bess::pb::DisconnectModulesRequest* request, ::bess::pb::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DumpMempool(::grpc::ClientContext* context, const ::bess::pb::DumpMempoolRequest* request, ::bess::pb::DumpMempoolResponse* response, std::function<void(::grpc::Status)>) override;
      void DumpMempool(::grpc::ClientContext* context, const ::bess::pb::DumpMempoolRequest* request, ::bess::pb::DumpMempoolResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ModuleCommand(::grpc::ClientContext* context, const ::bess::pb::CommandRequest* request, ::bess::pb::CommandResponse* response, std::function<void(::grpc::Status)>) override;
      void ModuleCommand(::grpc::ClientContext* context, const ::bess::pb::CommandRequest* request, ::bess::pb::CommandResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListGateHookClass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListGateHookClassResponse* response, std::function<void(::grpc::Status)>) override;
      void ListGateHookClass(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListGateHookClassResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetGateHookClassInfo(::grpc::ClientContext* context, const ::bess::pb::GetGateHookClassInfoRequest* request, ::bess::pb::GetGateHookClassInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GetGateHookClassInfo(::grpc::ClientContext* context, const ::bess::pb::GetGateHookClassInfoRequest* request, ::bess::pb::GetGateHookClassInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ConfigureGateHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureGateHookRequest* request, ::bess::pb::ConfigureGateHookResponse* response, std::function<void(::grpc::Status)>) override;
      void ConfigureGateHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureGateHookRequest* request, ::bess::pb::ConfigureGateHookResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListGateHooks(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListGateHooksResponse* response, std::function<void(::grpc::Status)>) override;
      void ListGateHooks(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListGateHooksResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GateHookCommand(::grpc::ClientContext* context, const ::bess::pb::GateHookCommandRequest* request, ::bess::pb::CommandResponse* response, std::function<void(::grpc::Status)>) override;
      void GateHookCommand(::grpc::ClientContext* context, const ::bess::pb::GateHookCommandRequest* request, ::bess::pb::CommandResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ConfigureResumeHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureResumeHookRequest* request, ::bess::pb::CommandResponse* response, std::function<void(::grpc::Status)>) override;
      void ConfigureResumeHook(::grpc::ClientContext* context, const ::bess::pb::ConfigureResumeHookRequest* request, ::bess::pb::CommandResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bess::pb::VersionResponse>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::VersionResponse>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncResetAllRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncResetAllRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncKillBessRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncKillBessRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncImportPluginRaw(::grpc::ClientContext* context, const ::bess::pb::ImportPluginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncImportPluginRaw(::grpc::ClientContext* context, const ::bess::pb::ImportPluginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncUnloadPluginRaw(::grpc::ClientContext* context, const ::bess::pb::UnloadPluginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncUnloadPluginRaw(::grpc::ClientContext* context, const ::bess::pb::UnloadPluginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListPluginsResponse>* AsyncListPluginsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListPluginsResponse>* PrepareAsyncListPluginsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncPauseAllRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncPauseAllRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncPauseWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::PauseWorkerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncPauseWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::PauseWorkerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncResumeWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::ResumeWorkerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncResumeWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::ResumeWorkerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncResumeAllRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncResumeAllRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncResetWorkersRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncResetWorkersRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListWorkersResponse>* AsyncListWorkersRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListWorkersResponse>* PrepareAsyncListWorkersRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncAddWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::AddWorkerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncAddWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::AddWorkerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncDestroyWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::DestroyWorkerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncDestroyWorkerRaw(::grpc::ClientContext* context, const ::bess::pb::DestroyWorkerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncResetTcsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncResetTcsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListTcsResponse>* AsyncListTcsRaw(::grpc::ClientContext* context, const ::bess::pb::ListTcsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListTcsResponse>* PrepareAsyncListTcsRaw(::grpc::ClientContext* context, const ::bess::pb::ListTcsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::CheckSchedulingConstraintsResponse>* AsyncCheckSchedulingConstraintsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::CheckSchedulingConstraintsResponse>* PrepareAsyncCheckSchedulingConstraintsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncAddTcRaw(::grpc::ClientContext* context, const ::bess::pb::AddTcRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncAddTcRaw(::grpc::ClientContext* context, const ::bess::pb::AddTcRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncUpdateTcParamsRaw(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncUpdateTcParamsRaw(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncUpdateTcParentRaw(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncUpdateTcParentRaw(::grpc::ClientContext* context, const ::bess::pb::UpdateTcParentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetTcStatsResponse>* AsyncGetTcStatsRaw(::grpc::ClientContext* context, const ::bess::pb::GetTcStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetTcStatsResponse>* PrepareAsyncGetTcStatsRaw(::grpc::ClientContext* context, const ::bess::pb::GetTcStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListDriversResponse>* AsyncListDriversRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListDriversResponse>* PrepareAsyncListDriversRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetDriverInfoResponse>* AsyncGetDriverInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetDriverInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetDriverInfoResponse>* PrepareAsyncGetDriverInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetDriverInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncResetPortsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncResetPortsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListPortsResponse>* AsyncListPortsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListPortsResponse>* PrepareAsyncListPortsRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::CreatePortResponse>* AsyncCreatePortRaw(::grpc::ClientContext* context, const ::bess::pb::CreatePortRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::CreatePortResponse>* PrepareAsyncCreatePortRaw(::grpc::ClientContext* context, const ::bess::pb::CreatePortRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncDestroyPortRaw(::grpc::ClientContext* context, const ::bess::pb::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncDestroyPortRaw(::grpc::ClientContext* context, const ::bess::pb::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>* AsyncSetPortConfRaw(::grpc::ClientContext* context, const ::bess::pb::SetPortConfRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>* PrepareAsyncSetPortConfRaw(::grpc::ClientContext* context, const ::bess::pb::SetPortConfRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetPortConfResponse>* AsyncGetPortConfRaw(::grpc::ClientContext* context, const ::bess::pb::GetPortConfRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetPortConfResponse>* PrepareAsyncGetPortConfRaw(::grpc::ClientContext* context, const ::bess::pb::GetPortConfRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetPortStatsResponse>* AsyncGetPortStatsRaw(::grpc::ClientContext* context, const ::bess::pb::GetPortStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetPortStatsResponse>* PrepareAsyncGetPortStatsRaw(::grpc::ClientContext* context, const ::bess::pb::GetPortStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetLinkStatusResponse>* AsyncGetLinkStatusRaw(::grpc::ClientContext* context, const ::bess::pb::GetLinkStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetLinkStatusResponse>* PrepareAsyncGetLinkStatusRaw(::grpc::ClientContext* context, const ::bess::pb::GetLinkStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListMclassResponse>* AsyncListMclassRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListMclassResponse>* PrepareAsyncListMclassRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetMclassInfoResponse>* AsyncGetMclassInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetMclassInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetMclassInfoResponse>* PrepareAsyncGetMclassInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetMclassInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncResetModulesRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncResetModulesRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListModulesResponse>* AsyncListModulesRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListModulesResponse>* PrepareAsyncListModulesRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::CreateModuleResponse>* AsyncCreateModuleRaw(::grpc::ClientContext* context, const ::bess::pb::CreateModuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::CreateModuleResponse>* PrepareAsyncCreateModuleRaw(::grpc::ClientContext* context, const ::bess::pb::CreateModuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncDestroyModuleRaw(::grpc::ClientContext* context, const ::bess::pb::DestroyModuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncDestroyModuleRaw(::grpc::ClientContext* context, const ::bess::pb::DestroyModuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetModuleInfoResponse>* AsyncGetModuleInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetModuleInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetModuleInfoResponse>* PrepareAsyncGetModuleInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetModuleInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncConnectModulesRaw(::grpc::ClientContext* context, const ::bess::pb::ConnectModulesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncConnectModulesRaw(::grpc::ClientContext* context, const ::bess::pb::ConnectModulesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* AsyncDisconnectModulesRaw(::grpc::ClientContext* context, const ::bess::pb::DisconnectModulesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::EmptyResponse>* PrepareAsyncDisconnectModulesRaw(::grpc::ClientContext* context, const ::bess::pb::DisconnectModulesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::DumpMempoolResponse>* AsyncDumpMempoolRaw(::grpc::ClientContext* context, const ::bess::pb::DumpMempoolRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::DumpMempoolResponse>* PrepareAsyncDumpMempoolRaw(::grpc::ClientContext* context, const ::bess::pb::DumpMempoolRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>* AsyncModuleCommandRaw(::grpc::ClientContext* context, const ::bess::pb::CommandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>* PrepareAsyncModuleCommandRaw(::grpc::ClientContext* context, const ::bess::pb::CommandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListGateHookClassResponse>* AsyncListGateHookClassRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListGateHookClassResponse>* PrepareAsyncListGateHookClassRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetGateHookClassInfoResponse>* AsyncGetGateHookClassInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetGateHookClassInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::GetGateHookClassInfoResponse>* PrepareAsyncGetGateHookClassInfoRaw(::grpc::ClientContext* context, const ::bess::pb::GetGateHookClassInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ConfigureGateHookResponse>* AsyncConfigureGateHookRaw(::grpc::ClientContext* context, const ::bess::pb::ConfigureGateHookRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ConfigureGateHookResponse>* PrepareAsyncConfigureGateHookRaw(::grpc::ClientContext* context, const ::bess::pb::ConfigureGateHookRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListGateHooksResponse>* AsyncListGateHooksRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::ListGateHooksResponse>* PrepareAsyncListGateHooksRaw(::grpc::ClientContext* context, const ::bess::pb::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>* AsyncGateHookCommandRaw(::grpc::ClientContext* context, const ::bess::pb::GateHookCommandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>* PrepareAsyncGateHookCommandRaw(::grpc::ClientContext* context, const ::bess::pb::GateHookCommandRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>* AsyncConfigureResumeHookRaw(::grpc::ClientContext* context, const ::bess::pb::ConfigureResumeHookRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bess::pb::CommandResponse>* PrepareAsyncConfigureResumeHookRaw(::grpc::ClientContext* context, const ::bess::pb::ConfigureResumeHookRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetAll_;
    const ::grpc::internal::RpcMethod rpcmethod_KillBess_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportPlugin_;
    const ::grpc::internal::RpcMethod rpcmethod_UnloadPlugin_;
    const ::grpc::internal::RpcMethod rpcmethod_ListPlugins_;
    const ::grpc::internal::RpcMethod rpcmethod_PauseAll_;
    const ::grpc::internal::RpcMethod rpcmethod_PauseWorker_;
    const ::grpc::internal::RpcMethod rpcmethod_ResumeWorker_;
    const ::grpc::internal::RpcMethod rpcmethod_ResumeAll_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetWorkers_;
    const ::grpc::internal::RpcMethod rpcmethod_ListWorkers_;
    const ::grpc::internal::RpcMethod rpcmethod_AddWorker_;
    const ::grpc::internal::RpcMethod rpcmethod_DestroyWorker_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetTcs_;
    const ::grpc::internal::RpcMethod rpcmethod_ListTcs_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckSchedulingConstraints_;
    const ::grpc::internal::RpcMethod rpcmethod_AddTc_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateTcParams_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateTcParent_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTcStats_;
    const ::grpc::internal::RpcMethod rpcmethod_ListDrivers_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDriverInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetPorts_;
    const ::grpc::internal::RpcMethod rpcmethod_ListPorts_;
    const ::grpc::internal::RpcMethod rpcmethod_CreatePort_;
    const ::grpc::internal::RpcMethod rpcmethod_DestroyPort_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPortConf_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPortConf_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPortStats_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLinkStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_ListMclass_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMclassInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetModules_;
    const ::grpc::internal::RpcMethod rpcmethod_ListModules_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateModule_;
    const ::grpc::internal::RpcMethod rpcmethod_DestroyModule_;
    const ::grpc::internal::RpcMethod rpcmethod_GetModuleInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_ConnectModules_;
    const ::grpc::internal::RpcMethod rpcmethod_DisconnectModules_;
    const ::grpc::internal::RpcMethod rpcmethod_DumpMempool_;
    const ::grpc::internal::RpcMethod rpcmethod_ModuleCommand_;
    const ::grpc::internal::RpcMethod rpcmethod_ListGateHookClass_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGateHookClassInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_ConfigureGateHook_;
    const ::grpc::internal::RpcMethod rpcmethod_ListGateHooks_;
    const ::grpc::internal::RpcMethod rpcmethod_GateHookCommand_;
    const ::grpc::internal::RpcMethod rpcmethod_ConfigureResumeHook_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    //  -------------------------------------------------------------------------
    //  System
    //  -------------------------------------------------------------------------
    //
    // / Query version of bessd
    virtual ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::VersionResponse* response);
    // / Reset the current packet processing datapath to the initial state.
    // /
    // / This command is identical to the following sequence:
    // /   ResetModules()
    // /   ResetPorts()
    // /   ResetTcs()
    // /   ResetWorkers()
    // / As it clears everything, BESS should appear as if the daemon has freshly
    // / started (if not, it is a bug; please report).
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status ResetAll(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response);
    // / Terminate the BESS daemon.
    // /
    // / BESS daemon shuts off in a graceful manner. Note that this command is
    // / "asynchronous": this command doesn't block until the BESS daemon has
    // / shut off.
    // /
    // / NOTE: There should be no running worker to run this command.
    // / FIXME: rename (e.g., Terminate)
    virtual ::grpc::Status KillBess(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response);
    // / Import a plugin
    // /
    // / At the moment plugins can only contain module types,
    // / but might also support drivers/hooks/schedulers in the future.
    virtual ::grpc::Status ImportPlugin(::grpc::ServerContext* context, const ::bess::pb::ImportPluginRequest* request, ::bess::pb::EmptyResponse* response);
    // / Unload a plugin
    // /
    // / At the moment plugins can only contain module types,
    // / but might also support drivers/hooks/schedulers in the future.
    virtual ::grpc::Status UnloadPlugin(::grpc::ServerContext* context, const ::bess::pb::UnloadPluginRequest* request, ::bess::pb::EmptyResponse* response);
    // / List imported plugins
    // /
    // / At the moment plugins can only contain module types,
    // / but might also support drivers/hooks/schedulers in the future.
    virtual ::grpc::Status ListPlugins(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListPluginsResponse* response);
    //  -------------------------------------------------------------------------
    //  Worker
    //  -------------------------------------------------------------------------
    //
    // / Pause all running workers temporarily
    // /
    // / Some RPC commands to BESS or individual modules/ports require that
    // / threads must be inactive, to avoid race conditions.
    // / For such commands, use PauseALl at the beginning and ResumeAll at the end.
    // /  PauseAll()
    // /   SomeCommand1()
    // /   SomeCommand2()
    // /   ...
    // /  ResumeAll()
    // / Keep the duration as short as possible, to avoid packet drops.
    virtual ::grpc::Status PauseAll(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response);
    // / Pause the specified worker temporarily
    // /
    // / Some RPC commands to BESS or individual modules/ports require that
    // / threads must be inactive, to avoid race conditions.
    // / For such commands, use PauseWorker at the beginning and ResumeWorker at the end.
    // /  PauseWorker(0)
    // /   SomeCommand1()
    // /   SomeCommand2()
    // /   ...
    // /  ResumeWorker(0)
    // / Keep the duration as short as possible, to avoid packet drops.
    virtual ::grpc::Status PauseWorker(::grpc::ServerContext* context, const ::bess::pb::PauseWorkerRequest* request, ::bess::pb::EmptyResponse* response);
    // / Resume the specified worker
    virtual ::grpc::Status ResumeWorker(::grpc::ServerContext* context, const ::bess::pb::ResumeWorkerRequest* request, ::bess::pb::EmptyResponse* response);
    // / Resume all paused workers
    virtual ::grpc::Status ResumeAll(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response);
    // / Remove all existing workers
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status ResetWorkers(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response);
    // / Enumerate all existing workers
    virtual ::grpc::Status ListWorkers(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListWorkersResponse* response);
    // / Create a new worker
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status AddWorker(::grpc::ServerContext* context, const ::bess::pb::AddWorkerRequest* request, ::bess::pb::EmptyResponse* response);
    // / Remove a single worker
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status DestroyWorker(::grpc::ServerContext* context, const ::bess::pb::DestroyWorkerRequest* request, ::bess::pb::EmptyResponse* response);
    //  -------------------------------------------------------------------------
    //  Traffic classe & task
    //  -------------------------------------------------------------------------
    //
    // / Remove all existing traffic classes
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status ResetTcs(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response);
    // / Enumerate all existing workers
    virtual ::grpc::Status ListTcs(::grpc::ServerContext* context, const ::bess::pb::ListTcsRequest* request, ::bess::pb::ListTcsResponse* response);
    // / Check scheduling contraints
    virtual ::grpc::Status CheckSchedulingConstraints(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::CheckSchedulingConstraintsResponse* response);
    // / Create a new traffic class
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status AddTc(::grpc::ServerContext* context, const ::bess::pb::AddTcRequest* request, ::bess::pb::EmptyResponse* response);
    // / Update parameters of an existing traffic class
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status UpdateTcParams(::grpc::ServerContext* context, const ::bess::pb::UpdateTcParamsRequest* request, ::bess::pb::EmptyResponse* response);
    // / Change parent (and child arguments) of an existing traffic class
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status UpdateTcParent(::grpc::ServerContext* context, const ::bess::pb::UpdateTcParentRequest* request, ::bess::pb::EmptyResponse* response);
    // / Collect statistics of a traffic class
    virtual ::grpc::Status GetTcStats(::grpc::ServerContext* context, const ::bess::pb::GetTcStatsRequest* request, ::bess::pb::GetTcStatsResponse* response);
    //  -------------------------------------------------------------------------
    //  Port
    //  -------------------------------------------------------------------------
    //
    // / Enumerate all port drivers available
    virtual ::grpc::Status ListDrivers(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListDriversResponse* response);
    // / Query detailed information of a port driver
    virtual ::grpc::Status GetDriverInfo(::grpc::ServerContext* context, const ::bess::pb::GetDriverInfoRequest* request, ::bess::pb::GetDriverInfoResponse* response);
    // / Remove all initialized ports
    // /
    // / Will fail if there are modules that are still using ports.
    // / (e.g., PortInc, PortOut, QueueInc, QueueOut)
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status ResetPorts(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response);
    // / Enumerate all initialized ports
    virtual ::grpc::Status ListPorts(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListPortsResponse* response);
    // / Create a new port from the specified driver
    virtual ::grpc::Status CreatePort(::grpc::ServerContext* context, const ::bess::pb::CreatePortRequest* request, ::bess::pb::CreatePortResponse* response);
    // / Remove a port
    // /
    // / The port should not be being used by a port-related module.
    // / (e.g., PortInc, PortOut, QueueInc, QueueOut)
    virtual ::grpc::Status DestroyPort(::grpc::ServerContext* context, const ::bess::pb::DestroyPortRequest* request, ::bess::pb::EmptyResponse* response);
    // / Runtime-updatable configuration
    virtual ::grpc::Status SetPortConf(::grpc::ServerContext* context, const ::bess::pb::SetPortConfRequest* request, ::bess::pb::CommandResponse* response);
    virtual ::grpc::Status GetPortConf(::grpc::ServerContext* context, const ::bess::pb::GetPortConfRequest* request, ::bess::pb::GetPortConfResponse* response);
    // / Collect port statistics
    // /
    // / At the moment, per-queue stats are not supported.
    virtual ::grpc::Status GetPortStats(::grpc::ServerContext* context, const ::bess::pb::GetPortStatsRequest* request, ::bess::pb::GetPortStatsResponse* response);
    // / Query link status
    virtual ::grpc::Status GetLinkStatus(::grpc::ServerContext* context, const ::bess::pb::GetLinkStatusRequest* request, ::bess::pb::GetLinkStatusResponse* response);
    // TODO: Add PortCommand, like ModuleCommand, which performs driver-specific
    //       actions on a port.
    //
    //  -------------------------------------------------------------------------
    //  Module
    //  -------------------------------------------------------------------------
    //
    // / Enumerate all module types available
    virtual ::grpc::Status ListMclass(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListMclassResponse* response);
    // / Query detailed information of a module type
    virtual ::grpc::Status GetMclassInfo(::grpc::ServerContext* context, const ::bess::pb::GetMclassInfoRequest* request, ::bess::pb::GetMclassInfoResponse* response);
    // / Remove all modules.
    // /
    // / This RPC will always succeed (unless there is a running worker)
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status ResetModules(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response);
    // / Enumerate all initialized modules
    virtual ::grpc::Status ListModules(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListModulesResponse* response);
    // / Create a new module instance from the given module type
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status CreateModule(::grpc::ServerContext* context, const ::bess::pb::CreateModuleRequest* request, ::bess::pb::CreateModuleResponse* response);
    // / Destroy an exsting module
    // /
    // / If the module is connected to other modules' input/output gate, they are
    // / disconnected first. All tasks created by the module will also be destoyed.
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status DestroyModule(::grpc::ServerContext* context, const ::bess::pb::DestroyModuleRequest* request, ::bess::pb::EmptyResponse* response);
    // / Fetch detailed information of an module instance
    virtual ::grpc::Status GetModuleInfo(::grpc::ServerContext* context, const ::bess::pb::GetModuleInfoRequest* request, ::bess::pb::GetModuleInfoResponse* response);
    // / Connect two modules.
    // /
    // / Connect between m1's ogate and n2's igate (i.e., ackets sent to m1's ogate
    // / will be fed to m2's igate). The oate can be connected to only one igate,
    // / while the igate can be connected to multiple output gates.
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status ConnectModules(::grpc::ServerContext* context, const ::bess::pb::ConnectModulesRequest* request, ::bess::pb::EmptyResponse* response);
    // / Disconnect two modules.
    // /
    // / It removes a connection between two modules (you specify the previous one
    // / and its output gate). All packets coming out from the ogate will be
    // / dropped. Once disconnected, the ogate can be connected
    // / to any input gate.
    // /
    // / NOTE: There should be no running worker to run this command.
    virtual ::grpc::Status DisconnectModules(::grpc::ServerContext* context, const ::bess::pb::DisconnectModulesRequest* request, ::bess::pb::EmptyResponse* response);
    // / Dump various stats about BESS's packet pools
    virtual ::grpc::Status DumpMempool(::grpc::ServerContext* context, const ::bess::pb::DumpMempoolRequest* request, ::bess::pb::DumpMempoolResponse* response);
    // / Send a command to the specified module instance.
    // /
    // / Each module type defines a list of modyle-specific commands, which
    // / allow external programs to communicate with the module at runtime.
    // / See module_msg.proto for details.
    // /
    // / NOTE: Some commands cannot be used if there are running workers.
    // /       For those commands you must pause all workers first.
    virtual ::grpc::Status ModuleCommand(::grpc::ServerContext* context, const ::bess::pb::CommandRequest* request, ::bess::pb::CommandResponse* response);
    //  -------------------------------------------------------------------------
    //  Gate hooks
    //  -------------------------------------------------------------------------
    //
    // / Enumerate all gatehook types available
    virtual ::grpc::Status ListGateHookClass(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListGateHookClassResponse* response);
    // / Query detailed information of a gatehook type
    virtual ::grpc::Status GetGateHookClassInfo(::grpc::ServerContext* context, const ::bess::pb::GetGateHookClassInfoRequest* request, ::bess::pb::GetGateHookClassInfoResponse* response);
    // / Enable/Disable a gate hook.
    virtual ::grpc::Status ConfigureGateHook(::grpc::ServerContext* context, const ::bess::pb::ConfigureGateHookRequest* request, ::bess::pb::ConfigureGateHookResponse* response);
    // / Enumerate all gatehook installed
    virtual ::grpc::Status ListGateHooks(::grpc::ServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListGateHooksResponse* response);
    // / Send command to gate hook instance.
    virtual ::grpc::Status GateHookCommand(::grpc::ServerContext* context, const ::bess::pb::GateHookCommandRequest* request, ::bess::pb::CommandResponse* response);
    //  -------------------------------------------------------------------------
    //  Resume hooks
    //  -------------------------------------------------------------------------
    //
    // / Enable/Disable a resume hook.
    virtual ::grpc::Status ConfigureResumeHook(::grpc::ServerContext* context, const ::bess::pb::ConfigureResumeHookRequest* request, ::bess::pb::CommandResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVersion() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::VersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResetAll() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ResetAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetAll(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KillBess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KillBess() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_KillBess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KillBess(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKillBess(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportPlugin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportPlugin() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ImportPlugin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportPlugin(::grpc::ServerContext* /*context*/, const ::bess::pb::ImportPluginRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportPlugin(::grpc::ServerContext* context, ::bess::pb::ImportPluginRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnloadPlugin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnloadPlugin() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_UnloadPlugin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnloadPlugin(::grpc::ServerContext* /*context*/, const ::bess::pb::UnloadPluginRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnloadPlugin(::grpc::ServerContext* context, ::bess::pb::UnloadPluginRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListPlugins : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListPlugins() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ListPlugins() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPlugins(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListPluginsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPlugins(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::ListPluginsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PauseAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PauseAll() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_PauseAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseAll(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PauseWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PauseWorker() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_PauseWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::PauseWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseWorker(::grpc::ServerContext* context, ::bess::pb::PauseWorkerRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResumeWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResumeWorker() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_ResumeWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::ResumeWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResumeWorker(::grpc::ServerContext* context, ::bess::pb::ResumeWorkerRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResumeAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResumeAll() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_ResumeAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResumeAll(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResetWorkers() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ResetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetWorkers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetWorkers(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListWorkers() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_ListWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListWorkers(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::ListWorkersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddWorker() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_AddWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::AddWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddWorker(::grpc::ServerContext* context, ::bess::pb::AddWorkerRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DestroyWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DestroyWorker() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_DestroyWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyWorker(::grpc::ServerContext* context, ::bess::pb::DestroyWorkerRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetTcs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResetTcs() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_ResetTcs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetTcs(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetTcs(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListTcs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListTcs() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_ListTcs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTcs(::grpc::ServerContext* /*context*/, const ::bess::pb::ListTcsRequest* /*request*/, ::bess::pb::ListTcsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTcs(::grpc::ServerContext* context, ::bess::pb::ListTcsRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::ListTcsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckSchedulingConstraints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckSchedulingConstraints() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_CheckSchedulingConstraints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckSchedulingConstraints(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::CheckSchedulingConstraintsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckSchedulingConstraints(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::CheckSchedulingConstraintsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddTc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddTc() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_AddTc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddTc(::grpc::ServerContext* /*context*/, const ::bess::pb::AddTcRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddTc(::grpc::ServerContext* context, ::bess::pb::AddTcRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateTcParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateTcParams() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_UpdateTcParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTcParams(::grpc::ServerContext* /*context*/, const ::bess::pb::UpdateTcParamsRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateTcParams(::grpc::ServerContext* context, ::bess::pb::UpdateTcParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateTcParent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateTcParent() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_UpdateTcParent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTcParent(::grpc::ServerContext* /*context*/, const ::bess::pb::UpdateTcParentRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateTcParent(::grpc::ServerContext* context, ::bess::pb::UpdateTcParentRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTcStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTcStats() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_GetTcStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcStats(::grpc::ServerContext* /*context*/, const ::bess::pb::GetTcStatsRequest* /*request*/, ::bess::pb::GetTcStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTcStats(::grpc::ServerContext* context, ::bess::pb::GetTcStatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::GetTcStatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListDrivers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListDrivers() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_ListDrivers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrivers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListDriversResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDrivers(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::ListDriversResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDriverInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetDriverInfo() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_GetDriverInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDriverInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetDriverInfoRequest* /*request*/, ::bess::pb::GetDriverInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDriverInfo(::grpc::ServerContext* context, ::bess::pb::GetDriverInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::GetDriverInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetPorts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResetPorts() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_ResetPorts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetPorts(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetPorts(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListPorts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListPorts() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_ListPorts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPorts(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListPortsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPorts(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::ListPortsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreatePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreatePort() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_CreatePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePort(::grpc::ServerContext* /*context*/, const ::bess::pb::CreatePortRequest* /*request*/, ::bess::pb::CreatePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreatePort(::grpc::ServerContext* context, ::bess::pb::CreatePortRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::CreatePortResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DestroyPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DestroyPort() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_DestroyPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPort(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyPortRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyPort(::grpc::ServerContext* context, ::bess::pb::DestroyPortRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPortConf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetPortConf() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_SetPortConf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPortConf(::grpc::ServerContext* /*context*/, const ::bess::pb::SetPortConfRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPortConf(::grpc::ServerContext* context, ::bess::pb::SetPortConfRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::CommandResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPortConf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPortConf() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_GetPortConf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPortConf(::grpc::ServerContext* /*context*/, const ::bess::pb::GetPortConfRequest* /*request*/, ::bess::pb::GetPortConfResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPortConf(::grpc::ServerContext* context, ::bess::pb::GetPortConfRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::GetPortConfResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPortStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPortStats() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_GetPortStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPortStats(::grpc::ServerContext* /*context*/, const ::bess::pb::GetPortStatsRequest* /*request*/, ::bess::pb::GetPortStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPortStats(::grpc::ServerContext* context, ::bess::pb::GetPortStatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::GetPortStatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLinkStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLinkStatus() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_GetLinkStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLinkStatus(::grpc::ServerContext* /*context*/, const ::bess::pb::GetLinkStatusRequest* /*request*/, ::bess::pb::GetLinkStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLinkStatus(::grpc::ServerContext* context, ::bess::pb::GetLinkStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::GetLinkStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListMclass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListMclass() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_ListMclass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMclass(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListMclassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListMclass(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::ListMclassResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMclassInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMclassInfo() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_GetMclassInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMclassInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetMclassInfoRequest* /*request*/, ::bess::pb::GetMclassInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMclassInfo(::grpc::ServerContext* context, ::bess::pb::GetMclassInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::GetMclassInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResetModules() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_ResetModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetModules(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetModules(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListModules() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_ListModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModules(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListModules(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::ListModulesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateModule() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_CreateModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateModule(::grpc::ServerContext* /*context*/, const ::bess::pb::CreateModuleRequest* /*request*/, ::bess::pb::CreateModuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateModule(::grpc::ServerContext* context, ::bess::pb::CreateModuleRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::CreateModuleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DestroyModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DestroyModule() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_DestroyModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyModule(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyModuleRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyModule(::grpc::ServerContext* context, ::bess::pb::DestroyModuleRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetModuleInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetModuleInfo() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_GetModuleInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModuleInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetModuleInfoRequest* /*request*/, ::bess::pb::GetModuleInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModuleInfo(::grpc::ServerContext* context, ::bess::pb::GetModuleInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::GetModuleInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConnectModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ConnectModules() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_ConnectModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectModules(::grpc::ServerContext* /*context*/, const ::bess::pb::ConnectModulesRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectModules(::grpc::ServerContext* context, ::bess::pb::ConnectModulesRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DisconnectModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DisconnectModules() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_DisconnectModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisconnectModules(::grpc::ServerContext* /*context*/, const ::bess::pb::DisconnectModulesRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisconnectModules(::grpc::ServerContext* context, ::bess::pb::DisconnectModulesRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DumpMempool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DumpMempool() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_DumpMempool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DumpMempool(::grpc::ServerContext* /*context*/, const ::bess::pb::DumpMempoolRequest* /*request*/, ::bess::pb::DumpMempoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDumpMempool(::grpc::ServerContext* context, ::bess::pb::DumpMempoolRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::DumpMempoolResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ModuleCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ModuleCommand() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_ModuleCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModuleCommand(::grpc::ServerContext* /*context*/, const ::bess::pb::CommandRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestModuleCommand(::grpc::ServerContext* context, ::bess::pb::CommandRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::CommandResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListGateHookClass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListGateHookClass() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_ListGateHookClass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGateHookClass(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListGateHookClassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListGateHookClass(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::ListGateHookClassResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGateHookClassInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGateHookClassInfo() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_GetGateHookClassInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGateHookClassInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetGateHookClassInfoRequest* /*request*/, ::bess::pb::GetGateHookClassInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGateHookClassInfo(::grpc::ServerContext* context, ::bess::pb::GetGateHookClassInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::GetGateHookClassInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConfigureGateHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ConfigureGateHook() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_ConfigureGateHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureGateHook(::grpc::ServerContext* /*context*/, const ::bess::pb::ConfigureGateHookRequest* /*request*/, ::bess::pb::ConfigureGateHookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigureGateHook(::grpc::ServerContext* context, ::bess::pb::ConfigureGateHookRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::ConfigureGateHookResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListGateHooks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListGateHooks() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_ListGateHooks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGateHooks(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListGateHooksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListGateHooks(::grpc::ServerContext* context, ::bess::pb::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::ListGateHooksResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GateHookCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GateHookCommand() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_GateHookCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GateHookCommand(::grpc::ServerContext* /*context*/, const ::bess::pb::GateHookCommandRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGateHookCommand(::grpc::ServerContext* context, ::bess::pb::GateHookCommandRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::CommandResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConfigureResumeHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ConfigureResumeHook() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_ConfigureResumeHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureResumeHook(::grpc::ServerContext* /*context*/, const ::bess::pb::ConfigureResumeHookRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigureResumeHook(::grpc::ServerContext* context, ::bess::pb::ConfigureResumeHookRequest* request, ::grpc::ServerAsyncResponseWriter< ::bess::pb::CommandResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetVersion<WithAsyncMethod_ResetAll<WithAsyncMethod_KillBess<WithAsyncMethod_ImportPlugin<WithAsyncMethod_UnloadPlugin<WithAsyncMethod_ListPlugins<WithAsyncMethod_PauseAll<WithAsyncMethod_PauseWorker<WithAsyncMethod_ResumeWorker<WithAsyncMethod_ResumeAll<WithAsyncMethod_ResetWorkers<WithAsyncMethod_ListWorkers<WithAsyncMethod_AddWorker<WithAsyncMethod_DestroyWorker<WithAsyncMethod_ResetTcs<WithAsyncMethod_ListTcs<WithAsyncMethod_CheckSchedulingConstraints<WithAsyncMethod_AddTc<WithAsyncMethod_UpdateTcParams<WithAsyncMethod_UpdateTcParent<WithAsyncMethod_GetTcStats<WithAsyncMethod_ListDrivers<WithAsyncMethod_GetDriverInfo<WithAsyncMethod_ResetPorts<WithAsyncMethod_ListPorts<WithAsyncMethod_CreatePort<WithAsyncMethod_DestroyPort<WithAsyncMethod_SetPortConf<WithAsyncMethod_GetPortConf<WithAsyncMethod_GetPortStats<WithAsyncMethod_GetLinkStatus<WithAsyncMethod_ListMclass<WithAsyncMethod_GetMclassInfo<WithAsyncMethod_ResetModules<WithAsyncMethod_ListModules<WithAsyncMethod_CreateModule<WithAsyncMethod_DestroyModule<WithAsyncMethod_GetModuleInfo<WithAsyncMethod_ConnectModules<WithAsyncMethod_DisconnectModules<WithAsyncMethod_DumpMempool<WithAsyncMethod_ModuleCommand<WithAsyncMethod_ListGateHookClass<WithAsyncMethod_GetGateHookClassInfo<WithAsyncMethod_ConfigureGateHook<WithAsyncMethod_ListGateHooks<WithAsyncMethod_GateHookCommand<WithAsyncMethod_ConfigureResumeHook<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetVersion() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::VersionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::VersionResponse* response) { return this->GetVersion(context, request, response); }));}
    void SetMessageAllocatorFor_GetVersion(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::VersionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::VersionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::VersionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResetAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResetAll() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response) { return this->ResetAll(context, request, response); }));}
    void SetMessageAllocatorFor_ResetAll(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResetAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetAll(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_KillBess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_KillBess() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response) { return this->KillBess(context, request, response); }));}
    void SetMessageAllocatorFor_KillBess(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_KillBess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KillBess(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* KillBess(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ImportPlugin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ImportPlugin() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::ImportPluginRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::ImportPluginRequest* request, ::bess::pb::EmptyResponse* response) { return this->ImportPlugin(context, request, response); }));}
    void SetMessageAllocatorFor_ImportPlugin(
        ::grpc::MessageAllocator< ::bess::pb::ImportPluginRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::ImportPluginRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ImportPlugin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportPlugin(::grpc::ServerContext* /*context*/, const ::bess::pb::ImportPluginRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ImportPlugin(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::ImportPluginRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UnloadPlugin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UnloadPlugin() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::UnloadPluginRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::UnloadPluginRequest* request, ::bess::pb::EmptyResponse* response) { return this->UnloadPlugin(context, request, response); }));}
    void SetMessageAllocatorFor_UnloadPlugin(
        ::grpc::MessageAllocator< ::bess::pb::UnloadPluginRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::UnloadPluginRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UnloadPlugin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnloadPlugin(::grpc::ServerContext* /*context*/, const ::bess::pb::UnloadPluginRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UnloadPlugin(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::UnloadPluginRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListPlugins : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListPlugins() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListPluginsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListPluginsResponse* response) { return this->ListPlugins(context, request, response); }));}
    void SetMessageAllocatorFor_ListPlugins(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::ListPluginsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListPluginsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListPlugins() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPlugins(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListPluginsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListPlugins(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListPluginsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PauseAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PauseAll() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response) { return this->PauseAll(context, request, response); }));}
    void SetMessageAllocatorFor_PauseAll(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PauseAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseAll(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PauseWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PauseWorker() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::PauseWorkerRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::PauseWorkerRequest* request, ::bess::pb::EmptyResponse* response) { return this->PauseWorker(context, request, response); }));}
    void SetMessageAllocatorFor_PauseWorker(
        ::grpc::MessageAllocator< ::bess::pb::PauseWorkerRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::PauseWorkerRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PauseWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::PauseWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseWorker(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::PauseWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResumeWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResumeWorker() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::ResumeWorkerRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::ResumeWorkerRequest* request, ::bess::pb::EmptyResponse* response) { return this->ResumeWorker(context, request, response); }));}
    void SetMessageAllocatorFor_ResumeWorker(
        ::grpc::MessageAllocator< ::bess::pb::ResumeWorkerRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::ResumeWorkerRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResumeWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::ResumeWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResumeWorker(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::ResumeWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResumeAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResumeAll() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response) { return this->ResumeAll(context, request, response); }));}
    void SetMessageAllocatorFor_ResumeAll(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResumeAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResumeAll(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResetWorkers() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response) { return this->ResetWorkers(context, request, response); }));}
    void SetMessageAllocatorFor_ResetWorkers(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetWorkers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetWorkers(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListWorkers() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListWorkersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListWorkersResponse* response) { return this->ListWorkers(context, request, response); }));}
    void SetMessageAllocatorFor_ListWorkers(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::ListWorkersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListWorkersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListWorkers(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListWorkersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AddWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AddWorker() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::AddWorkerRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::AddWorkerRequest* request, ::bess::pb::EmptyResponse* response) { return this->AddWorker(context, request, response); }));}
    void SetMessageAllocatorFor_AddWorker(
        ::grpc::MessageAllocator< ::bess::pb::AddWorkerRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::AddWorkerRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AddWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::AddWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddWorker(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::AddWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DestroyWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DestroyWorker() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::DestroyWorkerRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::DestroyWorkerRequest* request, ::bess::pb::EmptyResponse* response) { return this->DestroyWorker(context, request, response); }));}
    void SetMessageAllocatorFor_DestroyWorker(
        ::grpc::MessageAllocator< ::bess::pb::DestroyWorkerRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::DestroyWorkerRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DestroyWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DestroyWorker(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::DestroyWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResetTcs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResetTcs() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response) { return this->ResetTcs(context, request, response); }));}
    void SetMessageAllocatorFor_ResetTcs(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResetTcs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetTcs(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetTcs(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListTcs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListTcs() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::ListTcsRequest, ::bess::pb::ListTcsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::ListTcsRequest* request, ::bess::pb::ListTcsResponse* response) { return this->ListTcs(context, request, response); }));}
    void SetMessageAllocatorFor_ListTcs(
        ::grpc::MessageAllocator< ::bess::pb::ListTcsRequest, ::bess::pb::ListTcsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::ListTcsRequest, ::bess::pb::ListTcsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListTcs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTcs(::grpc::ServerContext* /*context*/, const ::bess::pb::ListTcsRequest* /*request*/, ::bess::pb::ListTcsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListTcs(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::ListTcsRequest* /*request*/, ::bess::pb::ListTcsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckSchedulingConstraints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckSchedulingConstraints() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::CheckSchedulingConstraintsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::CheckSchedulingConstraintsResponse* response) { return this->CheckSchedulingConstraints(context, request, response); }));}
    void SetMessageAllocatorFor_CheckSchedulingConstraints(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::CheckSchedulingConstraintsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::CheckSchedulingConstraintsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckSchedulingConstraints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckSchedulingConstraints(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::CheckSchedulingConstraintsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckSchedulingConstraints(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::CheckSchedulingConstraintsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AddTc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AddTc() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::AddTcRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::AddTcRequest* request, ::bess::pb::EmptyResponse* response) { return this->AddTc(context, request, response); }));}
    void SetMessageAllocatorFor_AddTc(
        ::grpc::MessageAllocator< ::bess::pb::AddTcRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::AddTcRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AddTc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddTc(::grpc::ServerContext* /*context*/, const ::bess::pb::AddTcRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddTc(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::AddTcRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateTcParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateTcParams() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::UpdateTcParamsRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::UpdateTcParamsRequest* request, ::bess::pb::EmptyResponse* response) { return this->UpdateTcParams(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateTcParams(
        ::grpc::MessageAllocator< ::bess::pb::UpdateTcParamsRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::UpdateTcParamsRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateTcParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTcParams(::grpc::ServerContext* /*context*/, const ::bess::pb::UpdateTcParamsRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateTcParams(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::UpdateTcParamsRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateTcParent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateTcParent() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::UpdateTcParentRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::UpdateTcParentRequest* request, ::bess::pb::EmptyResponse* response) { return this->UpdateTcParent(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateTcParent(
        ::grpc::MessageAllocator< ::bess::pb::UpdateTcParentRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::UpdateTcParentRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateTcParent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTcParent(::grpc::ServerContext* /*context*/, const ::bess::pb::UpdateTcParentRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateTcParent(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::UpdateTcParentRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTcStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTcStats() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetTcStatsRequest, ::bess::pb::GetTcStatsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::GetTcStatsRequest* request, ::bess::pb::GetTcStatsResponse* response) { return this->GetTcStats(context, request, response); }));}
    void SetMessageAllocatorFor_GetTcStats(
        ::grpc::MessageAllocator< ::bess::pb::GetTcStatsRequest, ::bess::pb::GetTcStatsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetTcStatsRequest, ::bess::pb::GetTcStatsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTcStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcStats(::grpc::ServerContext* /*context*/, const ::bess::pb::GetTcStatsRequest* /*request*/, ::bess::pb::GetTcStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTcStats(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::GetTcStatsRequest* /*request*/, ::bess::pb::GetTcStatsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListDrivers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListDrivers() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListDriversResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListDriversResponse* response) { return this->ListDrivers(context, request, response); }));}
    void SetMessageAllocatorFor_ListDrivers(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::ListDriversResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListDriversResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListDrivers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrivers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListDriversResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListDrivers(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListDriversResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetDriverInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetDriverInfo() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetDriverInfoRequest, ::bess::pb::GetDriverInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::GetDriverInfoRequest* request, ::bess::pb::GetDriverInfoResponse* response) { return this->GetDriverInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetDriverInfo(
        ::grpc::MessageAllocator< ::bess::pb::GetDriverInfoRequest, ::bess::pb::GetDriverInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetDriverInfoRequest, ::bess::pb::GetDriverInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetDriverInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDriverInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetDriverInfoRequest* /*request*/, ::bess::pb::GetDriverInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDriverInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::GetDriverInfoRequest* /*request*/, ::bess::pb::GetDriverInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResetPorts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResetPorts() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response) { return this->ResetPorts(context, request, response); }));}
    void SetMessageAllocatorFor_ResetPorts(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResetPorts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetPorts(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetPorts(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListPorts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListPorts() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListPortsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListPortsResponse* response) { return this->ListPorts(context, request, response); }));}
    void SetMessageAllocatorFor_ListPorts(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::ListPortsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListPortsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListPorts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPorts(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListPortsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListPorts(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListPortsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreatePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreatePort() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::CreatePortRequest, ::bess::pb::CreatePortResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::CreatePortRequest* request, ::bess::pb::CreatePortResponse* response) { return this->CreatePort(context, request, response); }));}
    void SetMessageAllocatorFor_CreatePort(
        ::grpc::MessageAllocator< ::bess::pb::CreatePortRequest, ::bess::pb::CreatePortResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::CreatePortRequest, ::bess::pb::CreatePortResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreatePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePort(::grpc::ServerContext* /*context*/, const ::bess::pb::CreatePortRequest* /*request*/, ::bess::pb::CreatePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreatePort(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::CreatePortRequest* /*request*/, ::bess::pb::CreatePortResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DestroyPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DestroyPort() {
      ::grpc::Service::MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::DestroyPortRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::DestroyPortRequest* request, ::bess::pb::EmptyResponse* response) { return this->DestroyPort(context, request, response); }));}
    void SetMessageAllocatorFor_DestroyPort(
        ::grpc::MessageAllocator< ::bess::pb::DestroyPortRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::DestroyPortRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DestroyPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPort(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyPortRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DestroyPort(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::DestroyPortRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetPortConf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetPortConf() {
      ::grpc::Service::MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::SetPortConfRequest, ::bess::pb::CommandResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::SetPortConfRequest* request, ::bess::pb::CommandResponse* response) { return this->SetPortConf(context, request, response); }));}
    void SetMessageAllocatorFor_SetPortConf(
        ::grpc::MessageAllocator< ::bess::pb::SetPortConfRequest, ::bess::pb::CommandResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::SetPortConfRequest, ::bess::pb::CommandResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetPortConf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPortConf(::grpc::ServerContext* /*context*/, const ::bess::pb::SetPortConfRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPortConf(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::SetPortConfRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPortConf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPortConf() {
      ::grpc::Service::MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetPortConfRequest, ::bess::pb::GetPortConfResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::GetPortConfRequest* request, ::bess::pb::GetPortConfResponse* response) { return this->GetPortConf(context, request, response); }));}
    void SetMessageAllocatorFor_GetPortConf(
        ::grpc::MessageAllocator< ::bess::pb::GetPortConfRequest, ::bess::pb::GetPortConfResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetPortConfRequest, ::bess::pb::GetPortConfResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPortConf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPortConf(::grpc::ServerContext* /*context*/, const ::bess::pb::GetPortConfRequest* /*request*/, ::bess::pb::GetPortConfResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPortConf(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::GetPortConfRequest* /*request*/, ::bess::pb::GetPortConfResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPortStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPortStats() {
      ::grpc::Service::MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetPortStatsRequest, ::bess::pb::GetPortStatsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::GetPortStatsRequest* request, ::bess::pb::GetPortStatsResponse* response) { return this->GetPortStats(context, request, response); }));}
    void SetMessageAllocatorFor_GetPortStats(
        ::grpc::MessageAllocator< ::bess::pb::GetPortStatsRequest, ::bess::pb::GetPortStatsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetPortStatsRequest, ::bess::pb::GetPortStatsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPortStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPortStats(::grpc::ServerContext* /*context*/, const ::bess::pb::GetPortStatsRequest* /*request*/, ::bess::pb::GetPortStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPortStats(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::GetPortStatsRequest* /*request*/, ::bess::pb::GetPortStatsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLinkStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLinkStatus() {
      ::grpc::Service::MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetLinkStatusRequest, ::bess::pb::GetLinkStatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::GetLinkStatusRequest* request, ::bess::pb::GetLinkStatusResponse* response) { return this->GetLinkStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetLinkStatus(
        ::grpc::MessageAllocator< ::bess::pb::GetLinkStatusRequest, ::bess::pb::GetLinkStatusResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetLinkStatusRequest, ::bess::pb::GetLinkStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLinkStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLinkStatus(::grpc::ServerContext* /*context*/, const ::bess::pb::GetLinkStatusRequest* /*request*/, ::bess::pb::GetLinkStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLinkStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::GetLinkStatusRequest* /*request*/, ::bess::pb::GetLinkStatusResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListMclass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListMclass() {
      ::grpc::Service::MarkMethodCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListMclassResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListMclassResponse* response) { return this->ListMclass(context, request, response); }));}
    void SetMessageAllocatorFor_ListMclass(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::ListMclassResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListMclassResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListMclass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMclass(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListMclassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListMclass(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListMclassResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetMclassInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetMclassInfo() {
      ::grpc::Service::MarkMethodCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetMclassInfoRequest, ::bess::pb::GetMclassInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::GetMclassInfoRequest* request, ::bess::pb::GetMclassInfoResponse* response) { return this->GetMclassInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetMclassInfo(
        ::grpc::MessageAllocator< ::bess::pb::GetMclassInfoRequest, ::bess::pb::GetMclassInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetMclassInfoRequest, ::bess::pb::GetMclassInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetMclassInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMclassInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetMclassInfoRequest* /*request*/, ::bess::pb::GetMclassInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMclassInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::GetMclassInfoRequest* /*request*/, ::bess::pb::GetMclassInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResetModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResetModules() {
      ::grpc::Service::MarkMethodCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::EmptyResponse* response) { return this->ResetModules(context, request, response); }));}
    void SetMessageAllocatorFor_ResetModules(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResetModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetModules(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetModules(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListModules() {
      ::grpc::Service::MarkMethodCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListModulesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListModulesResponse* response) { return this->ListModules(context, request, response); }));}
    void SetMessageAllocatorFor_ListModules(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::ListModulesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(34);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListModulesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModules(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListModules(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListModulesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateModule() {
      ::grpc::Service::MarkMethodCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::CreateModuleRequest, ::bess::pb::CreateModuleResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::CreateModuleRequest* request, ::bess::pb::CreateModuleResponse* response) { return this->CreateModule(context, request, response); }));}
    void SetMessageAllocatorFor_CreateModule(
        ::grpc::MessageAllocator< ::bess::pb::CreateModuleRequest, ::bess::pb::CreateModuleResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(35);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::CreateModuleRequest, ::bess::pb::CreateModuleResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateModule(::grpc::ServerContext* /*context*/, const ::bess::pb::CreateModuleRequest* /*request*/, ::bess::pb::CreateModuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateModule(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::CreateModuleRequest* /*request*/, ::bess::pb::CreateModuleResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DestroyModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DestroyModule() {
      ::grpc::Service::MarkMethodCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::DestroyModuleRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::DestroyModuleRequest* request, ::bess::pb::EmptyResponse* response) { return this->DestroyModule(context, request, response); }));}
    void SetMessageAllocatorFor_DestroyModule(
        ::grpc::MessageAllocator< ::bess::pb::DestroyModuleRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(36);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::DestroyModuleRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DestroyModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyModule(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyModuleRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DestroyModule(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::DestroyModuleRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetModuleInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetModuleInfo() {
      ::grpc::Service::MarkMethodCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetModuleInfoRequest, ::bess::pb::GetModuleInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::GetModuleInfoRequest* request, ::bess::pb::GetModuleInfoResponse* response) { return this->GetModuleInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetModuleInfo(
        ::grpc::MessageAllocator< ::bess::pb::GetModuleInfoRequest, ::bess::pb::GetModuleInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(37);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetModuleInfoRequest, ::bess::pb::GetModuleInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetModuleInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModuleInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetModuleInfoRequest* /*request*/, ::bess::pb::GetModuleInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetModuleInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::GetModuleInfoRequest* /*request*/, ::bess::pb::GetModuleInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ConnectModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ConnectModules() {
      ::grpc::Service::MarkMethodCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::ConnectModulesRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::ConnectModulesRequest* request, ::bess::pb::EmptyResponse* response) { return this->ConnectModules(context, request, response); }));}
    void SetMessageAllocatorFor_ConnectModules(
        ::grpc::MessageAllocator< ::bess::pb::ConnectModulesRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(38);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::ConnectModulesRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ConnectModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectModules(::grpc::ServerContext* /*context*/, const ::bess::pb::ConnectModulesRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConnectModules(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::ConnectModulesRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DisconnectModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DisconnectModules() {
      ::grpc::Service::MarkMethodCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::DisconnectModulesRequest, ::bess::pb::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::DisconnectModulesRequest* request, ::bess::pb::EmptyResponse* response) { return this->DisconnectModules(context, request, response); }));}
    void SetMessageAllocatorFor_DisconnectModules(
        ::grpc::MessageAllocator< ::bess::pb::DisconnectModulesRequest, ::bess::pb::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(39);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::DisconnectModulesRequest, ::bess::pb::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DisconnectModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisconnectModules(::grpc::ServerContext* /*context*/, const ::bess::pb::DisconnectModulesRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisconnectModules(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::DisconnectModulesRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DumpMempool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DumpMempool() {
      ::grpc::Service::MarkMethodCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::DumpMempoolRequest, ::bess::pb::DumpMempoolResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::DumpMempoolRequest* request, ::bess::pb::DumpMempoolResponse* response) { return this->DumpMempool(context, request, response); }));}
    void SetMessageAllocatorFor_DumpMempool(
        ::grpc::MessageAllocator< ::bess::pb::DumpMempoolRequest, ::bess::pb::DumpMempoolResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(40);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::DumpMempoolRequest, ::bess::pb::DumpMempoolResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DumpMempool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DumpMempool(::grpc::ServerContext* /*context*/, const ::bess::pb::DumpMempoolRequest* /*request*/, ::bess::pb::DumpMempoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DumpMempool(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::DumpMempoolRequest* /*request*/, ::bess::pb::DumpMempoolResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ModuleCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ModuleCommand() {
      ::grpc::Service::MarkMethodCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::CommandRequest, ::bess::pb::CommandResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::CommandRequest* request, ::bess::pb::CommandResponse* response) { return this->ModuleCommand(context, request, response); }));}
    void SetMessageAllocatorFor_ModuleCommand(
        ::grpc::MessageAllocator< ::bess::pb::CommandRequest, ::bess::pb::CommandResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(41);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::CommandRequest, ::bess::pb::CommandResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ModuleCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModuleCommand(::grpc::ServerContext* /*context*/, const ::bess::pb::CommandRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ModuleCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::CommandRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListGateHookClass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListGateHookClass() {
      ::grpc::Service::MarkMethodCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListGateHookClassResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListGateHookClassResponse* response) { return this->ListGateHookClass(context, request, response); }));}
    void SetMessageAllocatorFor_ListGateHookClass(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::ListGateHookClassResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(42);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListGateHookClassResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListGateHookClass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGateHookClass(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListGateHookClassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListGateHookClass(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListGateHookClassResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetGateHookClassInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetGateHookClassInfo() {
      ::grpc::Service::MarkMethodCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetGateHookClassInfoRequest, ::bess::pb::GetGateHookClassInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::GetGateHookClassInfoRequest* request, ::bess::pb::GetGateHookClassInfoResponse* response) { return this->GetGateHookClassInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetGateHookClassInfo(
        ::grpc::MessageAllocator< ::bess::pb::GetGateHookClassInfoRequest, ::bess::pb::GetGateHookClassInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(43);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::GetGateHookClassInfoRequest, ::bess::pb::GetGateHookClassInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetGateHookClassInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGateHookClassInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetGateHookClassInfoRequest* /*request*/, ::bess::pb::GetGateHookClassInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGateHookClassInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::GetGateHookClassInfoRequest* /*request*/, ::bess::pb::GetGateHookClassInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ConfigureGateHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ConfigureGateHook() {
      ::grpc::Service::MarkMethodCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::ConfigureGateHookRequest, ::bess::pb::ConfigureGateHookResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::ConfigureGateHookRequest* request, ::bess::pb::ConfigureGateHookResponse* response) { return this->ConfigureGateHook(context, request, response); }));}
    void SetMessageAllocatorFor_ConfigureGateHook(
        ::grpc::MessageAllocator< ::bess::pb::ConfigureGateHookRequest, ::bess::pb::ConfigureGateHookResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(44);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::ConfigureGateHookRequest, ::bess::pb::ConfigureGateHookResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ConfigureGateHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureGateHook(::grpc::ServerContext* /*context*/, const ::bess::pb::ConfigureGateHookRequest* /*request*/, ::bess::pb::ConfigureGateHookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConfigureGateHook(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::ConfigureGateHookRequest* /*request*/, ::bess::pb::ConfigureGateHookResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListGateHooks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListGateHooks() {
      ::grpc::Service::MarkMethodCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListGateHooksResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::EmptyRequest* request, ::bess::pb::ListGateHooksResponse* response) { return this->ListGateHooks(context, request, response); }));}
    void SetMessageAllocatorFor_ListGateHooks(
        ::grpc::MessageAllocator< ::bess::pb::EmptyRequest, ::bess::pb::ListGateHooksResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(45);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::EmptyRequest, ::bess::pb::ListGateHooksResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListGateHooks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGateHooks(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListGateHooksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListGateHooks(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListGateHooksResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GateHookCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GateHookCommand() {
      ::grpc::Service::MarkMethodCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::GateHookCommandRequest, ::bess::pb::CommandResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::GateHookCommandRequest* request, ::bess::pb::CommandResponse* response) { return this->GateHookCommand(context, request, response); }));}
    void SetMessageAllocatorFor_GateHookCommand(
        ::grpc::MessageAllocator< ::bess::pb::GateHookCommandRequest, ::bess::pb::CommandResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(46);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::GateHookCommandRequest, ::bess::pb::CommandResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GateHookCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GateHookCommand(::grpc::ServerContext* /*context*/, const ::bess::pb::GateHookCommandRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GateHookCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::GateHookCommandRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ConfigureResumeHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ConfigureResumeHook() {
      ::grpc::Service::MarkMethodCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::bess::pb::ConfigureResumeHookRequest, ::bess::pb::CommandResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bess::pb::ConfigureResumeHookRequest* request, ::bess::pb::CommandResponse* response) { return this->ConfigureResumeHook(context, request, response); }));}
    void SetMessageAllocatorFor_ConfigureResumeHook(
        ::grpc::MessageAllocator< ::bess::pb::ConfigureResumeHookRequest, ::bess::pb::CommandResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(47);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bess::pb::ConfigureResumeHookRequest, ::bess::pb::CommandResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ConfigureResumeHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureResumeHook(::grpc::ServerContext* /*context*/, const ::bess::pb::ConfigureResumeHookRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConfigureResumeHook(
      ::grpc::CallbackServerContext* /*context*/, const ::bess::pb::ConfigureResumeHookRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetVersion<WithCallbackMethod_ResetAll<WithCallbackMethod_KillBess<WithCallbackMethod_ImportPlugin<WithCallbackMethod_UnloadPlugin<WithCallbackMethod_ListPlugins<WithCallbackMethod_PauseAll<WithCallbackMethod_PauseWorker<WithCallbackMethod_ResumeWorker<WithCallbackMethod_ResumeAll<WithCallbackMethod_ResetWorkers<WithCallbackMethod_ListWorkers<WithCallbackMethod_AddWorker<WithCallbackMethod_DestroyWorker<WithCallbackMethod_ResetTcs<WithCallbackMethod_ListTcs<WithCallbackMethod_CheckSchedulingConstraints<WithCallbackMethod_AddTc<WithCallbackMethod_UpdateTcParams<WithCallbackMethod_UpdateTcParent<WithCallbackMethod_GetTcStats<WithCallbackMethod_ListDrivers<WithCallbackMethod_GetDriverInfo<WithCallbackMethod_ResetPorts<WithCallbackMethod_ListPorts<WithCallbackMethod_CreatePort<WithCallbackMethod_DestroyPort<WithCallbackMethod_SetPortConf<WithCallbackMethod_GetPortConf<WithCallbackMethod_GetPortStats<WithCallbackMethod_GetLinkStatus<WithCallbackMethod_ListMclass<WithCallbackMethod_GetMclassInfo<WithCallbackMethod_ResetModules<WithCallbackMethod_ListModules<WithCallbackMethod_CreateModule<WithCallbackMethod_DestroyModule<WithCallbackMethod_GetModuleInfo<WithCallbackMethod_ConnectModules<WithCallbackMethod_DisconnectModules<WithCallbackMethod_DumpMempool<WithCallbackMethod_ModuleCommand<WithCallbackMethod_ListGateHookClass<WithCallbackMethod_GetGateHookClassInfo<WithCallbackMethod_ConfigureGateHook<WithCallbackMethod_ListGateHooks<WithCallbackMethod_GateHookCommand<WithCallbackMethod_ConfigureResumeHook<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVersion() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResetAll() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ResetAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KillBess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KillBess() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_KillBess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KillBess(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportPlugin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportPlugin() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ImportPlugin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportPlugin(::grpc::ServerContext* /*context*/, const ::bess::pb::ImportPluginRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnloadPlugin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnloadPlugin() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_UnloadPlugin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnloadPlugin(::grpc::ServerContext* /*context*/, const ::bess::pb::UnloadPluginRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListPlugins : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListPlugins() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ListPlugins() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPlugins(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListPluginsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PauseAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PauseAll() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_PauseAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PauseWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PauseWorker() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_PauseWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::PauseWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResumeWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResumeWorker() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_ResumeWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::ResumeWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResumeAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResumeAll() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_ResumeAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResetWorkers() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ResetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetWorkers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListWorkers() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_ListWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddWorker() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_AddWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::AddWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DestroyWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DestroyWorker() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_DestroyWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetTcs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResetTcs() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_ResetTcs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetTcs(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListTcs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListTcs() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_ListTcs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTcs(::grpc::ServerContext* /*context*/, const ::bess::pb::ListTcsRequest* /*request*/, ::bess::pb::ListTcsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckSchedulingConstraints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckSchedulingConstraints() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_CheckSchedulingConstraints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckSchedulingConstraints(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::CheckSchedulingConstraintsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddTc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddTc() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_AddTc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddTc(::grpc::ServerContext* /*context*/, const ::bess::pb::AddTcRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateTcParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateTcParams() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_UpdateTcParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTcParams(::grpc::ServerContext* /*context*/, const ::bess::pb::UpdateTcParamsRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateTcParent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateTcParent() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_UpdateTcParent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTcParent(::grpc::ServerContext* /*context*/, const ::bess::pb::UpdateTcParentRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTcStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTcStats() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_GetTcStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcStats(::grpc::ServerContext* /*context*/, const ::bess::pb::GetTcStatsRequest* /*request*/, ::bess::pb::GetTcStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListDrivers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListDrivers() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_ListDrivers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrivers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListDriversResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDriverInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetDriverInfo() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_GetDriverInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDriverInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetDriverInfoRequest* /*request*/, ::bess::pb::GetDriverInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetPorts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResetPorts() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_ResetPorts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetPorts(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListPorts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListPorts() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_ListPorts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPorts(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListPortsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreatePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreatePort() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_CreatePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePort(::grpc::ServerContext* /*context*/, const ::bess::pb::CreatePortRequest* /*request*/, ::bess::pb::CreatePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DestroyPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DestroyPort() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_DestroyPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPort(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyPortRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPortConf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetPortConf() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_SetPortConf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPortConf(::grpc::ServerContext* /*context*/, const ::bess::pb::SetPortConfRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPortConf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPortConf() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_GetPortConf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPortConf(::grpc::ServerContext* /*context*/, const ::bess::pb::GetPortConfRequest* /*request*/, ::bess::pb::GetPortConfResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPortStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPortStats() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_GetPortStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPortStats(::grpc::ServerContext* /*context*/, const ::bess::pb::GetPortStatsRequest* /*request*/, ::bess::pb::GetPortStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLinkStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLinkStatus() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_GetLinkStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLinkStatus(::grpc::ServerContext* /*context*/, const ::bess::pb::GetLinkStatusRequest* /*request*/, ::bess::pb::GetLinkStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListMclass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListMclass() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_ListMclass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMclass(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListMclassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMclassInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMclassInfo() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_GetMclassInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMclassInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetMclassInfoRequest* /*request*/, ::bess::pb::GetMclassInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResetModules() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_ResetModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetModules(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListModules() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_ListModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModules(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateModule() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_CreateModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateModule(::grpc::ServerContext* /*context*/, const ::bess::pb::CreateModuleRequest* /*request*/, ::bess::pb::CreateModuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DestroyModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DestroyModule() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_DestroyModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyModule(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyModuleRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetModuleInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetModuleInfo() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_GetModuleInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModuleInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetModuleInfoRequest* /*request*/, ::bess::pb::GetModuleInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConnectModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ConnectModules() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_ConnectModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectModules(::grpc::ServerContext* /*context*/, const ::bess::pb::ConnectModulesRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DisconnectModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DisconnectModules() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_DisconnectModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisconnectModules(::grpc::ServerContext* /*context*/, const ::bess::pb::DisconnectModulesRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DumpMempool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DumpMempool() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_DumpMempool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DumpMempool(::grpc::ServerContext* /*context*/, const ::bess::pb::DumpMempoolRequest* /*request*/, ::bess::pb::DumpMempoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ModuleCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ModuleCommand() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_ModuleCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModuleCommand(::grpc::ServerContext* /*context*/, const ::bess::pb::CommandRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListGateHookClass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListGateHookClass() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_ListGateHookClass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGateHookClass(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListGateHookClassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGateHookClassInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGateHookClassInfo() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_GetGateHookClassInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGateHookClassInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetGateHookClassInfoRequest* /*request*/, ::bess::pb::GetGateHookClassInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConfigureGateHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ConfigureGateHook() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_ConfigureGateHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureGateHook(::grpc::ServerContext* /*context*/, const ::bess::pb::ConfigureGateHookRequest* /*request*/, ::bess::pb::ConfigureGateHookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListGateHooks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListGateHooks() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_ListGateHooks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGateHooks(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListGateHooksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GateHookCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GateHookCommand() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_GateHookCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GateHookCommand(::grpc::ServerContext* /*context*/, const ::bess::pb::GateHookCommandRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConfigureResumeHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ConfigureResumeHook() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_ConfigureResumeHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureResumeHook(::grpc::ServerContext* /*context*/, const ::bess::pb::ConfigureResumeHookRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVersion() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResetAll() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ResetAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetAll(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KillBess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KillBess() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_KillBess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KillBess(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKillBess(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportPlugin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportPlugin() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ImportPlugin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportPlugin(::grpc::ServerContext* /*context*/, const ::bess::pb::ImportPluginRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportPlugin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnloadPlugin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnloadPlugin() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_UnloadPlugin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnloadPlugin(::grpc::ServerContext* /*context*/, const ::bess::pb::UnloadPluginRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnloadPlugin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListPlugins : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListPlugins() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ListPlugins() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPlugins(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListPluginsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPlugins(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PauseAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PauseAll() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_PauseAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseAll(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PauseWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PauseWorker() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_PauseWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::PauseWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseWorker(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResumeWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResumeWorker() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_ResumeWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::ResumeWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResumeWorker(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResumeAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResumeAll() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_ResumeAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResumeAll(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResetWorkers() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_ResetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetWorkers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetWorkers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListWorkers() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_ListWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListWorkers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddWorker() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_AddWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::AddWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddWorker(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DestroyWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DestroyWorker() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_DestroyWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyWorker(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetTcs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResetTcs() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_ResetTcs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetTcs(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetTcs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListTcs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListTcs() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_ListTcs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTcs(::grpc::ServerContext* /*context*/, const ::bess::pb::ListTcsRequest* /*request*/, ::bess::pb::ListTcsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTcs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckSchedulingConstraints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckSchedulingConstraints() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_CheckSchedulingConstraints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckSchedulingConstraints(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::CheckSchedulingConstraintsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckSchedulingConstraints(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddTc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddTc() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_AddTc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddTc(::grpc::ServerContext* /*context*/, const ::bess::pb::AddTcRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddTc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateTcParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateTcParams() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_UpdateTcParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTcParams(::grpc::ServerContext* /*context*/, const ::bess::pb::UpdateTcParamsRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateTcParams(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateTcParent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateTcParent() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_UpdateTcParent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTcParent(::grpc::ServerContext* /*context*/, const ::bess::pb::UpdateTcParentRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateTcParent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTcStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTcStats() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_GetTcStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcStats(::grpc::ServerContext* /*context*/, const ::bess::pb::GetTcStatsRequest* /*request*/, ::bess::pb::GetTcStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTcStats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListDrivers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListDrivers() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_ListDrivers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrivers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListDriversResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListDrivers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDriverInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetDriverInfo() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_GetDriverInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDriverInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetDriverInfoRequest* /*request*/, ::bess::pb::GetDriverInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDriverInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetPorts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResetPorts() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_ResetPorts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetPorts(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetPorts(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListPorts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListPorts() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_ListPorts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPorts(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListPortsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPorts(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreatePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreatePort() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_CreatePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePort(::grpc::ServerContext* /*context*/, const ::bess::pb::CreatePortRequest* /*request*/, ::bess::pb::CreatePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreatePort(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DestroyPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DestroyPort() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_DestroyPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPort(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyPortRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyPort(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPortConf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetPortConf() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_SetPortConf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPortConf(::grpc::ServerContext* /*context*/, const ::bess::pb::SetPortConfRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPortConf(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPortConf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPortConf() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_GetPortConf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPortConf(::grpc::ServerContext* /*context*/, const ::bess::pb::GetPortConfRequest* /*request*/, ::bess::pb::GetPortConfResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPortConf(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPortStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPortStats() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_GetPortStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPortStats(::grpc::ServerContext* /*context*/, const ::bess::pb::GetPortStatsRequest* /*request*/, ::bess::pb::GetPortStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPortStats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLinkStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLinkStatus() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_GetLinkStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLinkStatus(::grpc::ServerContext* /*context*/, const ::bess::pb::GetLinkStatusRequest* /*request*/, ::bess::pb::GetLinkStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLinkStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListMclass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListMclass() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_ListMclass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMclass(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListMclassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListMclass(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMclassInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMclassInfo() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_GetMclassInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMclassInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetMclassInfoRequest* /*request*/, ::bess::pb::GetMclassInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMclassInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResetModules() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_ResetModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetModules(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetModules(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListModules() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_ListModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModules(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListModules(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateModule() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_CreateModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateModule(::grpc::ServerContext* /*context*/, const ::bess::pb::CreateModuleRequest* /*request*/, ::bess::pb::CreateModuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateModule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DestroyModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DestroyModule() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_DestroyModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyModule(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyModuleRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyModule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetModuleInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetModuleInfo() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_GetModuleInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModuleInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetModuleInfoRequest* /*request*/, ::bess::pb::GetModuleInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModuleInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConnectModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ConnectModules() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_ConnectModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectModules(::grpc::ServerContext* /*context*/, const ::bess::pb::ConnectModulesRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectModules(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DisconnectModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DisconnectModules() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_DisconnectModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisconnectModules(::grpc::ServerContext* /*context*/, const ::bess::pb::DisconnectModulesRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisconnectModules(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DumpMempool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DumpMempool() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_DumpMempool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DumpMempool(::grpc::ServerContext* /*context*/, const ::bess::pb::DumpMempoolRequest* /*request*/, ::bess::pb::DumpMempoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDumpMempool(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ModuleCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ModuleCommand() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_ModuleCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModuleCommand(::grpc::ServerContext* /*context*/, const ::bess::pb::CommandRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestModuleCommand(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListGateHookClass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListGateHookClass() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_ListGateHookClass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGateHookClass(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListGateHookClassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListGateHookClass(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGateHookClassInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGateHookClassInfo() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_GetGateHookClassInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGateHookClassInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetGateHookClassInfoRequest* /*request*/, ::bess::pb::GetGateHookClassInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGateHookClassInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConfigureGateHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ConfigureGateHook() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_ConfigureGateHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureGateHook(::grpc::ServerContext* /*context*/, const ::bess::pb::ConfigureGateHookRequest* /*request*/, ::bess::pb::ConfigureGateHookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigureGateHook(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListGateHooks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListGateHooks() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_ListGateHooks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGateHooks(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListGateHooksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListGateHooks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GateHookCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GateHookCommand() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_GateHookCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GateHookCommand(::grpc::ServerContext* /*context*/, const ::bess::pb::GateHookCommandRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGateHookCommand(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConfigureResumeHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ConfigureResumeHook() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_ConfigureResumeHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureResumeHook(::grpc::ServerContext* /*context*/, const ::bess::pb::ConfigureResumeHookRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfigureResumeHook(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetVersion() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVersion(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResetAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResetAll() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResetAll(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResetAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetAll(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_KillBess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_KillBess() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KillBess(context, request, response); }));
    }
    ~WithRawCallbackMethod_KillBess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KillBess(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* KillBess(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ImportPlugin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ImportPlugin() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImportPlugin(context, request, response); }));
    }
    ~WithRawCallbackMethod_ImportPlugin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportPlugin(::grpc::ServerContext* /*context*/, const ::bess::pb::ImportPluginRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ImportPlugin(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UnloadPlugin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UnloadPlugin() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnloadPlugin(context, request, response); }));
    }
    ~WithRawCallbackMethod_UnloadPlugin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnloadPlugin(::grpc::ServerContext* /*context*/, const ::bess::pb::UnloadPluginRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UnloadPlugin(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListPlugins : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListPlugins() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListPlugins(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListPlugins() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPlugins(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListPluginsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListPlugins(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PauseAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PauseAll() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PauseAll(context, request, response); }));
    }
    ~WithRawCallbackMethod_PauseAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseAll(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PauseWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PauseWorker() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PauseWorker(context, request, response); }));
    }
    ~WithRawCallbackMethod_PauseWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::PauseWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PauseWorker(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResumeWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResumeWorker() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResumeWorker(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResumeWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::ResumeWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResumeWorker(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResumeAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResumeAll() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResumeAll(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResumeAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResumeAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResumeAll(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResetWorkers() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResetWorkers(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetWorkers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetWorkers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListWorkers() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListWorkers(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListWorkers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListWorkers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AddWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AddWorker() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddWorker(context, request, response); }));
    }
    ~WithRawCallbackMethod_AddWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::AddWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddWorker(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DestroyWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DestroyWorker() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DestroyWorker(context, request, response); }));
    }
    ~WithRawCallbackMethod_DestroyWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DestroyWorker(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResetTcs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResetTcs() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResetTcs(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResetTcs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetTcs(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetTcs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListTcs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListTcs() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListTcs(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListTcs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTcs(::grpc::ServerContext* /*context*/, const ::bess::pb::ListTcsRequest* /*request*/, ::bess::pb::ListTcsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListTcs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckSchedulingConstraints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckSchedulingConstraints() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckSchedulingConstraints(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckSchedulingConstraints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckSchedulingConstraints(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::CheckSchedulingConstraintsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckSchedulingConstraints(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AddTc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AddTc() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddTc(context, request, response); }));
    }
    ~WithRawCallbackMethod_AddTc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddTc(::grpc::ServerContext* /*context*/, const ::bess::pb::AddTcRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddTc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateTcParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateTcParams() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateTcParams(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateTcParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTcParams(::grpc::ServerContext* /*context*/, const ::bess::pb::UpdateTcParamsRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateTcParams(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateTcParent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateTcParent() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateTcParent(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateTcParent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTcParent(::grpc::ServerContext* /*context*/, const ::bess::pb::UpdateTcParentRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateTcParent(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTcStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTcStats() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTcStats(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTcStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcStats(::grpc::ServerContext* /*context*/, const ::bess::pb::GetTcStatsRequest* /*request*/, ::bess::pb::GetTcStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTcStats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListDrivers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListDrivers() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListDrivers(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListDrivers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListDrivers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListDriversResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListDrivers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetDriverInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetDriverInfo() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetDriverInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetDriverInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDriverInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetDriverInfoRequest* /*request*/, ::bess::pb::GetDriverInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetDriverInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResetPorts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResetPorts() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResetPorts(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResetPorts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetPorts(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetPorts(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListPorts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListPorts() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListPorts(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListPorts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPorts(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListPortsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListPorts(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreatePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreatePort() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreatePort(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreatePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePort(::grpc::ServerContext* /*context*/, const ::bess::pb::CreatePortRequest* /*request*/, ::bess::pb::CreatePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreatePort(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DestroyPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DestroyPort() {
      ::grpc::Service::MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DestroyPort(context, request, response); }));
    }
    ~WithRawCallbackMethod_DestroyPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPort(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyPortRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DestroyPort(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetPortConf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetPortConf() {
      ::grpc::Service::MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetPortConf(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetPortConf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPortConf(::grpc::ServerContext* /*context*/, const ::bess::pb::SetPortConfRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPortConf(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPortConf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPortConf() {
      ::grpc::Service::MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPortConf(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPortConf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPortConf(::grpc::ServerContext* /*context*/, const ::bess::pb::GetPortConfRequest* /*request*/, ::bess::pb::GetPortConfResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPortConf(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPortStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPortStats() {
      ::grpc::Service::MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPortStats(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPortStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPortStats(::grpc::ServerContext* /*context*/, const ::bess::pb::GetPortStatsRequest* /*request*/, ::bess::pb::GetPortStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPortStats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLinkStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLinkStatus() {
      ::grpc::Service::MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLinkStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLinkStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLinkStatus(::grpc::ServerContext* /*context*/, const ::bess::pb::GetLinkStatusRequest* /*request*/, ::bess::pb::GetLinkStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLinkStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListMclass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListMclass() {
      ::grpc::Service::MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListMclass(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListMclass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMclass(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListMclassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListMclass(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetMclassInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetMclassInfo() {
      ::grpc::Service::MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetMclassInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetMclassInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMclassInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetMclassInfoRequest* /*request*/, ::bess::pb::GetMclassInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMclassInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResetModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResetModules() {
      ::grpc::Service::MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResetModules(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResetModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetModules(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResetModules(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListModules() {
      ::grpc::Service::MarkMethodRawCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListModules(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListModules(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListModules(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateModule() {
      ::grpc::Service::MarkMethodRawCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateModule(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateModule(::grpc::ServerContext* /*context*/, const ::bess::pb::CreateModuleRequest* /*request*/, ::bess::pb::CreateModuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateModule(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DestroyModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DestroyModule() {
      ::grpc::Service::MarkMethodRawCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DestroyModule(context, request, response); }));
    }
    ~WithRawCallbackMethod_DestroyModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyModule(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyModuleRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DestroyModule(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetModuleInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetModuleInfo() {
      ::grpc::Service::MarkMethodRawCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetModuleInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetModuleInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModuleInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetModuleInfoRequest* /*request*/, ::bess::pb::GetModuleInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetModuleInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ConnectModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ConnectModules() {
      ::grpc::Service::MarkMethodRawCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ConnectModules(context, request, response); }));
    }
    ~WithRawCallbackMethod_ConnectModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectModules(::grpc::ServerContext* /*context*/, const ::bess::pb::ConnectModulesRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConnectModules(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DisconnectModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DisconnectModules() {
      ::grpc::Service::MarkMethodRawCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DisconnectModules(context, request, response); }));
    }
    ~WithRawCallbackMethod_DisconnectModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisconnectModules(::grpc::ServerContext* /*context*/, const ::bess::pb::DisconnectModulesRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisconnectModules(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DumpMempool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DumpMempool() {
      ::grpc::Service::MarkMethodRawCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DumpMempool(context, request, response); }));
    }
    ~WithRawCallbackMethod_DumpMempool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DumpMempool(::grpc::ServerContext* /*context*/, const ::bess::pb::DumpMempoolRequest* /*request*/, ::bess::pb::DumpMempoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DumpMempool(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ModuleCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ModuleCommand() {
      ::grpc::Service::MarkMethodRawCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ModuleCommand(context, request, response); }));
    }
    ~WithRawCallbackMethod_ModuleCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModuleCommand(::grpc::ServerContext* /*context*/, const ::bess::pb::CommandRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ModuleCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListGateHookClass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListGateHookClass() {
      ::grpc::Service::MarkMethodRawCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListGateHookClass(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListGateHookClass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGateHookClass(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListGateHookClassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListGateHookClass(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetGateHookClassInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetGateHookClassInfo() {
      ::grpc::Service::MarkMethodRawCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetGateHookClassInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetGateHookClassInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGateHookClassInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetGateHookClassInfoRequest* /*request*/, ::bess::pb::GetGateHookClassInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGateHookClassInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ConfigureGateHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ConfigureGateHook() {
      ::grpc::Service::MarkMethodRawCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ConfigureGateHook(context, request, response); }));
    }
    ~WithRawCallbackMethod_ConfigureGateHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureGateHook(::grpc::ServerContext* /*context*/, const ::bess::pb::ConfigureGateHookRequest* /*request*/, ::bess::pb::ConfigureGateHookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConfigureGateHook(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListGateHooks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListGateHooks() {
      ::grpc::Service::MarkMethodRawCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListGateHooks(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListGateHooks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGateHooks(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListGateHooksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListGateHooks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GateHookCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GateHookCommand() {
      ::grpc::Service::MarkMethodRawCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GateHookCommand(context, request, response); }));
    }
    ~WithRawCallbackMethod_GateHookCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GateHookCommand(::grpc::ServerContext* /*context*/, const ::bess::pb::GateHookCommandRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GateHookCommand(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ConfigureResumeHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ConfigureResumeHook() {
      ::grpc::Service::MarkMethodRawCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ConfigureResumeHook(context, request, response); }));
    }
    ~WithRawCallbackMethod_ConfigureResumeHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfigureResumeHook(::grpc::ServerContext* /*context*/, const ::bess::pb::ConfigureResumeHookRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConfigureResumeHook(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVersion() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::VersionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::VersionResponse>* streamer) {
                       return this->StreamedGetVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::VersionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResetAll() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedResetAll(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResetAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetAll(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KillBess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KillBess() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedKillBess(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KillBess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KillBess(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKillBess(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImportPlugin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImportPlugin() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::ImportPluginRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::ImportPluginRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedImportPlugin(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImportPlugin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImportPlugin(::grpc::ServerContext* /*context*/, const ::bess::pb::ImportPluginRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImportPlugin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::ImportPluginRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnloadPlugin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnloadPlugin() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::UnloadPluginRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::UnloadPluginRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedUnloadPlugin(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnloadPlugin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnloadPlugin(::grpc::ServerContext* /*context*/, const ::bess::pb::UnloadPluginRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnloadPlugin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::UnloadPluginRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListPlugins : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListPlugins() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::ListPluginsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::ListPluginsResponse>* streamer) {
                       return this->StreamedListPlugins(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListPlugins() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListPlugins(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListPluginsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListPlugins(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::ListPluginsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PauseAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PauseAll() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedPauseAll(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PauseAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PauseAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPauseAll(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PauseWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PauseWorker() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::PauseWorkerRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::PauseWorkerRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedPauseWorker(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PauseWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PauseWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::PauseWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPauseWorker(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::PauseWorkerRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResumeWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResumeWorker() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::ResumeWorkerRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::ResumeWorkerRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedResumeWorker(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResumeWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResumeWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::ResumeWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResumeWorker(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::ResumeWorkerRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResumeAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResumeAll() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedResumeAll(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResumeAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResumeAll(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResumeAll(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResetWorkers() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedResetWorkers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetWorkers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetWorkers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListWorkers() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::ListWorkersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::ListWorkersResponse>* streamer) {
                       return this->StreamedListWorkers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListWorkers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListWorkers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::ListWorkersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddWorker() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::AddWorkerRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::AddWorkerRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedAddWorker(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::AddWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddWorker(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::AddWorkerRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DestroyWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DestroyWorker() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::DestroyWorkerRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::DestroyWorkerRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedDestroyWorker(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DestroyWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DestroyWorker(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyWorkerRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDestroyWorker(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::DestroyWorkerRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetTcs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResetTcs() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedResetTcs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResetTcs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetTcs(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetTcs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListTcs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListTcs() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::ListTcsRequest, ::bess::pb::ListTcsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::ListTcsRequest, ::bess::pb::ListTcsResponse>* streamer) {
                       return this->StreamedListTcs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListTcs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListTcs(::grpc::ServerContext* /*context*/, const ::bess::pb::ListTcsRequest* /*request*/, ::bess::pb::ListTcsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListTcs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::ListTcsRequest,::bess::pb::ListTcsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckSchedulingConstraints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckSchedulingConstraints() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::CheckSchedulingConstraintsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::CheckSchedulingConstraintsResponse>* streamer) {
                       return this->StreamedCheckSchedulingConstraints(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckSchedulingConstraints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckSchedulingConstraints(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::CheckSchedulingConstraintsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckSchedulingConstraints(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::CheckSchedulingConstraintsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddTc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddTc() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::AddTcRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::AddTcRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedAddTc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddTc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddTc(::grpc::ServerContext* /*context*/, const ::bess::pb::AddTcRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddTc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::AddTcRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateTcParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateTcParams() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::UpdateTcParamsRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::UpdateTcParamsRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedUpdateTcParams(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateTcParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateTcParams(::grpc::ServerContext* /*context*/, const ::bess::pb::UpdateTcParamsRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateTcParams(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::UpdateTcParamsRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateTcParent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateTcParent() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::UpdateTcParentRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::UpdateTcParentRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedUpdateTcParent(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateTcParent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateTcParent(::grpc::ServerContext* /*context*/, const ::bess::pb::UpdateTcParentRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateTcParent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::UpdateTcParentRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTcStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTcStats() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::GetTcStatsRequest, ::bess::pb::GetTcStatsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::GetTcStatsRequest, ::bess::pb::GetTcStatsResponse>* streamer) {
                       return this->StreamedGetTcStats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTcStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTcStats(::grpc::ServerContext* /*context*/, const ::bess::pb::GetTcStatsRequest* /*request*/, ::bess::pb::GetTcStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTcStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::GetTcStatsRequest,::bess::pb::GetTcStatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListDrivers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListDrivers() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::ListDriversResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::ListDriversResponse>* streamer) {
                       return this->StreamedListDrivers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListDrivers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListDrivers(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListDriversResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListDrivers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::ListDriversResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDriverInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetDriverInfo() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::GetDriverInfoRequest, ::bess::pb::GetDriverInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::GetDriverInfoRequest, ::bess::pb::GetDriverInfoResponse>* streamer) {
                       return this->StreamedGetDriverInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetDriverInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDriverInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetDriverInfoRequest* /*request*/, ::bess::pb::GetDriverInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDriverInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::GetDriverInfoRequest,::bess::pb::GetDriverInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetPorts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResetPorts() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedResetPorts(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResetPorts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetPorts(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetPorts(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListPorts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListPorts() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::ListPortsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::ListPortsResponse>* streamer) {
                       return this->StreamedListPorts(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListPorts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListPorts(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListPortsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListPorts(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::ListPortsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreatePort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreatePort() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::CreatePortRequest, ::bess::pb::CreatePortResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::CreatePortRequest, ::bess::pb::CreatePortResponse>* streamer) {
                       return this->StreamedCreatePort(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreatePort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreatePort(::grpc::ServerContext* /*context*/, const ::bess::pb::CreatePortRequest* /*request*/, ::bess::pb::CreatePortResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreatePort(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::CreatePortRequest,::bess::pb::CreatePortResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DestroyPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DestroyPort() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::DestroyPortRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::DestroyPortRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedDestroyPort(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DestroyPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DestroyPort(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyPortRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDestroyPort(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::DestroyPortRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPortConf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetPortConf() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::SetPortConfRequest, ::bess::pb::CommandResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::SetPortConfRequest, ::bess::pb::CommandResponse>* streamer) {
                       return this->StreamedSetPortConf(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetPortConf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPortConf(::grpc::ServerContext* /*context*/, const ::bess::pb::SetPortConfRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPortConf(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::SetPortConfRequest,::bess::pb::CommandResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPortConf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPortConf() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::GetPortConfRequest, ::bess::pb::GetPortConfResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::GetPortConfRequest, ::bess::pb::GetPortConfResponse>* streamer) {
                       return this->StreamedGetPortConf(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPortConf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPortConf(::grpc::ServerContext* /*context*/, const ::bess::pb::GetPortConfRequest* /*request*/, ::bess::pb::GetPortConfResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPortConf(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::GetPortConfRequest,::bess::pb::GetPortConfResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPortStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPortStats() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::GetPortStatsRequest, ::bess::pb::GetPortStatsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::GetPortStatsRequest, ::bess::pb::GetPortStatsResponse>* streamer) {
                       return this->StreamedGetPortStats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPortStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPortStats(::grpc::ServerContext* /*context*/, const ::bess::pb::GetPortStatsRequest* /*request*/, ::bess::pb::GetPortStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPortStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::GetPortStatsRequest,::bess::pb::GetPortStatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLinkStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLinkStatus() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::GetLinkStatusRequest, ::bess::pb::GetLinkStatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::GetLinkStatusRequest, ::bess::pb::GetLinkStatusResponse>* streamer) {
                       return this->StreamedGetLinkStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLinkStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLinkStatus(::grpc::ServerContext* /*context*/, const ::bess::pb::GetLinkStatusRequest* /*request*/, ::bess::pb::GetLinkStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLinkStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::GetLinkStatusRequest,::bess::pb::GetLinkStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListMclass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListMclass() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::ListMclassResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::ListMclassResponse>* streamer) {
                       return this->StreamedListMclass(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListMclass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListMclass(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListMclassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListMclass(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::ListMclassResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMclassInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMclassInfo() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::GetMclassInfoRequest, ::bess::pb::GetMclassInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::GetMclassInfoRequest, ::bess::pb::GetMclassInfoResponse>* streamer) {
                       return this->StreamedGetMclassInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetMclassInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMclassInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetMclassInfoRequest* /*request*/, ::bess::pb::GetMclassInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMclassInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::GetMclassInfoRequest,::bess::pb::GetMclassInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResetModules() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedResetModules(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResetModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetModules(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetModules(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListModules() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::ListModulesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::ListModulesResponse>* streamer) {
                       return this->StreamedListModules(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListModules(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListModules(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::ListModulesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateModule() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::CreateModuleRequest, ::bess::pb::CreateModuleResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::CreateModuleRequest, ::bess::pb::CreateModuleResponse>* streamer) {
                       return this->StreamedCreateModule(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateModule(::grpc::ServerContext* /*context*/, const ::bess::pb::CreateModuleRequest* /*request*/, ::bess::pb::CreateModuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateModule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::CreateModuleRequest,::bess::pb::CreateModuleResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DestroyModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DestroyModule() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::DestroyModuleRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::DestroyModuleRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedDestroyModule(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DestroyModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DestroyModule(::grpc::ServerContext* /*context*/, const ::bess::pb::DestroyModuleRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDestroyModule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::DestroyModuleRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetModuleInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetModuleInfo() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::GetModuleInfoRequest, ::bess::pb::GetModuleInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::GetModuleInfoRequest, ::bess::pb::GetModuleInfoResponse>* streamer) {
                       return this->StreamedGetModuleInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetModuleInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetModuleInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetModuleInfoRequest* /*request*/, ::bess::pb::GetModuleInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetModuleInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::GetModuleInfoRequest,::bess::pb::GetModuleInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConnectModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ConnectModules() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::ConnectModulesRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::ConnectModulesRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedConnectModules(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ConnectModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConnectModules(::grpc::ServerContext* /*context*/, const ::bess::pb::ConnectModulesRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConnectModules(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::ConnectModulesRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DisconnectModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DisconnectModules() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::DisconnectModulesRequest, ::bess::pb::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::DisconnectModulesRequest, ::bess::pb::EmptyResponse>* streamer) {
                       return this->StreamedDisconnectModules(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DisconnectModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DisconnectModules(::grpc::ServerContext* /*context*/, const ::bess::pb::DisconnectModulesRequest* /*request*/, ::bess::pb::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisconnectModules(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::DisconnectModulesRequest,::bess::pb::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DumpMempool : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DumpMempool() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::DumpMempoolRequest, ::bess::pb::DumpMempoolResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::DumpMempoolRequest, ::bess::pb::DumpMempoolResponse>* streamer) {
                       return this->StreamedDumpMempool(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DumpMempool() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DumpMempool(::grpc::ServerContext* /*context*/, const ::bess::pb::DumpMempoolRequest* /*request*/, ::bess::pb::DumpMempoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDumpMempool(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::DumpMempoolRequest,::bess::pb::DumpMempoolResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ModuleCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ModuleCommand() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::CommandRequest, ::bess::pb::CommandResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::CommandRequest, ::bess::pb::CommandResponse>* streamer) {
                       return this->StreamedModuleCommand(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ModuleCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ModuleCommand(::grpc::ServerContext* /*context*/, const ::bess::pb::CommandRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedModuleCommand(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::CommandRequest,::bess::pb::CommandResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListGateHookClass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListGateHookClass() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::ListGateHookClassResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::ListGateHookClassResponse>* streamer) {
                       return this->StreamedListGateHookClass(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListGateHookClass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListGateHookClass(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListGateHookClassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListGateHookClass(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::ListGateHookClassResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGateHookClassInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetGateHookClassInfo() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::GetGateHookClassInfoRequest, ::bess::pb::GetGateHookClassInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::GetGateHookClassInfoRequest, ::bess::pb::GetGateHookClassInfoResponse>* streamer) {
                       return this->StreamedGetGateHookClassInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetGateHookClassInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGateHookClassInfo(::grpc::ServerContext* /*context*/, const ::bess::pb::GetGateHookClassInfoRequest* /*request*/, ::bess::pb::GetGateHookClassInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGateHookClassInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::GetGateHookClassInfoRequest,::bess::pb::GetGateHookClassInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConfigureGateHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ConfigureGateHook() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::ConfigureGateHookRequest, ::bess::pb::ConfigureGateHookResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::ConfigureGateHookRequest, ::bess::pb::ConfigureGateHookResponse>* streamer) {
                       return this->StreamedConfigureGateHook(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ConfigureGateHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConfigureGateHook(::grpc::ServerContext* /*context*/, const ::bess::pb::ConfigureGateHookRequest* /*request*/, ::bess::pb::ConfigureGateHookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConfigureGateHook(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::ConfigureGateHookRequest,::bess::pb::ConfigureGateHookResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListGateHooks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListGateHooks() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::EmptyRequest, ::bess::pb::ListGateHooksResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::EmptyRequest, ::bess::pb::ListGateHooksResponse>* streamer) {
                       return this->StreamedListGateHooks(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListGateHooks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListGateHooks(::grpc::ServerContext* /*context*/, const ::bess::pb::EmptyRequest* /*request*/, ::bess::pb::ListGateHooksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListGateHooks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::EmptyRequest,::bess::pb::ListGateHooksResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GateHookCommand : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GateHookCommand() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::GateHookCommandRequest, ::bess::pb::CommandResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::GateHookCommandRequest, ::bess::pb::CommandResponse>* streamer) {
                       return this->StreamedGateHookCommand(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GateHookCommand() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GateHookCommand(::grpc::ServerContext* /*context*/, const ::bess::pb::GateHookCommandRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGateHookCommand(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::GateHookCommandRequest,::bess::pb::CommandResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConfigureResumeHook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ConfigureResumeHook() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bess::pb::ConfigureResumeHookRequest, ::bess::pb::CommandResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bess::pb::ConfigureResumeHookRequest, ::bess::pb::CommandResponse>* streamer) {
                       return this->StreamedConfigureResumeHook(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ConfigureResumeHook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConfigureResumeHook(::grpc::ServerContext* /*context*/, const ::bess::pb::ConfigureResumeHookRequest* /*request*/, ::bess::pb::CommandResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConfigureResumeHook(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bess::pb::ConfigureResumeHookRequest,::bess::pb::CommandResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetVersion<WithStreamedUnaryMethod_ResetAll<WithStreamedUnaryMethod_KillBess<WithStreamedUnaryMethod_ImportPlugin<WithStreamedUnaryMethod_UnloadPlugin<WithStreamedUnaryMethod_ListPlugins<WithStreamedUnaryMethod_PauseAll<WithStreamedUnaryMethod_PauseWorker<WithStreamedUnaryMethod_ResumeWorker<WithStreamedUnaryMethod_ResumeAll<WithStreamedUnaryMethod_ResetWorkers<WithStreamedUnaryMethod_ListWorkers<WithStreamedUnaryMethod_AddWorker<WithStreamedUnaryMethod_DestroyWorker<WithStreamedUnaryMethod_ResetTcs<WithStreamedUnaryMethod_ListTcs<WithStreamedUnaryMethod_CheckSchedulingConstraints<WithStreamedUnaryMethod_AddTc<WithStreamedUnaryMethod_UpdateTcParams<WithStreamedUnaryMethod_UpdateTcParent<WithStreamedUnaryMethod_GetTcStats<WithStreamedUnaryMethod_ListDrivers<WithStreamedUnaryMethod_GetDriverInfo<WithStreamedUnaryMethod_ResetPorts<WithStreamedUnaryMethod_ListPorts<WithStreamedUnaryMethod_CreatePort<WithStreamedUnaryMethod_DestroyPort<WithStreamedUnaryMethod_SetPortConf<WithStreamedUnaryMethod_GetPortConf<WithStreamedUnaryMethod_GetPortStats<WithStreamedUnaryMethod_GetLinkStatus<WithStreamedUnaryMethod_ListMclass<WithStreamedUnaryMethod_GetMclassInfo<WithStreamedUnaryMethod_ResetModules<WithStreamedUnaryMethod_ListModules<WithStreamedUnaryMethod_CreateModule<WithStreamedUnaryMethod_DestroyModule<WithStreamedUnaryMethod_GetModuleInfo<WithStreamedUnaryMethod_ConnectModules<WithStreamedUnaryMethod_DisconnectModules<WithStreamedUnaryMethod_DumpMempool<WithStreamedUnaryMethod_ModuleCommand<WithStreamedUnaryMethod_ListGateHookClass<WithStreamedUnaryMethod_GetGateHookClassInfo<WithStreamedUnaryMethod_ConfigureGateHook<WithStreamedUnaryMethod_ListGateHooks<WithStreamedUnaryMethod_GateHookCommand<WithStreamedUnaryMethod_ConfigureResumeHook<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetVersion<WithStreamedUnaryMethod_ResetAll<WithStreamedUnaryMethod_KillBess<WithStreamedUnaryMethod_ImportPlugin<WithStreamedUnaryMethod_UnloadPlugin<WithStreamedUnaryMethod_ListPlugins<WithStreamedUnaryMethod_PauseAll<WithStreamedUnaryMethod_PauseWorker<WithStreamedUnaryMethod_ResumeWorker<WithStreamedUnaryMethod_ResumeAll<WithStreamedUnaryMethod_ResetWorkers<WithStreamedUnaryMethod_ListWorkers<WithStreamedUnaryMethod_AddWorker<WithStreamedUnaryMethod_DestroyWorker<WithStreamedUnaryMethod_ResetTcs<WithStreamedUnaryMethod_ListTcs<WithStreamedUnaryMethod_CheckSchedulingConstraints<WithStreamedUnaryMethod_AddTc<WithStreamedUnaryMethod_UpdateTcParams<WithStreamedUnaryMethod_UpdateTcParent<WithStreamedUnaryMethod_GetTcStats<WithStreamedUnaryMethod_ListDrivers<WithStreamedUnaryMethod_GetDriverInfo<WithStreamedUnaryMethod_ResetPorts<WithStreamedUnaryMethod_ListPorts<WithStreamedUnaryMethod_CreatePort<WithStreamedUnaryMethod_DestroyPort<WithStreamedUnaryMethod_SetPortConf<WithStreamedUnaryMethod_GetPortConf<WithStreamedUnaryMethod_GetPortStats<WithStreamedUnaryMethod_GetLinkStatus<WithStreamedUnaryMethod_ListMclass<WithStreamedUnaryMethod_GetMclassInfo<WithStreamedUnaryMethod_ResetModules<WithStreamedUnaryMethod_ListModules<WithStreamedUnaryMethod_CreateModule<WithStreamedUnaryMethod_DestroyModule<WithStreamedUnaryMethod_GetModuleInfo<WithStreamedUnaryMethod_ConnectModules<WithStreamedUnaryMethod_DisconnectModules<WithStreamedUnaryMethod_DumpMempool<WithStreamedUnaryMethod_ModuleCommand<WithStreamedUnaryMethod_ListGateHookClass<WithStreamedUnaryMethod_GetGateHookClassInfo<WithStreamedUnaryMethod_ConfigureGateHook<WithStreamedUnaryMethod_ListGateHooks<WithStreamedUnaryMethod_GateHookCommand<WithStreamedUnaryMethod_ConfigureResumeHook<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace pb
}  // namespace bess


#endif  // GRPC_service_2eproto__INCLUDED
