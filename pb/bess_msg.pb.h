// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bess_msg.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_bess_5fmsg_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_bess_5fmsg_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/any.pb.h"
#include "error.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_bess_5fmsg_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_bess_5fmsg_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_bess_5fmsg_2eproto;
namespace bess {
namespace pb {
class AddTcRequest;
struct AddTcRequestDefaultTypeInternal;
extern AddTcRequestDefaultTypeInternal _AddTcRequest_default_instance_;
class AddWorkerRequest;
struct AddWorkerRequestDefaultTypeInternal;
extern AddWorkerRequestDefaultTypeInternal _AddWorkerRequest_default_instance_;
class CheckSchedulingConstraintsResponse;
struct CheckSchedulingConstraintsResponseDefaultTypeInternal;
extern CheckSchedulingConstraintsResponseDefaultTypeInternal _CheckSchedulingConstraintsResponse_default_instance_;
class CheckSchedulingConstraintsResponse_ViolatingClass;
struct CheckSchedulingConstraintsResponse_ViolatingClassDefaultTypeInternal;
extern CheckSchedulingConstraintsResponse_ViolatingClassDefaultTypeInternal _CheckSchedulingConstraintsResponse_ViolatingClass_default_instance_;
class CheckSchedulingConstraintsResponse_ViolatingModule;
struct CheckSchedulingConstraintsResponse_ViolatingModuleDefaultTypeInternal;
extern CheckSchedulingConstraintsResponse_ViolatingModuleDefaultTypeInternal _CheckSchedulingConstraintsResponse_ViolatingModule_default_instance_;
class CommandRequest;
struct CommandRequestDefaultTypeInternal;
extern CommandRequestDefaultTypeInternal _CommandRequest_default_instance_;
class CommandResponse;
struct CommandResponseDefaultTypeInternal;
extern CommandResponseDefaultTypeInternal _CommandResponse_default_instance_;
class ConfigureGateHookRequest;
struct ConfigureGateHookRequestDefaultTypeInternal;
extern ConfigureGateHookRequestDefaultTypeInternal _ConfigureGateHookRequest_default_instance_;
class ConfigureGateHookResponse;
struct ConfigureGateHookResponseDefaultTypeInternal;
extern ConfigureGateHookResponseDefaultTypeInternal _ConfigureGateHookResponse_default_instance_;
class ConfigureResumeHookRequest;
struct ConfigureResumeHookRequestDefaultTypeInternal;
extern ConfigureResumeHookRequestDefaultTypeInternal _ConfigureResumeHookRequest_default_instance_;
class ConnectModulesRequest;
struct ConnectModulesRequestDefaultTypeInternal;
extern ConnectModulesRequestDefaultTypeInternal _ConnectModulesRequest_default_instance_;
class CreateModuleRequest;
struct CreateModuleRequestDefaultTypeInternal;
extern CreateModuleRequestDefaultTypeInternal _CreateModuleRequest_default_instance_;
class CreateModuleResponse;
struct CreateModuleResponseDefaultTypeInternal;
extern CreateModuleResponseDefaultTypeInternal _CreateModuleResponse_default_instance_;
class CreatePortRequest;
struct CreatePortRequestDefaultTypeInternal;
extern CreatePortRequestDefaultTypeInternal _CreatePortRequest_default_instance_;
class CreatePortResponse;
struct CreatePortResponseDefaultTypeInternal;
extern CreatePortResponseDefaultTypeInternal _CreatePortResponse_default_instance_;
class DestroyModuleRequest;
struct DestroyModuleRequestDefaultTypeInternal;
extern DestroyModuleRequestDefaultTypeInternal _DestroyModuleRequest_default_instance_;
class DestroyPortRequest;
struct DestroyPortRequestDefaultTypeInternal;
extern DestroyPortRequestDefaultTypeInternal _DestroyPortRequest_default_instance_;
class DestroyWorkerRequest;
struct DestroyWorkerRequestDefaultTypeInternal;
extern DestroyWorkerRequestDefaultTypeInternal _DestroyWorkerRequest_default_instance_;
class DisconnectModulesRequest;
struct DisconnectModulesRequestDefaultTypeInternal;
extern DisconnectModulesRequestDefaultTypeInternal _DisconnectModulesRequest_default_instance_;
class DumpMempoolRequest;
struct DumpMempoolRequestDefaultTypeInternal;
extern DumpMempoolRequestDefaultTypeInternal _DumpMempoolRequest_default_instance_;
class DumpMempoolResponse;
struct DumpMempoolResponseDefaultTypeInternal;
extern DumpMempoolResponseDefaultTypeInternal _DumpMempoolResponse_default_instance_;
class EmptyRequest;
struct EmptyRequestDefaultTypeInternal;
extern EmptyRequestDefaultTypeInternal _EmptyRequest_default_instance_;
class EmptyResponse;
struct EmptyResponseDefaultTypeInternal;
extern EmptyResponseDefaultTypeInternal _EmptyResponse_default_instance_;
class GateHookCommandRequest;
struct GateHookCommandRequestDefaultTypeInternal;
extern GateHookCommandRequestDefaultTypeInternal _GateHookCommandRequest_default_instance_;
class GateHookInfo;
struct GateHookInfoDefaultTypeInternal;
extern GateHookInfoDefaultTypeInternal _GateHookInfo_default_instance_;
class GetDriverInfoRequest;
struct GetDriverInfoRequestDefaultTypeInternal;
extern GetDriverInfoRequestDefaultTypeInternal _GetDriverInfoRequest_default_instance_;
class GetDriverInfoResponse;
struct GetDriverInfoResponseDefaultTypeInternal;
extern GetDriverInfoResponseDefaultTypeInternal _GetDriverInfoResponse_default_instance_;
class GetGateHookClassInfoRequest;
struct GetGateHookClassInfoRequestDefaultTypeInternal;
extern GetGateHookClassInfoRequestDefaultTypeInternal _GetGateHookClassInfoRequest_default_instance_;
class GetGateHookClassInfoResponse;
struct GetGateHookClassInfoResponseDefaultTypeInternal;
extern GetGateHookClassInfoResponseDefaultTypeInternal _GetGateHookClassInfoResponse_default_instance_;
class GetLinkStatusRequest;
struct GetLinkStatusRequestDefaultTypeInternal;
extern GetLinkStatusRequestDefaultTypeInternal _GetLinkStatusRequest_default_instance_;
class GetLinkStatusResponse;
struct GetLinkStatusResponseDefaultTypeInternal;
extern GetLinkStatusResponseDefaultTypeInternal _GetLinkStatusResponse_default_instance_;
class GetMclassInfoRequest;
struct GetMclassInfoRequestDefaultTypeInternal;
extern GetMclassInfoRequestDefaultTypeInternal _GetMclassInfoRequest_default_instance_;
class GetMclassInfoResponse;
struct GetMclassInfoResponseDefaultTypeInternal;
extern GetMclassInfoResponseDefaultTypeInternal _GetMclassInfoResponse_default_instance_;
class GetModuleInfoRequest;
struct GetModuleInfoRequestDefaultTypeInternal;
extern GetModuleInfoRequestDefaultTypeInternal _GetModuleInfoRequest_default_instance_;
class GetModuleInfoResponse;
struct GetModuleInfoResponseDefaultTypeInternal;
extern GetModuleInfoResponseDefaultTypeInternal _GetModuleInfoResponse_default_instance_;
class GetModuleInfoResponse_Attribute;
struct GetModuleInfoResponse_AttributeDefaultTypeInternal;
extern GetModuleInfoResponse_AttributeDefaultTypeInternal _GetModuleInfoResponse_Attribute_default_instance_;
class GetModuleInfoResponse_GateHook;
struct GetModuleInfoResponse_GateHookDefaultTypeInternal;
extern GetModuleInfoResponse_GateHookDefaultTypeInternal _GetModuleInfoResponse_GateHook_default_instance_;
class GetModuleInfoResponse_IGate;
struct GetModuleInfoResponse_IGateDefaultTypeInternal;
extern GetModuleInfoResponse_IGateDefaultTypeInternal _GetModuleInfoResponse_IGate_default_instance_;
class GetModuleInfoResponse_IGate_OGate;
struct GetModuleInfoResponse_IGate_OGateDefaultTypeInternal;
extern GetModuleInfoResponse_IGate_OGateDefaultTypeInternal _GetModuleInfoResponse_IGate_OGate_default_instance_;
class GetModuleInfoResponse_OGate;
struct GetModuleInfoResponse_OGateDefaultTypeInternal;
extern GetModuleInfoResponse_OGateDefaultTypeInternal _GetModuleInfoResponse_OGate_default_instance_;
class GetPortConfRequest;
struct GetPortConfRequestDefaultTypeInternal;
extern GetPortConfRequestDefaultTypeInternal _GetPortConfRequest_default_instance_;
class GetPortConfResponse;
struct GetPortConfResponseDefaultTypeInternal;
extern GetPortConfResponseDefaultTypeInternal _GetPortConfResponse_default_instance_;
class GetPortStatsRequest;
struct GetPortStatsRequestDefaultTypeInternal;
extern GetPortStatsRequestDefaultTypeInternal _GetPortStatsRequest_default_instance_;
class GetPortStatsResponse;
struct GetPortStatsResponseDefaultTypeInternal;
extern GetPortStatsResponseDefaultTypeInternal _GetPortStatsResponse_default_instance_;
class GetPortStatsResponse_Stat;
struct GetPortStatsResponse_StatDefaultTypeInternal;
extern GetPortStatsResponse_StatDefaultTypeInternal _GetPortStatsResponse_Stat_default_instance_;
class GetTcStatsRequest;
struct GetTcStatsRequestDefaultTypeInternal;
extern GetTcStatsRequestDefaultTypeInternal _GetTcStatsRequest_default_instance_;
class GetTcStatsResponse;
struct GetTcStatsResponseDefaultTypeInternal;
extern GetTcStatsResponseDefaultTypeInternal _GetTcStatsResponse_default_instance_;
class ImportPluginRequest;
struct ImportPluginRequestDefaultTypeInternal;
extern ImportPluginRequestDefaultTypeInternal _ImportPluginRequest_default_instance_;
class ListDriversResponse;
struct ListDriversResponseDefaultTypeInternal;
extern ListDriversResponseDefaultTypeInternal _ListDriversResponse_default_instance_;
class ListGateHookClassResponse;
struct ListGateHookClassResponseDefaultTypeInternal;
extern ListGateHookClassResponseDefaultTypeInternal _ListGateHookClassResponse_default_instance_;
class ListGateHooksResponse;
struct ListGateHooksResponseDefaultTypeInternal;
extern ListGateHooksResponseDefaultTypeInternal _ListGateHooksResponse_default_instance_;
class ListMclassResponse;
struct ListMclassResponseDefaultTypeInternal;
extern ListMclassResponseDefaultTypeInternal _ListMclassResponse_default_instance_;
class ListModulesResponse;
struct ListModulesResponseDefaultTypeInternal;
extern ListModulesResponseDefaultTypeInternal _ListModulesResponse_default_instance_;
class ListModulesResponse_Module;
struct ListModulesResponse_ModuleDefaultTypeInternal;
extern ListModulesResponse_ModuleDefaultTypeInternal _ListModulesResponse_Module_default_instance_;
class ListPluginsResponse;
struct ListPluginsResponseDefaultTypeInternal;
extern ListPluginsResponseDefaultTypeInternal _ListPluginsResponse_default_instance_;
class ListPortsResponse;
struct ListPortsResponseDefaultTypeInternal;
extern ListPortsResponseDefaultTypeInternal _ListPortsResponse_default_instance_;
class ListPortsResponse_Port;
struct ListPortsResponse_PortDefaultTypeInternal;
extern ListPortsResponse_PortDefaultTypeInternal _ListPortsResponse_Port_default_instance_;
class ListTcsRequest;
struct ListTcsRequestDefaultTypeInternal;
extern ListTcsRequestDefaultTypeInternal _ListTcsRequest_default_instance_;
class ListTcsResponse;
struct ListTcsResponseDefaultTypeInternal;
extern ListTcsResponseDefaultTypeInternal _ListTcsResponse_default_instance_;
class ListTcsResponse_TrafficClassStatus;
struct ListTcsResponse_TrafficClassStatusDefaultTypeInternal;
extern ListTcsResponse_TrafficClassStatusDefaultTypeInternal _ListTcsResponse_TrafficClassStatus_default_instance_;
class ListWorkersResponse;
struct ListWorkersResponseDefaultTypeInternal;
extern ListWorkersResponseDefaultTypeInternal _ListWorkersResponse_default_instance_;
class ListWorkersResponse_WorkerStatus;
struct ListWorkersResponse_WorkerStatusDefaultTypeInternal;
extern ListWorkersResponse_WorkerStatusDefaultTypeInternal _ListWorkersResponse_WorkerStatus_default_instance_;
class MempoolDump;
struct MempoolDumpDefaultTypeInternal;
extern MempoolDumpDefaultTypeInternal _MempoolDump_default_instance_;
class PauseWorkerRequest;
struct PauseWorkerRequestDefaultTypeInternal;
extern PauseWorkerRequestDefaultTypeInternal _PauseWorkerRequest_default_instance_;
class PcapngArg;
struct PcapngArgDefaultTypeInternal;
extern PcapngArgDefaultTypeInternal _PcapngArg_default_instance_;
class PortConf;
struct PortConfDefaultTypeInternal;
extern PortConfDefaultTypeInternal _PortConf_default_instance_;
class ResumeWorkerRequest;
struct ResumeWorkerRequestDefaultTypeInternal;
extern ResumeWorkerRequestDefaultTypeInternal _ResumeWorkerRequest_default_instance_;
class SetPortConfRequest;
struct SetPortConfRequestDefaultTypeInternal;
extern SetPortConfRequestDefaultTypeInternal _SetPortConfRequest_default_instance_;
class TcpdumpArg;
struct TcpdumpArgDefaultTypeInternal;
extern TcpdumpArgDefaultTypeInternal _TcpdumpArg_default_instance_;
class TrackArg;
struct TrackArgDefaultTypeInternal;
extern TrackArgDefaultTypeInternal _TrackArg_default_instance_;
class TrafficClass;
struct TrafficClassDefaultTypeInternal;
extern TrafficClassDefaultTypeInternal _TrafficClass_default_instance_;
class TrafficClass_LimitEntry_DoNotUse;
struct TrafficClass_LimitEntry_DoNotUseDefaultTypeInternal;
extern TrafficClass_LimitEntry_DoNotUseDefaultTypeInternal _TrafficClass_LimitEntry_DoNotUse_default_instance_;
class TrafficClass_MaxBurstEntry_DoNotUse;
struct TrafficClass_MaxBurstEntry_DoNotUseDefaultTypeInternal;
extern TrafficClass_MaxBurstEntry_DoNotUseDefaultTypeInternal _TrafficClass_MaxBurstEntry_DoNotUse_default_instance_;
class UnloadPluginRequest;
struct UnloadPluginRequestDefaultTypeInternal;
extern UnloadPluginRequestDefaultTypeInternal _UnloadPluginRequest_default_instance_;
class UpdateTcParamsRequest;
struct UpdateTcParamsRequestDefaultTypeInternal;
extern UpdateTcParamsRequestDefaultTypeInternal _UpdateTcParamsRequest_default_instance_;
class UpdateTcParentRequest;
struct UpdateTcParentRequestDefaultTypeInternal;
extern UpdateTcParentRequestDefaultTypeInternal _UpdateTcParentRequest_default_instance_;
class VersionResponse;
struct VersionResponseDefaultTypeInternal;
extern VersionResponseDefaultTypeInternal _VersionResponse_default_instance_;
}  // namespace pb
}  // namespace bess
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace bess {
namespace pb {

// ===================================================================


// -------------------------------------------------------------------

class UnloadPluginRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.UnloadPluginRequest) */ {
 public:
  inline UnloadPluginRequest() : UnloadPluginRequest(nullptr) {}
  ~UnloadPluginRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UnloadPluginRequest(::google::protobuf::internal::ConstantInitialized);

  inline UnloadPluginRequest(const UnloadPluginRequest& from)
      : UnloadPluginRequest(nullptr, from) {}
  UnloadPluginRequest(UnloadPluginRequest&& from) noexcept
    : UnloadPluginRequest() {
    *this = ::std::move(from);
  }

  inline UnloadPluginRequest& operator=(const UnloadPluginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnloadPluginRequest& operator=(UnloadPluginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnloadPluginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnloadPluginRequest* internal_default_instance() {
    return reinterpret_cast<const UnloadPluginRequest*>(
               &_UnloadPluginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UnloadPluginRequest& a, UnloadPluginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnloadPluginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnloadPluginRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnloadPluginRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnloadPluginRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnloadPluginRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UnloadPluginRequest& from) {
    UnloadPluginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UnloadPluginRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.UnloadPluginRequest";
  }
  protected:
  explicit UnloadPluginRequest(::google::protobuf::Arena* arena);
  UnloadPluginRequest(::google::protobuf::Arena* arena, const UnloadPluginRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.UnloadPluginRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr path_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class TrafficClass_MaxBurstEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          TrafficClass_MaxBurstEntry_DoNotUse, std::string, ::int64_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT64> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      TrafficClass_MaxBurstEntry_DoNotUse, std::string, ::int64_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64>;
  TrafficClass_MaxBurstEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficClass_MaxBurstEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TrafficClass_MaxBurstEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const TrafficClass_MaxBurstEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const TrafficClass_MaxBurstEntry_DoNotUse*>(
        &_TrafficClass_MaxBurstEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "bess.pb.TrafficClass.MaxBurstEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class TrafficClass_LimitEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          TrafficClass_LimitEntry_DoNotUse, std::string, ::int64_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT64> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      TrafficClass_LimitEntry_DoNotUse, std::string, ::int64_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64>;
  TrafficClass_LimitEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficClass_LimitEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TrafficClass_LimitEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const TrafficClass_LimitEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const TrafficClass_LimitEntry_DoNotUse*>(
        &_TrafficClass_LimitEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "bess.pb.TrafficClass.LimitEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};
// -------------------------------------------------------------------

class TrackArg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.TrackArg) */ {
 public:
  inline TrackArg() : TrackArg(nullptr) {}
  ~TrackArg() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrackArg(::google::protobuf::internal::ConstantInitialized);

  inline TrackArg(const TrackArg& from)
      : TrackArg(nullptr, from) {}
  TrackArg(TrackArg&& from) noexcept
    : TrackArg() {
    *this = ::std::move(from);
  }

  inline TrackArg& operator=(const TrackArg& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackArg& operator=(TrackArg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackArg& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackArg* internal_default_instance() {
    return reinterpret_cast<const TrackArg*>(
               &_TrackArg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(TrackArg& a, TrackArg& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackArg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackArg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackArg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackArg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrackArg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrackArg& from) {
    TrackArg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrackArg* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.TrackArg";
  }
  protected:
  explicit TrackArg(::google::protobuf::Arena* arena);
  TrackArg(::google::protobuf::Arena* arena, const TrackArg& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBitsFieldNumber = 5,
  };
  // bool bits = 5;
  void clear_bits() ;
  bool bits() const;
  void set_bits(bool value);

  private:
  bool _internal_bits() const;
  void _internal_set_bits(bool value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.TrackArg)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class TcpdumpArg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.TcpdumpArg) */ {
 public:
  inline TcpdumpArg() : TcpdumpArg(nullptr) {}
  ~TcpdumpArg() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TcpdumpArg(::google::protobuf::internal::ConstantInitialized);

  inline TcpdumpArg(const TcpdumpArg& from)
      : TcpdumpArg(nullptr, from) {}
  TcpdumpArg(TcpdumpArg&& from) noexcept
    : TcpdumpArg() {
    *this = ::std::move(from);
  }

  inline TcpdumpArg& operator=(const TcpdumpArg& from) {
    CopyFrom(from);
    return *this;
  }
  inline TcpdumpArg& operator=(TcpdumpArg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TcpdumpArg& default_instance() {
    return *internal_default_instance();
  }
  static inline const TcpdumpArg* internal_default_instance() {
    return reinterpret_cast<const TcpdumpArg*>(
               &_TcpdumpArg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(TcpdumpArg& a, TcpdumpArg& b) {
    a.Swap(&b);
  }
  inline void Swap(TcpdumpArg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TcpdumpArg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TcpdumpArg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TcpdumpArg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TcpdumpArg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TcpdumpArg& from) {
    TcpdumpArg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TcpdumpArg* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.TcpdumpArg";
  }
  protected:
  explicit TcpdumpArg(::google::protobuf::Arena* arena);
  TcpdumpArg(::google::protobuf::Arena* arena, const TcpdumpArg& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFifoFieldNumber = 5,
    kDeferFieldNumber = 6,
    kReconnectFieldNumber = 7,
  };
  // string fifo = 5;
  void clear_fifo() ;
  const std::string& fifo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fifo(Arg_&& arg, Args_... args);
  std::string* mutable_fifo();
  PROTOBUF_NODISCARD std::string* release_fifo();
  void set_allocated_fifo(std::string* value);

  private:
  const std::string& _internal_fifo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fifo(
      const std::string& value);
  std::string* _internal_mutable_fifo();

  public:
  // bool defer = 6;
  void clear_defer() ;
  bool defer() const;
  void set_defer(bool value);

  private:
  bool _internal_defer() const;
  void _internal_set_defer(bool value);

  public:
  // bool reconnect = 7;
  void clear_reconnect() ;
  bool reconnect() const;
  void set_reconnect(bool value);

  private:
  bool _internal_reconnect() const;
  void _internal_set_reconnect(bool value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.TcpdumpArg)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      31, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr fifo_;
    bool defer_;
    bool reconnect_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ResumeWorkerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ResumeWorkerRequest) */ {
 public:
  inline ResumeWorkerRequest() : ResumeWorkerRequest(nullptr) {}
  ~ResumeWorkerRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResumeWorkerRequest(::google::protobuf::internal::ConstantInitialized);

  inline ResumeWorkerRequest(const ResumeWorkerRequest& from)
      : ResumeWorkerRequest(nullptr, from) {}
  ResumeWorkerRequest(ResumeWorkerRequest&& from) noexcept
    : ResumeWorkerRequest() {
    *this = ::std::move(from);
  }

  inline ResumeWorkerRequest& operator=(const ResumeWorkerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResumeWorkerRequest& operator=(ResumeWorkerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResumeWorkerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResumeWorkerRequest* internal_default_instance() {
    return reinterpret_cast<const ResumeWorkerRequest*>(
               &_ResumeWorkerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(ResumeWorkerRequest& a, ResumeWorkerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResumeWorkerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResumeWorkerRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResumeWorkerRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResumeWorkerRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResumeWorkerRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ResumeWorkerRequest& from) {
    ResumeWorkerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ResumeWorkerRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ResumeWorkerRequest";
  }
  protected:
  explicit ResumeWorkerRequest(::google::protobuf::Arena* arena);
  ResumeWorkerRequest(::google::protobuf::Arena* arena, const ResumeWorkerRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidFieldNumber = 1,
  };
  // int64 wid = 1;
  void clear_wid() ;
  ::int64_t wid() const;
  void set_wid(::int64_t value);

  private:
  ::int64_t _internal_wid() const;
  void _internal_set_wid(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ResumeWorkerRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t wid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class PortConf final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.PortConf) */ {
 public:
  inline PortConf() : PortConf(nullptr) {}
  ~PortConf() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PortConf(::google::protobuf::internal::ConstantInitialized);

  inline PortConf(const PortConf& from)
      : PortConf(nullptr, from) {}
  PortConf(PortConf&& from) noexcept
    : PortConf() {
    *this = ::std::move(from);
  }

  inline PortConf& operator=(const PortConf& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortConf& operator=(PortConf&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortConf& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortConf* internal_default_instance() {
    return reinterpret_cast<const PortConf*>(
               &_PortConf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(PortConf& a, PortConf& b) {
    a.Swap(&b);
  }
  inline void Swap(PortConf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortConf* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortConf* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortConf>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PortConf& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PortConf& from) {
    PortConf::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PortConf* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.PortConf";
  }
  protected:
  explicit PortConf(::google::protobuf::Arena* arena);
  PortConf(::google::protobuf::Arena* arena, const PortConf& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacAddrFieldNumber = 1,
    kMtuFieldNumber = 2,
    kAdminUpFieldNumber = 3,
  };
  // string mac_addr = 1;
  void clear_mac_addr() ;
  const std::string& mac_addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mac_addr(Arg_&& arg, Args_... args);
  std::string* mutable_mac_addr();
  PROTOBUF_NODISCARD std::string* release_mac_addr();
  void set_allocated_mac_addr(std::string* value);

  private:
  const std::string& _internal_mac_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_addr(
      const std::string& value);
  std::string* _internal_mutable_mac_addr();

  public:
  // uint32 mtu = 2;
  void clear_mtu() ;
  ::uint32_t mtu() const;
  void set_mtu(::uint32_t value);

  private:
  ::uint32_t _internal_mtu() const;
  void _internal_set_mtu(::uint32_t value);

  public:
  // bool admin_up = 3;
  void clear_admin_up() ;
  bool admin_up() const;
  void set_admin_up(bool value);

  private:
  bool _internal_admin_up() const;
  void _internal_set_admin_up(bool value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.PortConf)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr mac_addr_;
    ::uint32_t mtu_;
    bool admin_up_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class PcapngArg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.PcapngArg) */ {
 public:
  inline PcapngArg() : PcapngArg(nullptr) {}
  ~PcapngArg() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PcapngArg(::google::protobuf::internal::ConstantInitialized);

  inline PcapngArg(const PcapngArg& from)
      : PcapngArg(nullptr, from) {}
  PcapngArg(PcapngArg&& from) noexcept
    : PcapngArg() {
    *this = ::std::move(from);
  }

  inline PcapngArg& operator=(const PcapngArg& from) {
    CopyFrom(from);
    return *this;
  }
  inline PcapngArg& operator=(PcapngArg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PcapngArg& default_instance() {
    return *internal_default_instance();
  }
  static inline const PcapngArg* internal_default_instance() {
    return reinterpret_cast<const PcapngArg*>(
               &_PcapngArg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(PcapngArg& a, PcapngArg& b) {
    a.Swap(&b);
  }
  inline void Swap(PcapngArg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PcapngArg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PcapngArg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PcapngArg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PcapngArg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PcapngArg& from) {
    PcapngArg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PcapngArg* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.PcapngArg";
  }
  protected:
  explicit PcapngArg(::google::protobuf::Arena* arena);
  PcapngArg(::google::protobuf::Arena* arena, const PcapngArg& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFifoFieldNumber = 5,
    kDeferFieldNumber = 6,
    kReconnectFieldNumber = 7,
  };
  // string fifo = 5;
  void clear_fifo() ;
  const std::string& fifo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fifo(Arg_&& arg, Args_... args);
  std::string* mutable_fifo();
  PROTOBUF_NODISCARD std::string* release_fifo();
  void set_allocated_fifo(std::string* value);

  private:
  const std::string& _internal_fifo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fifo(
      const std::string& value);
  std::string* _internal_mutable_fifo();

  public:
  // bool defer = 6;
  void clear_defer() ;
  bool defer() const;
  void set_defer(bool value);

  private:
  bool _internal_defer() const;
  void _internal_set_defer(bool value);

  public:
  // bool reconnect = 7;
  void clear_reconnect() ;
  bool reconnect() const;
  void set_reconnect(bool value);

  private:
  bool _internal_reconnect() const;
  void _internal_set_reconnect(bool value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.PcapngArg)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      30, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr fifo_;
    bool defer_;
    bool reconnect_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class PauseWorkerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.PauseWorkerRequest) */ {
 public:
  inline PauseWorkerRequest() : PauseWorkerRequest(nullptr) {}
  ~PauseWorkerRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PauseWorkerRequest(::google::protobuf::internal::ConstantInitialized);

  inline PauseWorkerRequest(const PauseWorkerRequest& from)
      : PauseWorkerRequest(nullptr, from) {}
  PauseWorkerRequest(PauseWorkerRequest&& from) noexcept
    : PauseWorkerRequest() {
    *this = ::std::move(from);
  }

  inline PauseWorkerRequest& operator=(const PauseWorkerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseWorkerRequest& operator=(PauseWorkerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PauseWorkerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PauseWorkerRequest* internal_default_instance() {
    return reinterpret_cast<const PauseWorkerRequest*>(
               &_PauseWorkerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(PauseWorkerRequest& a, PauseWorkerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseWorkerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseWorkerRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PauseWorkerRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PauseWorkerRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PauseWorkerRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PauseWorkerRequest& from) {
    PauseWorkerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PauseWorkerRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.PauseWorkerRequest";
  }
  protected:
  explicit PauseWorkerRequest(::google::protobuf::Arena* arena);
  PauseWorkerRequest(::google::protobuf::Arena* arena, const PauseWorkerRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidFieldNumber = 1,
  };
  // int64 wid = 1;
  void clear_wid() ;
  ::int64_t wid() const;
  void set_wid(::int64_t value);

  private:
  ::int64_t _internal_wid() const;
  void _internal_set_wid(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.PauseWorkerRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t wid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class MempoolDump final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.MempoolDump) */ {
 public:
  inline MempoolDump() : MempoolDump(nullptr) {}
  ~MempoolDump() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MempoolDump(::google::protobuf::internal::ConstantInitialized);

  inline MempoolDump(const MempoolDump& from)
      : MempoolDump(nullptr, from) {}
  MempoolDump(MempoolDump&& from) noexcept
    : MempoolDump() {
    *this = ::std::move(from);
  }

  inline MempoolDump& operator=(const MempoolDump& from) {
    CopyFrom(from);
    return *this;
  }
  inline MempoolDump& operator=(MempoolDump&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MempoolDump& default_instance() {
    return *internal_default_instance();
  }
  static inline const MempoolDump* internal_default_instance() {
    return reinterpret_cast<const MempoolDump*>(
               &_MempoolDump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(MempoolDump& a, MempoolDump& b) {
    a.Swap(&b);
  }
  inline void Swap(MempoolDump* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MempoolDump* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MempoolDump* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MempoolDump>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MempoolDump& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MempoolDump& from) {
    MempoolDump::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MempoolDump* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.MempoolDump";
  }
  protected:
  explicit MempoolDump(::google::protobuf::Arena* arena);
  MempoolDump(::google::protobuf::Arena* arena, const MempoolDump& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSocketFieldNumber = 1,
    kInitializedFieldNumber = 2,
    kMpSizeFieldNumber = 3,
    kMpCacheSizeFieldNumber = 4,
    kMpElementSizeFieldNumber = 5,
    kMpPopulatedSizeFieldNumber = 6,
    kMpAvailableCountFieldNumber = 7,
    kMpInUseCountFieldNumber = 8,
    kRingCountFieldNumber = 9,
    kRingFreeCountFieldNumber = 10,
    kRingBytesFieldNumber = 11,
  };
  // int32 socket = 1;
  void clear_socket() ;
  ::int32_t socket() const;
  void set_socket(::int32_t value);

  private:
  ::int32_t _internal_socket() const;
  void _internal_set_socket(::int32_t value);

  public:
  // bool initialized = 2;
  void clear_initialized() ;
  bool initialized() const;
  void set_initialized(bool value);

  private:
  bool _internal_initialized() const;
  void _internal_set_initialized(bool value);

  public:
  // uint32 mp_size = 3;
  void clear_mp_size() ;
  ::uint32_t mp_size() const;
  void set_mp_size(::uint32_t value);

  private:
  ::uint32_t _internal_mp_size() const;
  void _internal_set_mp_size(::uint32_t value);

  public:
  // uint32 mp_cache_size = 4;
  void clear_mp_cache_size() ;
  ::uint32_t mp_cache_size() const;
  void set_mp_cache_size(::uint32_t value);

  private:
  ::uint32_t _internal_mp_cache_size() const;
  void _internal_set_mp_cache_size(::uint32_t value);

  public:
  // uint32 mp_element_size = 5;
  void clear_mp_element_size() ;
  ::uint32_t mp_element_size() const;
  void set_mp_element_size(::uint32_t value);

  private:
  ::uint32_t _internal_mp_element_size() const;
  void _internal_set_mp_element_size(::uint32_t value);

  public:
  // uint32 mp_populated_size = 6;
  void clear_mp_populated_size() ;
  ::uint32_t mp_populated_size() const;
  void set_mp_populated_size(::uint32_t value);

  private:
  ::uint32_t _internal_mp_populated_size() const;
  void _internal_set_mp_populated_size(::uint32_t value);

  public:
  // uint32 mp_available_count = 7;
  void clear_mp_available_count() ;
  ::uint32_t mp_available_count() const;
  void set_mp_available_count(::uint32_t value);

  private:
  ::uint32_t _internal_mp_available_count() const;
  void _internal_set_mp_available_count(::uint32_t value);

  public:
  // uint32 mp_in_use_count = 8;
  void clear_mp_in_use_count() ;
  ::uint32_t mp_in_use_count() const;
  void set_mp_in_use_count(::uint32_t value);

  private:
  ::uint32_t _internal_mp_in_use_count() const;
  void _internal_set_mp_in_use_count(::uint32_t value);

  public:
  // uint32 ring_count = 9;
  void clear_ring_count() ;
  ::uint32_t ring_count() const;
  void set_ring_count(::uint32_t value);

  private:
  ::uint32_t _internal_ring_count() const;
  void _internal_set_ring_count(::uint32_t value);

  public:
  // uint32 ring_free_count = 10;
  void clear_ring_free_count() ;
  ::uint32_t ring_free_count() const;
  void set_ring_free_count(::uint32_t value);

  private:
  ::uint32_t _internal_ring_free_count() const;
  void _internal_set_ring_free_count(::uint32_t value);

  public:
  // uint64 ring_bytes = 11;
  void clear_ring_bytes() ;
  ::uint64_t ring_bytes() const;
  void set_ring_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_ring_bytes() const;
  void _internal_set_ring_bytes(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.MempoolDump)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t socket_;
    bool initialized_;
    ::uint32_t mp_size_;
    ::uint32_t mp_cache_size_;
    ::uint32_t mp_element_size_;
    ::uint32_t mp_populated_size_;
    ::uint32_t mp_available_count_;
    ::uint32_t mp_in_use_count_;
    ::uint32_t ring_count_;
    ::uint32_t ring_free_count_;
    ::uint64_t ring_bytes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ListWorkersResponse_WorkerStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ListWorkersResponse.WorkerStatus) */ {
 public:
  inline ListWorkersResponse_WorkerStatus() : ListWorkersResponse_WorkerStatus(nullptr) {}
  ~ListWorkersResponse_WorkerStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListWorkersResponse_WorkerStatus(::google::protobuf::internal::ConstantInitialized);

  inline ListWorkersResponse_WorkerStatus(const ListWorkersResponse_WorkerStatus& from)
      : ListWorkersResponse_WorkerStatus(nullptr, from) {}
  ListWorkersResponse_WorkerStatus(ListWorkersResponse_WorkerStatus&& from) noexcept
    : ListWorkersResponse_WorkerStatus() {
    *this = ::std::move(from);
  }

  inline ListWorkersResponse_WorkerStatus& operator=(const ListWorkersResponse_WorkerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListWorkersResponse_WorkerStatus& operator=(ListWorkersResponse_WorkerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListWorkersResponse_WorkerStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListWorkersResponse_WorkerStatus* internal_default_instance() {
    return reinterpret_cast<const ListWorkersResponse_WorkerStatus*>(
               &_ListWorkersResponse_WorkerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListWorkersResponse_WorkerStatus& a, ListWorkersResponse_WorkerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ListWorkersResponse_WorkerStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListWorkersResponse_WorkerStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListWorkersResponse_WorkerStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListWorkersResponse_WorkerStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListWorkersResponse_WorkerStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListWorkersResponse_WorkerStatus& from) {
    ListWorkersResponse_WorkerStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListWorkersResponse_WorkerStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ListWorkersResponse.WorkerStatus";
  }
  protected:
  explicit ListWorkersResponse_WorkerStatus(::google::protobuf::Arena* arena);
  ListWorkersResponse_WorkerStatus(::google::protobuf::Arena* arena, const ListWorkersResponse_WorkerStatus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidFieldNumber = 1,
    kCoreFieldNumber = 2,
    kNumTcsFieldNumber = 4,
    kSilentDropsFieldNumber = 5,
    kRunningFieldNumber = 3,
  };
  // int64 wid = 1;
  void clear_wid() ;
  ::int64_t wid() const;
  void set_wid(::int64_t value);

  private:
  ::int64_t _internal_wid() const;
  void _internal_set_wid(::int64_t value);

  public:
  // int64 core = 2;
  void clear_core() ;
  ::int64_t core() const;
  void set_core(::int64_t value);

  private:
  ::int64_t _internal_core() const;
  void _internal_set_core(::int64_t value);

  public:
  // int64 num_tcs = 4;
  void clear_num_tcs() ;
  ::int64_t num_tcs() const;
  void set_num_tcs(::int64_t value);

  private:
  ::int64_t _internal_num_tcs() const;
  void _internal_set_num_tcs(::int64_t value);

  public:
  // int64 silent_drops = 5;
  void clear_silent_drops() ;
  ::int64_t silent_drops() const;
  void set_silent_drops(::int64_t value);

  private:
  ::int64_t _internal_silent_drops() const;
  void _internal_set_silent_drops(::int64_t value);

  public:
  // bool running = 3;
  void clear_running() ;
  bool running() const;
  void set_running(bool value);

  private:
  bool _internal_running() const;
  void _internal_set_running(bool value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ListWorkersResponse.WorkerStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t wid_;
    ::int64_t core_;
    ::int64_t num_tcs_;
    ::int64_t silent_drops_;
    bool running_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ListTcsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ListTcsRequest) */ {
 public:
  inline ListTcsRequest() : ListTcsRequest(nullptr) {}
  ~ListTcsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListTcsRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListTcsRequest(const ListTcsRequest& from)
      : ListTcsRequest(nullptr, from) {}
  ListTcsRequest(ListTcsRequest&& from) noexcept
    : ListTcsRequest() {
    *this = ::std::move(from);
  }

  inline ListTcsRequest& operator=(const ListTcsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTcsRequest& operator=(ListTcsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTcsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTcsRequest* internal_default_instance() {
    return reinterpret_cast<const ListTcsRequest*>(
               &_ListTcsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListTcsRequest& a, ListTcsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTcsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTcsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTcsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTcsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListTcsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListTcsRequest& from) {
    ListTcsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListTcsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ListTcsRequest";
  }
  protected:
  explicit ListTcsRequest(::google::protobuf::Arena* arena);
  ListTcsRequest(::google::protobuf::Arena* arena, const ListTcsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidFieldNumber = 1,
  };
  // int64 wid = 1;
  void clear_wid() ;
  ::int64_t wid() const;
  void set_wid(::int64_t value);

  private:
  ::int64_t _internal_wid() const;
  void _internal_set_wid(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ListTcsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t wid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ListModulesResponse_Module final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ListModulesResponse.Module) */ {
 public:
  inline ListModulesResponse_Module() : ListModulesResponse_Module(nullptr) {}
  ~ListModulesResponse_Module() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListModulesResponse_Module(::google::protobuf::internal::ConstantInitialized);

  inline ListModulesResponse_Module(const ListModulesResponse_Module& from)
      : ListModulesResponse_Module(nullptr, from) {}
  ListModulesResponse_Module(ListModulesResponse_Module&& from) noexcept
    : ListModulesResponse_Module() {
    *this = ::std::move(from);
  }

  inline ListModulesResponse_Module& operator=(const ListModulesResponse_Module& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListModulesResponse_Module& operator=(ListModulesResponse_Module&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListModulesResponse_Module& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListModulesResponse_Module* internal_default_instance() {
    return reinterpret_cast<const ListModulesResponse_Module*>(
               &_ListModulesResponse_Module_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ListModulesResponse_Module& a, ListModulesResponse_Module& b) {
    a.Swap(&b);
  }
  inline void Swap(ListModulesResponse_Module* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListModulesResponse_Module* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListModulesResponse_Module* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListModulesResponse_Module>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListModulesResponse_Module& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListModulesResponse_Module& from) {
    ListModulesResponse_Module::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListModulesResponse_Module* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ListModulesResponse.Module";
  }
  protected:
  explicit ListModulesResponse_Module(::google::protobuf::Arena* arena);
  ListModulesResponse_Module(::google::protobuf::Arena* arena, const ListModulesResponse_Module& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kMclassFieldNumber = 2,
    kDescFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string mclass = 2;
  void clear_mclass() ;
  const std::string& mclass() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mclass(Arg_&& arg, Args_... args);
  std::string* mutable_mclass();
  PROTOBUF_NODISCARD std::string* release_mclass();
  void set_allocated_mclass(std::string* value);

  private:
  const std::string& _internal_mclass() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mclass(
      const std::string& value);
  std::string* _internal_mutable_mclass();

  public:
  // string desc = 3;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ListModulesResponse.Module)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr mclass_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ImportPluginRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ImportPluginRequest) */ {
 public:
  inline ImportPluginRequest() : ImportPluginRequest(nullptr) {}
  ~ImportPluginRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ImportPluginRequest(::google::protobuf::internal::ConstantInitialized);

  inline ImportPluginRequest(const ImportPluginRequest& from)
      : ImportPluginRequest(nullptr, from) {}
  ImportPluginRequest(ImportPluginRequest&& from) noexcept
    : ImportPluginRequest() {
    *this = ::std::move(from);
  }

  inline ImportPluginRequest& operator=(const ImportPluginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImportPluginRequest& operator=(ImportPluginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImportPluginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImportPluginRequest* internal_default_instance() {
    return reinterpret_cast<const ImportPluginRequest*>(
               &_ImportPluginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ImportPluginRequest& a, ImportPluginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ImportPluginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImportPluginRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImportPluginRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImportPluginRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ImportPluginRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ImportPluginRequest& from) {
    ImportPluginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ImportPluginRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ImportPluginRequest";
  }
  protected:
  explicit ImportPluginRequest(::google::protobuf::Arena* arena);
  ImportPluginRequest(::google::protobuf::Arena* arena, const ImportPluginRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ImportPluginRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr path_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetTcStatsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetTcStatsRequest) */ {
 public:
  inline GetTcStatsRequest() : GetTcStatsRequest(nullptr) {}
  ~GetTcStatsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetTcStatsRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetTcStatsRequest(const GetTcStatsRequest& from)
      : GetTcStatsRequest(nullptr, from) {}
  GetTcStatsRequest(GetTcStatsRequest&& from) noexcept
    : GetTcStatsRequest() {
    *this = ::std::move(from);
  }

  inline GetTcStatsRequest& operator=(const GetTcStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTcStatsRequest& operator=(GetTcStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTcStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTcStatsRequest* internal_default_instance() {
    return reinterpret_cast<const GetTcStatsRequest*>(
               &_GetTcStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetTcStatsRequest& a, GetTcStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTcStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTcStatsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTcStatsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTcStatsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTcStatsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetTcStatsRequest& from) {
    GetTcStatsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetTcStatsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetTcStatsRequest";
  }
  protected:
  explicit GetTcStatsRequest(::google::protobuf::Arena* arena);
  GetTcStatsRequest(::google::protobuf::Arena* arena, const GetTcStatsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetTcStatsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetPortStatsResponse_Stat final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetPortStatsResponse.Stat) */ {
 public:
  inline GetPortStatsResponse_Stat() : GetPortStatsResponse_Stat(nullptr) {}
  ~GetPortStatsResponse_Stat() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPortStatsResponse_Stat(::google::protobuf::internal::ConstantInitialized);

  inline GetPortStatsResponse_Stat(const GetPortStatsResponse_Stat& from)
      : GetPortStatsResponse_Stat(nullptr, from) {}
  GetPortStatsResponse_Stat(GetPortStatsResponse_Stat&& from) noexcept
    : GetPortStatsResponse_Stat() {
    *this = ::std::move(from);
  }

  inline GetPortStatsResponse_Stat& operator=(const GetPortStatsResponse_Stat& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPortStatsResponse_Stat& operator=(GetPortStatsResponse_Stat&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPortStatsResponse_Stat& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPortStatsResponse_Stat* internal_default_instance() {
    return reinterpret_cast<const GetPortStatsResponse_Stat*>(
               &_GetPortStatsResponse_Stat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GetPortStatsResponse_Stat& a, GetPortStatsResponse_Stat& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPortStatsResponse_Stat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPortStatsResponse_Stat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPortStatsResponse_Stat* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPortStatsResponse_Stat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPortStatsResponse_Stat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPortStatsResponse_Stat& from) {
    GetPortStatsResponse_Stat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPortStatsResponse_Stat* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetPortStatsResponse.Stat";
  }
  protected:
  explicit GetPortStatsResponse_Stat(::google::protobuf::Arena* arena);
  GetPortStatsResponse_Stat(::google::protobuf::Arena* arena, const GetPortStatsResponse_Stat& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestedHistFieldNumber = 4,
    kActualHistFieldNumber = 5,
    kDiffHistFieldNumber = 6,
    kPacketsFieldNumber = 1,
    kDroppedFieldNumber = 2,
    kBytesFieldNumber = 3,
  };
  // repeated uint64 requested_hist = 4;
  int requested_hist_size() const;
  private:
  int _internal_requested_hist_size() const;

  public:
  void clear_requested_hist() ;
  ::uint64_t requested_hist(int index) const;
  void set_requested_hist(int index, ::uint64_t value);
  void add_requested_hist(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& requested_hist() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_requested_hist();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_requested_hist() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_requested_hist();

  public:
  // repeated uint64 actual_hist = 5;
  int actual_hist_size() const;
  private:
  int _internal_actual_hist_size() const;

  public:
  void clear_actual_hist() ;
  ::uint64_t actual_hist(int index) const;
  void set_actual_hist(int index, ::uint64_t value);
  void add_actual_hist(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& actual_hist() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_actual_hist();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_actual_hist() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_actual_hist();

  public:
  // repeated uint64 diff_hist = 6;
  int diff_hist_size() const;
  private:
  int _internal_diff_hist_size() const;

  public:
  void clear_diff_hist() ;
  ::uint64_t diff_hist(int index) const;
  void set_diff_hist(int index, ::uint64_t value);
  void add_diff_hist(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& diff_hist() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_diff_hist();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_diff_hist() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_diff_hist();

  public:
  // uint64 packets = 1;
  void clear_packets() ;
  ::uint64_t packets() const;
  void set_packets(::uint64_t value);

  private:
  ::uint64_t _internal_packets() const;
  void _internal_set_packets(::uint64_t value);

  public:
  // uint64 dropped = 2;
  void clear_dropped() ;
  ::uint64_t dropped() const;
  void set_dropped(::uint64_t value);

  private:
  ::uint64_t _internal_dropped() const;
  void _internal_set_dropped(::uint64_t value);

  public:
  // uint64 bytes = 3;
  void clear_bytes() ;
  ::uint64_t bytes() const;
  void set_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_bytes() const;
  void _internal_set_bytes(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetPortStatsResponse.Stat)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::uint64_t> requested_hist_;
    mutable ::google::protobuf::internal::CachedSize _requested_hist_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint64_t> actual_hist_;
    mutable ::google::protobuf::internal::CachedSize _actual_hist_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint64_t> diff_hist_;
    mutable ::google::protobuf::internal::CachedSize _diff_hist_cached_byte_size_;
    ::uint64_t packets_;
    ::uint64_t dropped_;
    ::uint64_t bytes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetPortStatsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetPortStatsRequest) */ {
 public:
  inline GetPortStatsRequest() : GetPortStatsRequest(nullptr) {}
  ~GetPortStatsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPortStatsRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetPortStatsRequest(const GetPortStatsRequest& from)
      : GetPortStatsRequest(nullptr, from) {}
  GetPortStatsRequest(GetPortStatsRequest&& from) noexcept
    : GetPortStatsRequest() {
    *this = ::std::move(from);
  }

  inline GetPortStatsRequest& operator=(const GetPortStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPortStatsRequest& operator=(GetPortStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPortStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPortStatsRequest* internal_default_instance() {
    return reinterpret_cast<const GetPortStatsRequest*>(
               &_GetPortStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetPortStatsRequest& a, GetPortStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPortStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPortStatsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPortStatsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPortStatsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPortStatsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPortStatsRequest& from) {
    GetPortStatsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPortStatsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetPortStatsRequest";
  }
  protected:
  explicit GetPortStatsRequest(::google::protobuf::Arena* arena);
  GetPortStatsRequest(::google::protobuf::Arena* arena, const GetPortStatsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetPortStatsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetPortConfRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetPortConfRequest) */ {
 public:
  inline GetPortConfRequest() : GetPortConfRequest(nullptr) {}
  ~GetPortConfRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPortConfRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetPortConfRequest(const GetPortConfRequest& from)
      : GetPortConfRequest(nullptr, from) {}
  GetPortConfRequest(GetPortConfRequest&& from) noexcept
    : GetPortConfRequest() {
    *this = ::std::move(from);
  }

  inline GetPortConfRequest& operator=(const GetPortConfRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPortConfRequest& operator=(GetPortConfRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPortConfRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPortConfRequest* internal_default_instance() {
    return reinterpret_cast<const GetPortConfRequest*>(
               &_GetPortConfRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GetPortConfRequest& a, GetPortConfRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPortConfRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPortConfRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPortConfRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPortConfRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPortConfRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPortConfRequest& from) {
    GetPortConfRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPortConfRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetPortConfRequest";
  }
  protected:
  explicit GetPortConfRequest(::google::protobuf::Arena* arena);
  GetPortConfRequest(::google::protobuf::Arena* arena, const GetPortConfRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetPortConfRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetModuleInfoResponse_IGate_OGate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetModuleInfoResponse.IGate.OGate) */ {
 public:
  inline GetModuleInfoResponse_IGate_OGate() : GetModuleInfoResponse_IGate_OGate(nullptr) {}
  ~GetModuleInfoResponse_IGate_OGate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetModuleInfoResponse_IGate_OGate(::google::protobuf::internal::ConstantInitialized);

  inline GetModuleInfoResponse_IGate_OGate(const GetModuleInfoResponse_IGate_OGate& from)
      : GetModuleInfoResponse_IGate_OGate(nullptr, from) {}
  GetModuleInfoResponse_IGate_OGate(GetModuleInfoResponse_IGate_OGate&& from) noexcept
    : GetModuleInfoResponse_IGate_OGate() {
    *this = ::std::move(from);
  }

  inline GetModuleInfoResponse_IGate_OGate& operator=(const GetModuleInfoResponse_IGate_OGate& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModuleInfoResponse_IGate_OGate& operator=(GetModuleInfoResponse_IGate_OGate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModuleInfoResponse_IGate_OGate& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModuleInfoResponse_IGate_OGate* internal_default_instance() {
    return reinterpret_cast<const GetModuleInfoResponse_IGate_OGate*>(
               &_GetModuleInfoResponse_IGate_OGate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(GetModuleInfoResponse_IGate_OGate& a, GetModuleInfoResponse_IGate_OGate& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModuleInfoResponse_IGate_OGate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModuleInfoResponse_IGate_OGate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModuleInfoResponse_IGate_OGate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModuleInfoResponse_IGate_OGate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetModuleInfoResponse_IGate_OGate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetModuleInfoResponse_IGate_OGate& from) {
    GetModuleInfoResponse_IGate_OGate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetModuleInfoResponse_IGate_OGate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetModuleInfoResponse.IGate.OGate";
  }
  protected:
  explicit GetModuleInfoResponse_IGate_OGate(::google::protobuf::Arena* arena);
  GetModuleInfoResponse_IGate_OGate(::google::protobuf::Arena* arena, const GetModuleInfoResponse_IGate_OGate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kOgateFieldNumber = 1,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // uint64 ogate = 1;
  void clear_ogate() ;
  ::uint64_t ogate() const;
  void set_ogate(::uint64_t value);

  private:
  ::uint64_t _internal_ogate() const;
  void _internal_set_ogate(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetModuleInfoResponse.IGate.OGate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint64_t ogate_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetModuleInfoResponse_GateHook final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetModuleInfoResponse.GateHook) */ {
 public:
  inline GetModuleInfoResponse_GateHook() : GetModuleInfoResponse_GateHook(nullptr) {}
  ~GetModuleInfoResponse_GateHook() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetModuleInfoResponse_GateHook(::google::protobuf::internal::ConstantInitialized);

  inline GetModuleInfoResponse_GateHook(const GetModuleInfoResponse_GateHook& from)
      : GetModuleInfoResponse_GateHook(nullptr, from) {}
  GetModuleInfoResponse_GateHook(GetModuleInfoResponse_GateHook&& from) noexcept
    : GetModuleInfoResponse_GateHook() {
    *this = ::std::move(from);
  }

  inline GetModuleInfoResponse_GateHook& operator=(const GetModuleInfoResponse_GateHook& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModuleInfoResponse_GateHook& operator=(GetModuleInfoResponse_GateHook&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModuleInfoResponse_GateHook& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModuleInfoResponse_GateHook* internal_default_instance() {
    return reinterpret_cast<const GetModuleInfoResponse_GateHook*>(
               &_GetModuleInfoResponse_GateHook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(GetModuleInfoResponse_GateHook& a, GetModuleInfoResponse_GateHook& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModuleInfoResponse_GateHook* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModuleInfoResponse_GateHook* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModuleInfoResponse_GateHook* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModuleInfoResponse_GateHook>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetModuleInfoResponse_GateHook& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetModuleInfoResponse_GateHook& from) {
    GetModuleInfoResponse_GateHook::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetModuleInfoResponse_GateHook* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetModuleInfoResponse.GateHook";
  }
  protected:
  explicit GetModuleInfoResponse_GateHook(::google::protobuf::Arena* arena);
  GetModuleInfoResponse_GateHook(::google::protobuf::Arena* arena, const GetModuleInfoResponse_GateHook& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassNameFieldNumber = 1,
    kHookNameFieldNumber = 2,
  };
  // string class_name = 1;
  void clear_class_name() ;
  const std::string& class_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_class_name(Arg_&& arg, Args_... args);
  std::string* mutable_class_name();
  PROTOBUF_NODISCARD std::string* release_class_name();
  void set_allocated_class_name(std::string* value);

  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(
      const std::string& value);
  std::string* _internal_mutable_class_name();

  public:
  // string hook_name = 2;
  void clear_hook_name() ;
  const std::string& hook_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hook_name(Arg_&& arg, Args_... args);
  std::string* mutable_hook_name();
  PROTOBUF_NODISCARD std::string* release_hook_name();
  void set_allocated_hook_name(std::string* value);

  private:
  const std::string& _internal_hook_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hook_name(
      const std::string& value);
  std::string* _internal_mutable_hook_name();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetModuleInfoResponse.GateHook)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr class_name_;
    ::google::protobuf::internal::ArenaStringPtr hook_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetModuleInfoResponse_Attribute final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetModuleInfoResponse.Attribute) */ {
 public:
  inline GetModuleInfoResponse_Attribute() : GetModuleInfoResponse_Attribute(nullptr) {}
  ~GetModuleInfoResponse_Attribute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetModuleInfoResponse_Attribute(::google::protobuf::internal::ConstantInitialized);

  inline GetModuleInfoResponse_Attribute(const GetModuleInfoResponse_Attribute& from)
      : GetModuleInfoResponse_Attribute(nullptr, from) {}
  GetModuleInfoResponse_Attribute(GetModuleInfoResponse_Attribute&& from) noexcept
    : GetModuleInfoResponse_Attribute() {
    *this = ::std::move(from);
  }

  inline GetModuleInfoResponse_Attribute& operator=(const GetModuleInfoResponse_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModuleInfoResponse_Attribute& operator=(GetModuleInfoResponse_Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModuleInfoResponse_Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModuleInfoResponse_Attribute* internal_default_instance() {
    return reinterpret_cast<const GetModuleInfoResponse_Attribute*>(
               &_GetModuleInfoResponse_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(GetModuleInfoResponse_Attribute& a, GetModuleInfoResponse_Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModuleInfoResponse_Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModuleInfoResponse_Attribute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModuleInfoResponse_Attribute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModuleInfoResponse_Attribute>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetModuleInfoResponse_Attribute& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetModuleInfoResponse_Attribute& from) {
    GetModuleInfoResponse_Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetModuleInfoResponse_Attribute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetModuleInfoResponse.Attribute";
  }
  protected:
  explicit GetModuleInfoResponse_Attribute(::google::protobuf::Arena* arena);
  GetModuleInfoResponse_Attribute(::google::protobuf::Arena* arena, const GetModuleInfoResponse_Attribute& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kModeFieldNumber = 3,
    kSizeFieldNumber = 2,
    kOffsetFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string mode = 3;
  void clear_mode() ;
  const std::string& mode() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mode(Arg_&& arg, Args_... args);
  std::string* mutable_mode();
  PROTOBUF_NODISCARD std::string* release_mode();
  void set_allocated_mode(std::string* value);

  private:
  const std::string& _internal_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mode(
      const std::string& value);
  std::string* _internal_mutable_mode();

  public:
  // uint64 size = 2;
  void clear_size() ;
  ::uint64_t size() const;
  void set_size(::uint64_t value);

  private:
  ::uint64_t _internal_size() const;
  void _internal_set_size(::uint64_t value);

  public:
  // int64 offset = 4;
  void clear_offset() ;
  ::int64_t offset() const;
  void set_offset(::int64_t value);

  private:
  ::int64_t _internal_offset() const;
  void _internal_set_offset(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetModuleInfoResponse.Attribute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr mode_;
    ::uint64_t size_;
    ::int64_t offset_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetModuleInfoRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetModuleInfoRequest) */ {
 public:
  inline GetModuleInfoRequest() : GetModuleInfoRequest(nullptr) {}
  ~GetModuleInfoRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetModuleInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetModuleInfoRequest(const GetModuleInfoRequest& from)
      : GetModuleInfoRequest(nullptr, from) {}
  GetModuleInfoRequest(GetModuleInfoRequest&& from) noexcept
    : GetModuleInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetModuleInfoRequest& operator=(const GetModuleInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModuleInfoRequest& operator=(GetModuleInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModuleInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModuleInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetModuleInfoRequest*>(
               &_GetModuleInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(GetModuleInfoRequest& a, GetModuleInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModuleInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModuleInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModuleInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModuleInfoRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetModuleInfoRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetModuleInfoRequest& from) {
    GetModuleInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetModuleInfoRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetModuleInfoRequest";
  }
  protected:
  explicit GetModuleInfoRequest(::google::protobuf::Arena* arena);
  GetModuleInfoRequest(::google::protobuf::Arena* arena, const GetModuleInfoRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetModuleInfoRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetMclassInfoRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetMclassInfoRequest) */ {
 public:
  inline GetMclassInfoRequest() : GetMclassInfoRequest(nullptr) {}
  ~GetMclassInfoRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetMclassInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetMclassInfoRequest(const GetMclassInfoRequest& from)
      : GetMclassInfoRequest(nullptr, from) {}
  GetMclassInfoRequest(GetMclassInfoRequest&& from) noexcept
    : GetMclassInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetMclassInfoRequest& operator=(const GetMclassInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMclassInfoRequest& operator=(GetMclassInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMclassInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMclassInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetMclassInfoRequest*>(
               &_GetMclassInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(GetMclassInfoRequest& a, GetMclassInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMclassInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMclassInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMclassInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMclassInfoRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetMclassInfoRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetMclassInfoRequest& from) {
    GetMclassInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetMclassInfoRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetMclassInfoRequest";
  }
  protected:
  explicit GetMclassInfoRequest(::google::protobuf::Arena* arena);
  GetMclassInfoRequest(::google::protobuf::Arena* arena, const GetMclassInfoRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetMclassInfoRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetLinkStatusRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetLinkStatusRequest) */ {
 public:
  inline GetLinkStatusRequest() : GetLinkStatusRequest(nullptr) {}
  ~GetLinkStatusRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetLinkStatusRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetLinkStatusRequest(const GetLinkStatusRequest& from)
      : GetLinkStatusRequest(nullptr, from) {}
  GetLinkStatusRequest(GetLinkStatusRequest&& from) noexcept
    : GetLinkStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetLinkStatusRequest& operator=(const GetLinkStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLinkStatusRequest& operator=(GetLinkStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLinkStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLinkStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetLinkStatusRequest*>(
               &_GetLinkStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(GetLinkStatusRequest& a, GetLinkStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLinkStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLinkStatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLinkStatusRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLinkStatusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetLinkStatusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetLinkStatusRequest& from) {
    GetLinkStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetLinkStatusRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetLinkStatusRequest";
  }
  protected:
  explicit GetLinkStatusRequest(::google::protobuf::Arena* arena);
  GetLinkStatusRequest(::google::protobuf::Arena* arena, const GetLinkStatusRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetLinkStatusRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetGateHookClassInfoRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetGateHookClassInfoRequest) */ {
 public:
  inline GetGateHookClassInfoRequest() : GetGateHookClassInfoRequest(nullptr) {}
  ~GetGateHookClassInfoRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetGateHookClassInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetGateHookClassInfoRequest(const GetGateHookClassInfoRequest& from)
      : GetGateHookClassInfoRequest(nullptr, from) {}
  GetGateHookClassInfoRequest(GetGateHookClassInfoRequest&& from) noexcept
    : GetGateHookClassInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetGateHookClassInfoRequest& operator=(const GetGateHookClassInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetGateHookClassInfoRequest& operator=(GetGateHookClassInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetGateHookClassInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetGateHookClassInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetGateHookClassInfoRequest*>(
               &_GetGateHookClassInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(GetGateHookClassInfoRequest& a, GetGateHookClassInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetGateHookClassInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetGateHookClassInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetGateHookClassInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetGateHookClassInfoRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetGateHookClassInfoRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetGateHookClassInfoRequest& from) {
    GetGateHookClassInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetGateHookClassInfoRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetGateHookClassInfoRequest";
  }
  protected:
  explicit GetGateHookClassInfoRequest(::google::protobuf::Arena* arena);
  GetGateHookClassInfoRequest(::google::protobuf::Arena* arena, const GetGateHookClassInfoRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetGateHookClassInfoRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetDriverInfoRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetDriverInfoRequest) */ {
 public:
  inline GetDriverInfoRequest() : GetDriverInfoRequest(nullptr) {}
  ~GetDriverInfoRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetDriverInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetDriverInfoRequest(const GetDriverInfoRequest& from)
      : GetDriverInfoRequest(nullptr, from) {}
  GetDriverInfoRequest(GetDriverInfoRequest&& from) noexcept
    : GetDriverInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetDriverInfoRequest& operator=(const GetDriverInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDriverInfoRequest& operator=(GetDriverInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDriverInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDriverInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetDriverInfoRequest*>(
               &_GetDriverInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetDriverInfoRequest& a, GetDriverInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDriverInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDriverInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDriverInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDriverInfoRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetDriverInfoRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetDriverInfoRequest& from) {
    GetDriverInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetDriverInfoRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetDriverInfoRequest";
  }
  protected:
  explicit GetDriverInfoRequest(::google::protobuf::Arena* arena);
  GetDriverInfoRequest(::google::protobuf::Arena* arena, const GetDriverInfoRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDriverNameFieldNumber = 1,
  };
  // string driver_name = 1;
  void clear_driver_name() ;
  const std::string& driver_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_driver_name(Arg_&& arg, Args_... args);
  std::string* mutable_driver_name();
  PROTOBUF_NODISCARD std::string* release_driver_name();
  void set_allocated_driver_name(std::string* value);

  private:
  const std::string& _internal_driver_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_name(
      const std::string& value);
  std::string* _internal_mutable_driver_name();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetDriverInfoRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr driver_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class EmptyRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bess.pb.EmptyRequest) */ {
 public:
  inline EmptyRequest() : EmptyRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EmptyRequest(::google::protobuf::internal::ConstantInitialized);

  inline EmptyRequest(const EmptyRequest& from)
      : EmptyRequest(nullptr, from) {}
  EmptyRequest(EmptyRequest&& from) noexcept
    : EmptyRequest() {
    *this = ::std::move(from);
  }

  inline EmptyRequest& operator=(const EmptyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyRequest& operator=(EmptyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyRequest* internal_default_instance() {
    return reinterpret_cast<const EmptyRequest*>(
               &_EmptyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EmptyRequest& a, EmptyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmptyRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmptyRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.EmptyRequest";
  }
  protected:
  explicit EmptyRequest(::google::protobuf::Arena* arena);
  EmptyRequest(::google::protobuf::Arena* arena, const EmptyRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bess.pb.EmptyRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class DumpMempoolRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.DumpMempoolRequest) */ {
 public:
  inline DumpMempoolRequest() : DumpMempoolRequest(nullptr) {}
  ~DumpMempoolRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DumpMempoolRequest(::google::protobuf::internal::ConstantInitialized);

  inline DumpMempoolRequest(const DumpMempoolRequest& from)
      : DumpMempoolRequest(nullptr, from) {}
  DumpMempoolRequest(DumpMempoolRequest&& from) noexcept
    : DumpMempoolRequest() {
    *this = ::std::move(from);
  }

  inline DumpMempoolRequest& operator=(const DumpMempoolRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DumpMempoolRequest& operator=(DumpMempoolRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DumpMempoolRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DumpMempoolRequest* internal_default_instance() {
    return reinterpret_cast<const DumpMempoolRequest*>(
               &_DumpMempoolRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(DumpMempoolRequest& a, DumpMempoolRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DumpMempoolRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DumpMempoolRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DumpMempoolRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DumpMempoolRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DumpMempoolRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DumpMempoolRequest& from) {
    DumpMempoolRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DumpMempoolRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.DumpMempoolRequest";
  }
  protected:
  explicit DumpMempoolRequest(::google::protobuf::Arena* arena);
  DumpMempoolRequest(::google::protobuf::Arena* arena, const DumpMempoolRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSocketFieldNumber = 1,
  };
  // int32 socket = 1;
  void clear_socket() ;
  ::int32_t socket() const;
  void set_socket(::int32_t value);

  private:
  ::int32_t _internal_socket() const;
  void _internal_set_socket(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.DumpMempoolRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t socket_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class DisconnectModulesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.DisconnectModulesRequest) */ {
 public:
  inline DisconnectModulesRequest() : DisconnectModulesRequest(nullptr) {}
  ~DisconnectModulesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DisconnectModulesRequest(::google::protobuf::internal::ConstantInitialized);

  inline DisconnectModulesRequest(const DisconnectModulesRequest& from)
      : DisconnectModulesRequest(nullptr, from) {}
  DisconnectModulesRequest(DisconnectModulesRequest&& from) noexcept
    : DisconnectModulesRequest() {
    *this = ::std::move(from);
  }

  inline DisconnectModulesRequest& operator=(const DisconnectModulesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisconnectModulesRequest& operator=(DisconnectModulesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisconnectModulesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisconnectModulesRequest* internal_default_instance() {
    return reinterpret_cast<const DisconnectModulesRequest*>(
               &_DisconnectModulesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(DisconnectModulesRequest& a, DisconnectModulesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DisconnectModulesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisconnectModulesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisconnectModulesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisconnectModulesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DisconnectModulesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DisconnectModulesRequest& from) {
    DisconnectModulesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DisconnectModulesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.DisconnectModulesRequest";
  }
  protected:
  explicit DisconnectModulesRequest(::google::protobuf::Arena* arena);
  DisconnectModulesRequest(::google::protobuf::Arena* arena, const DisconnectModulesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kOgateFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // uint64 ogate = 2;
  void clear_ogate() ;
  ::uint64_t ogate() const;
  void set_ogate(::uint64_t value);

  private:
  ::uint64_t _internal_ogate() const;
  void _internal_set_ogate(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.DisconnectModulesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint64_t ogate_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class DestroyWorkerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.DestroyWorkerRequest) */ {
 public:
  inline DestroyWorkerRequest() : DestroyWorkerRequest(nullptr) {}
  ~DestroyWorkerRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DestroyWorkerRequest(::google::protobuf::internal::ConstantInitialized);

  inline DestroyWorkerRequest(const DestroyWorkerRequest& from)
      : DestroyWorkerRequest(nullptr, from) {}
  DestroyWorkerRequest(DestroyWorkerRequest&& from) noexcept
    : DestroyWorkerRequest() {
    *this = ::std::move(from);
  }

  inline DestroyWorkerRequest& operator=(const DestroyWorkerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestroyWorkerRequest& operator=(DestroyWorkerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestroyWorkerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestroyWorkerRequest* internal_default_instance() {
    return reinterpret_cast<const DestroyWorkerRequest*>(
               &_DestroyWorkerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DestroyWorkerRequest& a, DestroyWorkerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DestroyWorkerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestroyWorkerRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestroyWorkerRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestroyWorkerRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DestroyWorkerRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DestroyWorkerRequest& from) {
    DestroyWorkerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DestroyWorkerRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.DestroyWorkerRequest";
  }
  protected:
  explicit DestroyWorkerRequest(::google::protobuf::Arena* arena);
  DestroyWorkerRequest(::google::protobuf::Arena* arena, const DestroyWorkerRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidFieldNumber = 1,
  };
  // int64 wid = 1;
  void clear_wid() ;
  ::int64_t wid() const;
  void set_wid(::int64_t value);

  private:
  ::int64_t _internal_wid() const;
  void _internal_set_wid(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.DestroyWorkerRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t wid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class DestroyPortRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.DestroyPortRequest) */ {
 public:
  inline DestroyPortRequest() : DestroyPortRequest(nullptr) {}
  ~DestroyPortRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DestroyPortRequest(::google::protobuf::internal::ConstantInitialized);

  inline DestroyPortRequest(const DestroyPortRequest& from)
      : DestroyPortRequest(nullptr, from) {}
  DestroyPortRequest(DestroyPortRequest&& from) noexcept
    : DestroyPortRequest() {
    *this = ::std::move(from);
  }

  inline DestroyPortRequest& operator=(const DestroyPortRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestroyPortRequest& operator=(DestroyPortRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestroyPortRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestroyPortRequest* internal_default_instance() {
    return reinterpret_cast<const DestroyPortRequest*>(
               &_DestroyPortRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(DestroyPortRequest& a, DestroyPortRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DestroyPortRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestroyPortRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestroyPortRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestroyPortRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DestroyPortRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DestroyPortRequest& from) {
    DestroyPortRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DestroyPortRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.DestroyPortRequest";
  }
  protected:
  explicit DestroyPortRequest(::google::protobuf::Arena* arena);
  DestroyPortRequest(::google::protobuf::Arena* arena, const DestroyPortRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.DestroyPortRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class DestroyModuleRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.DestroyModuleRequest) */ {
 public:
  inline DestroyModuleRequest() : DestroyModuleRequest(nullptr) {}
  ~DestroyModuleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DestroyModuleRequest(::google::protobuf::internal::ConstantInitialized);

  inline DestroyModuleRequest(const DestroyModuleRequest& from)
      : DestroyModuleRequest(nullptr, from) {}
  DestroyModuleRequest(DestroyModuleRequest&& from) noexcept
    : DestroyModuleRequest() {
    *this = ::std::move(from);
  }

  inline DestroyModuleRequest& operator=(const DestroyModuleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestroyModuleRequest& operator=(DestroyModuleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestroyModuleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestroyModuleRequest* internal_default_instance() {
    return reinterpret_cast<const DestroyModuleRequest*>(
               &_DestroyModuleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(DestroyModuleRequest& a, DestroyModuleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DestroyModuleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestroyModuleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestroyModuleRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestroyModuleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DestroyModuleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DestroyModuleRequest& from) {
    DestroyModuleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DestroyModuleRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.DestroyModuleRequest";
  }
  protected:
  explicit DestroyModuleRequest(::google::protobuf::Arena* arena);
  DestroyModuleRequest(::google::protobuf::Arena* arena, const DestroyModuleRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.DestroyModuleRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ConnectModulesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ConnectModulesRequest) */ {
 public:
  inline ConnectModulesRequest() : ConnectModulesRequest(nullptr) {}
  ~ConnectModulesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectModulesRequest(::google::protobuf::internal::ConstantInitialized);

  inline ConnectModulesRequest(const ConnectModulesRequest& from)
      : ConnectModulesRequest(nullptr, from) {}
  ConnectModulesRequest(ConnectModulesRequest&& from) noexcept
    : ConnectModulesRequest() {
    *this = ::std::move(from);
  }

  inline ConnectModulesRequest& operator=(const ConnectModulesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectModulesRequest& operator=(ConnectModulesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectModulesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectModulesRequest* internal_default_instance() {
    return reinterpret_cast<const ConnectModulesRequest*>(
               &_ConnectModulesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(ConnectModulesRequest& a, ConnectModulesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectModulesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectModulesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectModulesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectModulesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConnectModulesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ConnectModulesRequest& from) {
    ConnectModulesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConnectModulesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ConnectModulesRequest";
  }
  protected:
  explicit ConnectModulesRequest(::google::protobuf::Arena* arena);
  ConnectModulesRequest(::google::protobuf::Arena* arena, const ConnectModulesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kM1FieldNumber = 1,
    kM2FieldNumber = 2,
    kOgateFieldNumber = 3,
    kIgateFieldNumber = 4,
    kSkipDefaultHooksFieldNumber = 5,
  };
  // string m1 = 1;
  void clear_m1() ;
  const std::string& m1() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_m1(Arg_&& arg, Args_... args);
  std::string* mutable_m1();
  PROTOBUF_NODISCARD std::string* release_m1();
  void set_allocated_m1(std::string* value);

  private:
  const std::string& _internal_m1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m1(
      const std::string& value);
  std::string* _internal_mutable_m1();

  public:
  // string m2 = 2;
  void clear_m2() ;
  const std::string& m2() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_m2(Arg_&& arg, Args_... args);
  std::string* mutable_m2();
  PROTOBUF_NODISCARD std::string* release_m2();
  void set_allocated_m2(std::string* value);

  private:
  const std::string& _internal_m2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m2(
      const std::string& value);
  std::string* _internal_mutable_m2();

  public:
  // uint64 ogate = 3;
  void clear_ogate() ;
  ::uint64_t ogate() const;
  void set_ogate(::uint64_t value);

  private:
  ::uint64_t _internal_ogate() const;
  void _internal_set_ogate(::uint64_t value);

  public:
  // uint64 igate = 4;
  void clear_igate() ;
  ::uint64_t igate() const;
  void set_igate(::uint64_t value);

  private:
  ::uint64_t _internal_igate() const;
  void _internal_set_igate(::uint64_t value);

  public:
  // bool skip_default_hooks = 5;
  void clear_skip_default_hooks() ;
  bool skip_default_hooks() const;
  void set_skip_default_hooks(bool value);

  private:
  bool _internal_skip_default_hooks() const;
  void _internal_set_skip_default_hooks(bool value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ConnectModulesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr m1_;
    ::google::protobuf::internal::ArenaStringPtr m2_;
    ::uint64_t ogate_;
    ::uint64_t igate_;
    bool skip_default_hooks_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class CheckSchedulingConstraintsResponse_ViolatingModule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.CheckSchedulingConstraintsResponse.ViolatingModule) */ {
 public:
  inline CheckSchedulingConstraintsResponse_ViolatingModule() : CheckSchedulingConstraintsResponse_ViolatingModule(nullptr) {}
  ~CheckSchedulingConstraintsResponse_ViolatingModule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CheckSchedulingConstraintsResponse_ViolatingModule(::google::protobuf::internal::ConstantInitialized);

  inline CheckSchedulingConstraintsResponse_ViolatingModule(const CheckSchedulingConstraintsResponse_ViolatingModule& from)
      : CheckSchedulingConstraintsResponse_ViolatingModule(nullptr, from) {}
  CheckSchedulingConstraintsResponse_ViolatingModule(CheckSchedulingConstraintsResponse_ViolatingModule&& from) noexcept
    : CheckSchedulingConstraintsResponse_ViolatingModule() {
    *this = ::std::move(from);
  }

  inline CheckSchedulingConstraintsResponse_ViolatingModule& operator=(const CheckSchedulingConstraintsResponse_ViolatingModule& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckSchedulingConstraintsResponse_ViolatingModule& operator=(CheckSchedulingConstraintsResponse_ViolatingModule&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckSchedulingConstraintsResponse_ViolatingModule& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckSchedulingConstraintsResponse_ViolatingModule* internal_default_instance() {
    return reinterpret_cast<const CheckSchedulingConstraintsResponse_ViolatingModule*>(
               &_CheckSchedulingConstraintsResponse_ViolatingModule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CheckSchedulingConstraintsResponse_ViolatingModule& a, CheckSchedulingConstraintsResponse_ViolatingModule& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckSchedulingConstraintsResponse_ViolatingModule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckSchedulingConstraintsResponse_ViolatingModule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckSchedulingConstraintsResponse_ViolatingModule* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckSchedulingConstraintsResponse_ViolatingModule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckSchedulingConstraintsResponse_ViolatingModule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CheckSchedulingConstraintsResponse_ViolatingModule& from) {
    CheckSchedulingConstraintsResponse_ViolatingModule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CheckSchedulingConstraintsResponse_ViolatingModule* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.CheckSchedulingConstraintsResponse.ViolatingModule";
  }
  protected:
  explicit CheckSchedulingConstraintsResponse_ViolatingModule(::google::protobuf::Arena* arena);
  CheckSchedulingConstraintsResponse_ViolatingModule(::google::protobuf::Arena* arena, const CheckSchedulingConstraintsResponse_ViolatingModule& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.CheckSchedulingConstraintsResponse.ViolatingModule)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      71, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class CheckSchedulingConstraintsResponse_ViolatingClass final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass) */ {
 public:
  inline CheckSchedulingConstraintsResponse_ViolatingClass() : CheckSchedulingConstraintsResponse_ViolatingClass(nullptr) {}
  ~CheckSchedulingConstraintsResponse_ViolatingClass() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CheckSchedulingConstraintsResponse_ViolatingClass(::google::protobuf::internal::ConstantInitialized);

  inline CheckSchedulingConstraintsResponse_ViolatingClass(const CheckSchedulingConstraintsResponse_ViolatingClass& from)
      : CheckSchedulingConstraintsResponse_ViolatingClass(nullptr, from) {}
  CheckSchedulingConstraintsResponse_ViolatingClass(CheckSchedulingConstraintsResponse_ViolatingClass&& from) noexcept
    : CheckSchedulingConstraintsResponse_ViolatingClass() {
    *this = ::std::move(from);
  }

  inline CheckSchedulingConstraintsResponse_ViolatingClass& operator=(const CheckSchedulingConstraintsResponse_ViolatingClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckSchedulingConstraintsResponse_ViolatingClass& operator=(CheckSchedulingConstraintsResponse_ViolatingClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckSchedulingConstraintsResponse_ViolatingClass& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckSchedulingConstraintsResponse_ViolatingClass* internal_default_instance() {
    return reinterpret_cast<const CheckSchedulingConstraintsResponse_ViolatingClass*>(
               &_CheckSchedulingConstraintsResponse_ViolatingClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CheckSchedulingConstraintsResponse_ViolatingClass& a, CheckSchedulingConstraintsResponse_ViolatingClass& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckSchedulingConstraintsResponse_ViolatingClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckSchedulingConstraintsResponse_ViolatingClass* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckSchedulingConstraintsResponse_ViolatingClass* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckSchedulingConstraintsResponse_ViolatingClass>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckSchedulingConstraintsResponse_ViolatingClass& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CheckSchedulingConstraintsResponse_ViolatingClass& from) {
    CheckSchedulingConstraintsResponse_ViolatingClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CheckSchedulingConstraintsResponse_ViolatingClass* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass";
  }
  protected:
  explicit CheckSchedulingConstraintsResponse_ViolatingClass(::google::protobuf::Arena* arena);
  CheckSchedulingConstraintsResponse_ViolatingClass(::google::protobuf::Arena* arena, const CheckSchedulingConstraintsResponse_ViolatingClass& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kConstraintFieldNumber = 2,
    kAssignedNodeFieldNumber = 3,
    kAssignedCoreFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int32 constraint = 2;
  void clear_constraint() ;
  ::int32_t constraint() const;
  void set_constraint(::int32_t value);

  private:
  ::int32_t _internal_constraint() const;
  void _internal_set_constraint(::int32_t value);

  public:
  // int32 assigned_node = 3;
  void clear_assigned_node() ;
  ::int32_t assigned_node() const;
  void set_assigned_node(::int32_t value);

  private:
  ::int32_t _internal_assigned_node() const;
  void _internal_set_assigned_node(::int32_t value);

  public:
  // int32 assigned_core = 4;
  void clear_assigned_core() ;
  ::int32_t assigned_core() const;
  void set_assigned_core(::int32_t value);

  private:
  ::int32_t _internal_assigned_core() const;
  void _internal_set_assigned_core(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      70, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t constraint_;
    ::int32_t assigned_node_;
    ::int32_t assigned_core_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class AddWorkerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.AddWorkerRequest) */ {
 public:
  inline AddWorkerRequest() : AddWorkerRequest(nullptr) {}
  ~AddWorkerRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddWorkerRequest(::google::protobuf::internal::ConstantInitialized);

  inline AddWorkerRequest(const AddWorkerRequest& from)
      : AddWorkerRequest(nullptr, from) {}
  AddWorkerRequest(AddWorkerRequest&& from) noexcept
    : AddWorkerRequest() {
    *this = ::std::move(from);
  }

  inline AddWorkerRequest& operator=(const AddWorkerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddWorkerRequest& operator=(AddWorkerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddWorkerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddWorkerRequest* internal_default_instance() {
    return reinterpret_cast<const AddWorkerRequest*>(
               &_AddWorkerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AddWorkerRequest& a, AddWorkerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddWorkerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddWorkerRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddWorkerRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddWorkerRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddWorkerRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddWorkerRequest& from) {
    AddWorkerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddWorkerRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.AddWorkerRequest";
  }
  protected:
  explicit AddWorkerRequest(::google::protobuf::Arena* arena);
  AddWorkerRequest(::google::protobuf::Arena* arena, const AddWorkerRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchedulerFieldNumber = 3,
    kWidFieldNumber = 1,
    kCoreFieldNumber = 2,
  };
  // string scheduler = 3;
  void clear_scheduler() ;
  const std::string& scheduler() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_scheduler(Arg_&& arg, Args_... args);
  std::string* mutable_scheduler();
  PROTOBUF_NODISCARD std::string* release_scheduler();
  void set_allocated_scheduler(std::string* value);

  private:
  const std::string& _internal_scheduler() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scheduler(
      const std::string& value);
  std::string* _internal_mutable_scheduler();

  public:
  // int64 wid = 1;
  void clear_wid() ;
  ::int64_t wid() const;
  void set_wid(::int64_t value);

  private:
  ::int64_t _internal_wid() const;
  void _internal_set_wid(::int64_t value);

  public:
  // int64 core = 2;
  void clear_core() ;
  ::int64_t core() const;
  void set_core(::int64_t value);

  private:
  ::int64_t _internal_core() const;
  void _internal_set_core(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.AddWorkerRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr scheduler_;
    ::int64_t wid_;
    ::int64_t core_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class VersionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.VersionResponse) */ {
 public:
  inline VersionResponse() : VersionResponse(nullptr) {}
  ~VersionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VersionResponse(::google::protobuf::internal::ConstantInitialized);

  inline VersionResponse(const VersionResponse& from)
      : VersionResponse(nullptr, from) {}
  VersionResponse(VersionResponse&& from) noexcept
    : VersionResponse() {
    *this = ::std::move(from);
  }

  inline VersionResponse& operator=(const VersionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionResponse& operator=(VersionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VersionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VersionResponse* internal_default_instance() {
    return reinterpret_cast<const VersionResponse*>(
               &_VersionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(VersionResponse& a, VersionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VersionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VersionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VersionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VersionResponse& from) {
    VersionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VersionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.VersionResponse";
  }
  protected:
  explicit VersionResponse(::google::protobuf::Arena* arena);
  VersionResponse(::google::protobuf::Arena* arena, const VersionResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // string version = 2;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.VersionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class TrafficClass final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.TrafficClass) */ {
 public:
  inline TrafficClass() : TrafficClass(nullptr) {}
  ~TrafficClass() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficClass(::google::protobuf::internal::ConstantInitialized);

  inline TrafficClass(const TrafficClass& from)
      : TrafficClass(nullptr, from) {}
  TrafficClass(TrafficClass&& from) noexcept
    : TrafficClass() {
    *this = ::std::move(from);
  }

  inline TrafficClass& operator=(const TrafficClass& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficClass& operator=(TrafficClass&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficClass& default_instance() {
    return *internal_default_instance();
  }
  enum ArgCase {
    kPriority = 6,
    kShare = 7,
    ARG_NOT_SET = 0,
  };

  static inline const TrafficClass* internal_default_instance() {
    return reinterpret_cast<const TrafficClass*>(
               &_TrafficClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TrafficClass& a, TrafficClass& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficClass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficClass* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficClass* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficClass>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficClass& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficClass& from) {
    TrafficClass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficClass* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.TrafficClass";
  }
  protected:
  explicit TrafficClass(::google::protobuf::Arena* arena);
  TrafficClass(::google::protobuf::Arena* arena, const TrafficClass& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLimitFieldNumber = 9,
    kMaxBurstFieldNumber = 10,
    kParentFieldNumber = 1,
    kNameFieldNumber = 2,
    kPolicyFieldNumber = 4,
    kResourceFieldNumber = 5,
    kLeafModuleNameFieldNumber = 11,
    kWidFieldNumber = 8,
    kLeafModuleTaskidFieldNumber = 12,
    kBlockedFieldNumber = 3,
    kPriorityFieldNumber = 6,
    kShareFieldNumber = 7,
  };
  // map<string, int64> limit = 9;
  int limit_size() const;
  private:
  int _internal_limit_size() const;

  public:
  void clear_limit() ;
  const ::google::protobuf::Map<std::string, ::int64_t>& limit() const;
  ::google::protobuf::Map<std::string, ::int64_t>* mutable_limit();

  private:
  const ::google::protobuf::Map<std::string, ::int64_t>& _internal_limit() const;
  ::google::protobuf::Map<std::string, ::int64_t>* _internal_mutable_limit();

  public:
  // map<string, int64> max_burst = 10;
  int max_burst_size() const;
  private:
  int _internal_max_burst_size() const;

  public:
  void clear_max_burst() ;
  const ::google::protobuf::Map<std::string, ::int64_t>& max_burst() const;
  ::google::protobuf::Map<std::string, ::int64_t>* mutable_max_burst();

  private:
  const ::google::protobuf::Map<std::string, ::int64_t>& _internal_max_burst() const;
  ::google::protobuf::Map<std::string, ::int64_t>* _internal_mutable_max_burst();

  public:
  // string parent = 1;
  void clear_parent() ;
  const std::string& parent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent(Arg_&& arg, Args_... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* value);

  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(
      const std::string& value);
  std::string* _internal_mutable_parent();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string policy = 4;
  void clear_policy() ;
  const std::string& policy() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_policy(Arg_&& arg, Args_... args);
  std::string* mutable_policy();
  PROTOBUF_NODISCARD std::string* release_policy();
  void set_allocated_policy(std::string* value);

  private:
  const std::string& _internal_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy(
      const std::string& value);
  std::string* _internal_mutable_policy();

  public:
  // string resource = 5;
  void clear_resource() ;
  const std::string& resource() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resource(Arg_&& arg, Args_... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* value);

  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(
      const std::string& value);
  std::string* _internal_mutable_resource();

  public:
  // string leaf_module_name = 11;
  void clear_leaf_module_name() ;
  const std::string& leaf_module_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_leaf_module_name(Arg_&& arg, Args_... args);
  std::string* mutable_leaf_module_name();
  PROTOBUF_NODISCARD std::string* release_leaf_module_name();
  void set_allocated_leaf_module_name(std::string* value);

  private:
  const std::string& _internal_leaf_module_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leaf_module_name(
      const std::string& value);
  std::string* _internal_mutable_leaf_module_name();

  public:
  // int64 wid = 8;
  void clear_wid() ;
  ::int64_t wid() const;
  void set_wid(::int64_t value);

  private:
  ::int64_t _internal_wid() const;
  void _internal_set_wid(::int64_t value);

  public:
  // uint64 leaf_module_taskid = 12;
  void clear_leaf_module_taskid() ;
  ::uint64_t leaf_module_taskid() const;
  void set_leaf_module_taskid(::uint64_t value);

  private:
  ::uint64_t _internal_leaf_module_taskid() const;
  void _internal_set_leaf_module_taskid(::uint64_t value);

  public:
  // bool blocked = 3;
  void clear_blocked() ;
  bool blocked() const;
  void set_blocked(bool value);

  private:
  bool _internal_blocked() const;
  void _internal_set_blocked(bool value);

  public:
  // int64 priority = 6;
  bool has_priority() const;
  void clear_priority() ;
  ::int64_t priority() const;
  void set_priority(::int64_t value);

  private:
  ::int64_t _internal_priority() const;
  void _internal_set_priority(::int64_t value);

  public:
  // int64 share = 7;
  bool has_share() const;
  void clear_share() ;
  ::int64_t share() const;
  void set_share(::int64_t value);

  private:
  ::int64_t _internal_share() const;
  void _internal_set_share(::int64_t value);

  public:
  void clear_arg();
  ArgCase arg_case() const;
  // @@protoc_insertion_point(class_scope:bess.pb.TrafficClass)
 private:
  class _Internal;
  void set_has_priority();
  void set_has_share();

  inline bool has_arg() const;
  inline void clear_has_arg();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 2,
      91, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<TrafficClass_LimitEntry_DoNotUse, std::string, ::int64_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT64>
        limit_;
    ::google::protobuf::internal::MapField<TrafficClass_MaxBurstEntry_DoNotUse, std::string, ::int64_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT64>
        max_burst_;
    ::google::protobuf::internal::ArenaStringPtr parent_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr policy_;
    ::google::protobuf::internal::ArenaStringPtr resource_;
    ::google::protobuf::internal::ArenaStringPtr leaf_module_name_;
    ::int64_t wid_;
    ::uint64_t leaf_module_taskid_;
    bool blocked_;
    union ArgUnion {
      constexpr ArgUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t priority_;
      ::int64_t share_;
    } arg_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class SetPortConfRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.SetPortConfRequest) */ {
 public:
  inline SetPortConfRequest() : SetPortConfRequest(nullptr) {}
  ~SetPortConfRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetPortConfRequest(::google::protobuf::internal::ConstantInitialized);

  inline SetPortConfRequest(const SetPortConfRequest& from)
      : SetPortConfRequest(nullptr, from) {}
  SetPortConfRequest(SetPortConfRequest&& from) noexcept
    : SetPortConfRequest() {
    *this = ::std::move(from);
  }

  inline SetPortConfRequest& operator=(const SetPortConfRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPortConfRequest& operator=(SetPortConfRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPortConfRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPortConfRequest* internal_default_instance() {
    return reinterpret_cast<const SetPortConfRequest*>(
               &_SetPortConfRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(SetPortConfRequest& a, SetPortConfRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPortConfRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPortConfRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPortConfRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPortConfRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetPortConfRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SetPortConfRequest& from) {
    SetPortConfRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SetPortConfRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.SetPortConfRequest";
  }
  protected:
  explicit SetPortConfRequest(::google::protobuf::Arena* arena);
  SetPortConfRequest(::google::protobuf::Arena* arena, const SetPortConfRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kConfFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .bess.pb.PortConf conf = 2;
  bool has_conf() const;
  void clear_conf() ;
  const ::bess::pb::PortConf& conf() const;
  PROTOBUF_NODISCARD ::bess::pb::PortConf* release_conf();
  ::bess::pb::PortConf* mutable_conf();
  void set_allocated_conf(::bess::pb::PortConf* value);
  void unsafe_arena_set_allocated_conf(::bess::pb::PortConf* value);
  ::bess::pb::PortConf* unsafe_arena_release_conf();

  private:
  const ::bess::pb::PortConf& _internal_conf() const;
  ::bess::pb::PortConf* _internal_mutable_conf();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.SetPortConfRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::bess::pb::PortConf* conf_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ListWorkersResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ListWorkersResponse) */ {
 public:
  inline ListWorkersResponse() : ListWorkersResponse(nullptr) {}
  ~ListWorkersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListWorkersResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListWorkersResponse(const ListWorkersResponse& from)
      : ListWorkersResponse(nullptr, from) {}
  ListWorkersResponse(ListWorkersResponse&& from) noexcept
    : ListWorkersResponse() {
    *this = ::std::move(from);
  }

  inline ListWorkersResponse& operator=(const ListWorkersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListWorkersResponse& operator=(ListWorkersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListWorkersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListWorkersResponse* internal_default_instance() {
    return reinterpret_cast<const ListWorkersResponse*>(
               &_ListWorkersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListWorkersResponse& a, ListWorkersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListWorkersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListWorkersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListWorkersResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListWorkersResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListWorkersResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListWorkersResponse& from) {
    ListWorkersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListWorkersResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ListWorkersResponse";
  }
  protected:
  explicit ListWorkersResponse(::google::protobuf::Arena* arena);
  ListWorkersResponse(::google::protobuf::Arena* arena, const ListWorkersResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using WorkerStatus = ListWorkersResponse_WorkerStatus;

  // accessors -------------------------------------------------------

  enum : int {
    kWorkersStatusFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated .bess.pb.ListWorkersResponse.WorkerStatus workers_status = 2;
  int workers_status_size() const;
  private:
  int _internal_workers_status_size() const;

  public:
  void clear_workers_status() ;
  ::bess::pb::ListWorkersResponse_WorkerStatus* mutable_workers_status(int index);
  ::google::protobuf::RepeatedPtrField< ::bess::pb::ListWorkersResponse_WorkerStatus >*
      mutable_workers_status();
  private:
  const ::google::protobuf::RepeatedPtrField<::bess::pb::ListWorkersResponse_WorkerStatus>& _internal_workers_status() const;
  ::google::protobuf::RepeatedPtrField<::bess::pb::ListWorkersResponse_WorkerStatus>* _internal_mutable_workers_status();
  public:
  const ::bess::pb::ListWorkersResponse_WorkerStatus& workers_status(int index) const;
  ::bess::pb::ListWorkersResponse_WorkerStatus* add_workers_status();
  const ::google::protobuf::RepeatedPtrField< ::bess::pb::ListWorkersResponse_WorkerStatus >&
      workers_status() const;
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ListWorkersResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::bess::pb::ListWorkersResponse_WorkerStatus > workers_status_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ListPortsResponse_Port final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ListPortsResponse.Port) */ {
 public:
  inline ListPortsResponse_Port() : ListPortsResponse_Port(nullptr) {}
  ~ListPortsResponse_Port() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListPortsResponse_Port(::google::protobuf::internal::ConstantInitialized);

  inline ListPortsResponse_Port(const ListPortsResponse_Port& from)
      : ListPortsResponse_Port(nullptr, from) {}
  ListPortsResponse_Port(ListPortsResponse_Port&& from) noexcept
    : ListPortsResponse_Port() {
    *this = ::std::move(from);
  }

  inline ListPortsResponse_Port& operator=(const ListPortsResponse_Port& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPortsResponse_Port& operator=(ListPortsResponse_Port&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPortsResponse_Port& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPortsResponse_Port* internal_default_instance() {
    return reinterpret_cast<const ListPortsResponse_Port*>(
               &_ListPortsResponse_Port_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ListPortsResponse_Port& a, ListPortsResponse_Port& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPortsResponse_Port* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPortsResponse_Port* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPortsResponse_Port* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPortsResponse_Port>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListPortsResponse_Port& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListPortsResponse_Port& from) {
    ListPortsResponse_Port::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListPortsResponse_Port* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ListPortsResponse.Port";
  }
  protected:
  explicit ListPortsResponse_Port(::google::protobuf::Arena* arena);
  ListPortsResponse_Port(::google::protobuf::Arena* arena, const ListPortsResponse_Port& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDriverFieldNumber = 2,
    kMacAddrFieldNumber = 3,
    kDriverArgFieldNumber = 8,
    kNumIncQFieldNumber = 4,
    kNumOutQFieldNumber = 5,
    kSizeIncQFieldNumber = 6,
    kSizeOutQFieldNumber = 7,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string driver = 2;
  void clear_driver() ;
  const std::string& driver() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_driver(Arg_&& arg, Args_... args);
  std::string* mutable_driver();
  PROTOBUF_NODISCARD std::string* release_driver();
  void set_allocated_driver(std::string* value);

  private:
  const std::string& _internal_driver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver(
      const std::string& value);
  std::string* _internal_mutable_driver();

  public:
  // string mac_addr = 3;
  void clear_mac_addr() ;
  const std::string& mac_addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mac_addr(Arg_&& arg, Args_... args);
  std::string* mutable_mac_addr();
  PROTOBUF_NODISCARD std::string* release_mac_addr();
  void set_allocated_mac_addr(std::string* value);

  private:
  const std::string& _internal_mac_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_addr(
      const std::string& value);
  std::string* _internal_mutable_mac_addr();

  public:
  // .google.protobuf.Any driver_arg = 8;
  bool has_driver_arg() const;
  void clear_driver_arg() ;
  const ::google::protobuf::Any& driver_arg() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_driver_arg();
  ::google::protobuf::Any* mutable_driver_arg();
  void set_allocated_driver_arg(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_driver_arg(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_driver_arg();

  private:
  const ::google::protobuf::Any& _internal_driver_arg() const;
  ::google::protobuf::Any* _internal_mutable_driver_arg();

  public:
  // uint64 num_inc_q = 4;
  void clear_num_inc_q() ;
  ::uint64_t num_inc_q() const;
  void set_num_inc_q(::uint64_t value);

  private:
  ::uint64_t _internal_num_inc_q() const;
  void _internal_set_num_inc_q(::uint64_t value);

  public:
  // uint64 num_out_q = 5;
  void clear_num_out_q() ;
  ::uint64_t num_out_q() const;
  void set_num_out_q(::uint64_t value);

  private:
  ::uint64_t _internal_num_out_q() const;
  void _internal_set_num_out_q(::uint64_t value);

  public:
  // uint64 size_inc_q = 6;
  void clear_size_inc_q() ;
  ::uint64_t size_inc_q() const;
  void set_size_inc_q(::uint64_t value);

  private:
  ::uint64_t _internal_size_inc_q() const;
  void _internal_set_size_inc_q(::uint64_t value);

  public:
  // uint64 size_out_q = 7;
  void clear_size_out_q() ;
  ::uint64_t size_out_q() const;
  void set_size_out_q(::uint64_t value);

  private:
  ::uint64_t _internal_size_out_q() const;
  void _internal_set_size_out_q(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ListPortsResponse.Port)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      65, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr driver_;
    ::google::protobuf::internal::ArenaStringPtr mac_addr_;
    ::google::protobuf::Any* driver_arg_;
    ::uint64_t num_inc_q_;
    ::uint64_t num_out_q_;
    ::uint64_t size_inc_q_;
    ::uint64_t size_out_q_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ListPluginsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ListPluginsResponse) */ {
 public:
  inline ListPluginsResponse() : ListPluginsResponse(nullptr) {}
  ~ListPluginsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListPluginsResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListPluginsResponse(const ListPluginsResponse& from)
      : ListPluginsResponse(nullptr, from) {}
  ListPluginsResponse(ListPluginsResponse&& from) noexcept
    : ListPluginsResponse() {
    *this = ::std::move(from);
  }

  inline ListPluginsResponse& operator=(const ListPluginsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPluginsResponse& operator=(ListPluginsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPluginsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPluginsResponse* internal_default_instance() {
    return reinterpret_cast<const ListPluginsResponse*>(
               &_ListPluginsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListPluginsResponse& a, ListPluginsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPluginsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPluginsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPluginsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPluginsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListPluginsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListPluginsResponse& from) {
    ListPluginsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListPluginsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ListPluginsResponse";
  }
  protected:
  explicit ListPluginsResponse(::google::protobuf::Arena* arena);
  ListPluginsResponse(::google::protobuf::Arena* arena, const ListPluginsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathsFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated string paths = 2;
  int paths_size() const;
  private:
  int _internal_paths_size() const;

  public:
  void clear_paths() ;
  const std::string& paths(int index) const;
  std::string* mutable_paths(int index);
  void set_paths(int index, const std::string& value);
  void set_paths(int index, std::string&& value);
  void set_paths(int index, const char* value);
  void set_paths(int index, const char* value, std::size_t size);
  void set_paths(int index, absl::string_view value);
  std::string* add_paths();
  void add_paths(const std::string& value);
  void add_paths(std::string&& value);
  void add_paths(const char* value);
  void add_paths(const char* value, std::size_t size);
  void add_paths(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& paths() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_paths();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_paths() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_paths();

  public:
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ListPluginsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> paths_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ListModulesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ListModulesResponse) */ {
 public:
  inline ListModulesResponse() : ListModulesResponse(nullptr) {}
  ~ListModulesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListModulesResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListModulesResponse(const ListModulesResponse& from)
      : ListModulesResponse(nullptr, from) {}
  ListModulesResponse(ListModulesResponse&& from) noexcept
    : ListModulesResponse() {
    *this = ::std::move(from);
  }

  inline ListModulesResponse& operator=(const ListModulesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListModulesResponse& operator=(ListModulesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListModulesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListModulesResponse* internal_default_instance() {
    return reinterpret_cast<const ListModulesResponse*>(
               &_ListModulesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(ListModulesResponse& a, ListModulesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListModulesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListModulesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListModulesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListModulesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListModulesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListModulesResponse& from) {
    ListModulesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListModulesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ListModulesResponse";
  }
  protected:
  explicit ListModulesResponse(::google::protobuf::Arena* arena);
  ListModulesResponse(::google::protobuf::Arena* arena, const ListModulesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Module = ListModulesResponse_Module;

  // accessors -------------------------------------------------------

  enum : int {
    kModulesFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated .bess.pb.ListModulesResponse.Module modules = 2;
  int modules_size() const;
  private:
  int _internal_modules_size() const;

  public:
  void clear_modules() ;
  ::bess::pb::ListModulesResponse_Module* mutable_modules(int index);
  ::google::protobuf::RepeatedPtrField< ::bess::pb::ListModulesResponse_Module >*
      mutable_modules();
  private:
  const ::google::protobuf::RepeatedPtrField<::bess::pb::ListModulesResponse_Module>& _internal_modules() const;
  ::google::protobuf::RepeatedPtrField<::bess::pb::ListModulesResponse_Module>* _internal_mutable_modules();
  public:
  const ::bess::pb::ListModulesResponse_Module& modules(int index) const;
  ::bess::pb::ListModulesResponse_Module* add_modules();
  const ::google::protobuf::RepeatedPtrField< ::bess::pb::ListModulesResponse_Module >&
      modules() const;
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ListModulesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::bess::pb::ListModulesResponse_Module > modules_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ListMclassResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ListMclassResponse) */ {
 public:
  inline ListMclassResponse() : ListMclassResponse(nullptr) {}
  ~ListMclassResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListMclassResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListMclassResponse(const ListMclassResponse& from)
      : ListMclassResponse(nullptr, from) {}
  ListMclassResponse(ListMclassResponse&& from) noexcept
    : ListMclassResponse() {
    *this = ::std::move(from);
  }

  inline ListMclassResponse& operator=(const ListMclassResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListMclassResponse& operator=(ListMclassResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListMclassResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListMclassResponse* internal_default_instance() {
    return reinterpret_cast<const ListMclassResponse*>(
               &_ListMclassResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ListMclassResponse& a, ListMclassResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListMclassResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListMclassResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListMclassResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListMclassResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListMclassResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListMclassResponse& from) {
    ListMclassResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListMclassResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ListMclassResponse";
  }
  protected:
  explicit ListMclassResponse(::google::protobuf::Arena* arena);
  ListMclassResponse(::google::protobuf::Arena* arena, const ListMclassResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamesFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated string names = 2;
  int names_size() const;
  private:
  int _internal_names_size() const;

  public:
  void clear_names() ;
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, std::size_t size);
  void set_names(int index, absl::string_view value);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, std::size_t size);
  void add_names(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_names();

  public:
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ListMclassResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> names_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ListGateHookClassResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ListGateHookClassResponse) */ {
 public:
  inline ListGateHookClassResponse() : ListGateHookClassResponse(nullptr) {}
  ~ListGateHookClassResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListGateHookClassResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListGateHookClassResponse(const ListGateHookClassResponse& from)
      : ListGateHookClassResponse(nullptr, from) {}
  ListGateHookClassResponse(ListGateHookClassResponse&& from) noexcept
    : ListGateHookClassResponse() {
    *this = ::std::move(from);
  }

  inline ListGateHookClassResponse& operator=(const ListGateHookClassResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListGateHookClassResponse& operator=(ListGateHookClassResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListGateHookClassResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListGateHookClassResponse* internal_default_instance() {
    return reinterpret_cast<const ListGateHookClassResponse*>(
               &_ListGateHookClassResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(ListGateHookClassResponse& a, ListGateHookClassResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListGateHookClassResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListGateHookClassResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListGateHookClassResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListGateHookClassResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListGateHookClassResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListGateHookClassResponse& from) {
    ListGateHookClassResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListGateHookClassResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ListGateHookClassResponse";
  }
  protected:
  explicit ListGateHookClassResponse(::google::protobuf::Arena* arena);
  ListGateHookClassResponse(::google::protobuf::Arena* arena, const ListGateHookClassResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamesFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated string names = 2;
  int names_size() const;
  private:
  int _internal_names_size() const;

  public:
  void clear_names() ;
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, std::size_t size);
  void set_names(int index, absl::string_view value);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, std::size_t size);
  void add_names(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_names();

  public:
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ListGateHookClassResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> names_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ListDriversResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ListDriversResponse) */ {
 public:
  inline ListDriversResponse() : ListDriversResponse(nullptr) {}
  ~ListDriversResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListDriversResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListDriversResponse(const ListDriversResponse& from)
      : ListDriversResponse(nullptr, from) {}
  ListDriversResponse(ListDriversResponse&& from) noexcept
    : ListDriversResponse() {
    *this = ::std::move(from);
  }

  inline ListDriversResponse& operator=(const ListDriversResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDriversResponse& operator=(ListDriversResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDriversResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDriversResponse* internal_default_instance() {
    return reinterpret_cast<const ListDriversResponse*>(
               &_ListDriversResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ListDriversResponse& a, ListDriversResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDriversResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDriversResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDriversResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDriversResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListDriversResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListDriversResponse& from) {
    ListDriversResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListDriversResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ListDriversResponse";
  }
  protected:
  explicit ListDriversResponse(::google::protobuf::Arena* arena);
  ListDriversResponse(::google::protobuf::Arena* arena, const ListDriversResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDriverNamesFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated string driver_names = 2;
  int driver_names_size() const;
  private:
  int _internal_driver_names_size() const;

  public:
  void clear_driver_names() ;
  const std::string& driver_names(int index) const;
  std::string* mutable_driver_names(int index);
  void set_driver_names(int index, const std::string& value);
  void set_driver_names(int index, std::string&& value);
  void set_driver_names(int index, const char* value);
  void set_driver_names(int index, const char* value, std::size_t size);
  void set_driver_names(int index, absl::string_view value);
  std::string* add_driver_names();
  void add_driver_names(const std::string& value);
  void add_driver_names(std::string&& value);
  void add_driver_names(const char* value);
  void add_driver_names(const char* value, std::size_t size);
  void add_driver_names(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& driver_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_driver_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_driver_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_driver_names();

  public:
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ListDriversResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> driver_names_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetTcStatsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetTcStatsResponse) */ {
 public:
  inline GetTcStatsResponse() : GetTcStatsResponse(nullptr) {}
  ~GetTcStatsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetTcStatsResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetTcStatsResponse(const GetTcStatsResponse& from)
      : GetTcStatsResponse(nullptr, from) {}
  GetTcStatsResponse(GetTcStatsResponse&& from) noexcept
    : GetTcStatsResponse() {
    *this = ::std::move(from);
  }

  inline GetTcStatsResponse& operator=(const GetTcStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTcStatsResponse& operator=(GetTcStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTcStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTcStatsResponse* internal_default_instance() {
    return reinterpret_cast<const GetTcStatsResponse*>(
               &_GetTcStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetTcStatsResponse& a, GetTcStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTcStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTcStatsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTcStatsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTcStatsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTcStatsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetTcStatsResponse& from) {
    GetTcStatsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetTcStatsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetTcStatsResponse";
  }
  protected:
  explicit GetTcStatsResponse(::google::protobuf::Arena* arena);
  GetTcStatsResponse(::google::protobuf::Arena* arena, const GetTcStatsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kCountFieldNumber = 3,
    kCyclesFieldNumber = 4,
    kPacketsFieldNumber = 5,
    kBitsFieldNumber = 6,
  };
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // double timestamp = 2;
  void clear_timestamp() ;
  double timestamp() const;
  void set_timestamp(double value);

  private:
  double _internal_timestamp() const;
  void _internal_set_timestamp(double value);

  public:
  // uint64 count = 3;
  void clear_count() ;
  ::uint64_t count() const;
  void set_count(::uint64_t value);

  private:
  ::uint64_t _internal_count() const;
  void _internal_set_count(::uint64_t value);

  public:
  // uint64 cycles = 4;
  void clear_cycles() ;
  ::uint64_t cycles() const;
  void set_cycles(::uint64_t value);

  private:
  ::uint64_t _internal_cycles() const;
  void _internal_set_cycles(::uint64_t value);

  public:
  // uint64 packets = 5;
  void clear_packets() ;
  ::uint64_t packets() const;
  void set_packets(::uint64_t value);

  private:
  ::uint64_t _internal_packets() const;
  void _internal_set_packets(::uint64_t value);

  public:
  // uint64 bits = 6;
  void clear_bits() ;
  ::uint64_t bits() const;
  void set_bits(::uint64_t value);

  private:
  ::uint64_t _internal_bits() const;
  void _internal_set_bits(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetTcStatsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::bess::pb::Error* error_;
    double timestamp_;
    ::uint64_t count_;
    ::uint64_t cycles_;
    ::uint64_t packets_;
    ::uint64_t bits_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetPortStatsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetPortStatsResponse) */ {
 public:
  inline GetPortStatsResponse() : GetPortStatsResponse(nullptr) {}
  ~GetPortStatsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPortStatsResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetPortStatsResponse(const GetPortStatsResponse& from)
      : GetPortStatsResponse(nullptr, from) {}
  GetPortStatsResponse(GetPortStatsResponse&& from) noexcept
    : GetPortStatsResponse() {
    *this = ::std::move(from);
  }

  inline GetPortStatsResponse& operator=(const GetPortStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPortStatsResponse& operator=(GetPortStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPortStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPortStatsResponse* internal_default_instance() {
    return reinterpret_cast<const GetPortStatsResponse*>(
               &_GetPortStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(GetPortStatsResponse& a, GetPortStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPortStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPortStatsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPortStatsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPortStatsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPortStatsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPortStatsResponse& from) {
    GetPortStatsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPortStatsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetPortStatsResponse";
  }
  protected:
  explicit GetPortStatsResponse(::google::protobuf::Arena* arena);
  GetPortStatsResponse(::google::protobuf::Arena* arena, const GetPortStatsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Stat = GetPortStatsResponse_Stat;

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kIncFieldNumber = 2,
    kOutFieldNumber = 3,
    kTimestampFieldNumber = 4,
  };
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // .bess.pb.GetPortStatsResponse.Stat inc = 2;
  bool has_inc() const;
  void clear_inc() ;
  const ::bess::pb::GetPortStatsResponse_Stat& inc() const;
  PROTOBUF_NODISCARD ::bess::pb::GetPortStatsResponse_Stat* release_inc();
  ::bess::pb::GetPortStatsResponse_Stat* mutable_inc();
  void set_allocated_inc(::bess::pb::GetPortStatsResponse_Stat* value);
  void unsafe_arena_set_allocated_inc(::bess::pb::GetPortStatsResponse_Stat* value);
  ::bess::pb::GetPortStatsResponse_Stat* unsafe_arena_release_inc();

  private:
  const ::bess::pb::GetPortStatsResponse_Stat& _internal_inc() const;
  ::bess::pb::GetPortStatsResponse_Stat* _internal_mutable_inc();

  public:
  // .bess.pb.GetPortStatsResponse.Stat out = 3;
  bool has_out() const;
  void clear_out() ;
  const ::bess::pb::GetPortStatsResponse_Stat& out() const;
  PROTOBUF_NODISCARD ::bess::pb::GetPortStatsResponse_Stat* release_out();
  ::bess::pb::GetPortStatsResponse_Stat* mutable_out();
  void set_allocated_out(::bess::pb::GetPortStatsResponse_Stat* value);
  void unsafe_arena_set_allocated_out(::bess::pb::GetPortStatsResponse_Stat* value);
  ::bess::pb::GetPortStatsResponse_Stat* unsafe_arena_release_out();

  private:
  const ::bess::pb::GetPortStatsResponse_Stat& _internal_out() const;
  ::bess::pb::GetPortStatsResponse_Stat* _internal_mutable_out();

  public:
  // double timestamp = 4;
  void clear_timestamp() ;
  double timestamp() const;
  void set_timestamp(double value);

  private:
  double _internal_timestamp() const;
  void _internal_set_timestamp(double value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetPortStatsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::bess::pb::Error* error_;
    ::bess::pb::GetPortStatsResponse_Stat* inc_;
    ::bess::pb::GetPortStatsResponse_Stat* out_;
    double timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetPortConfResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetPortConfResponse) */ {
 public:
  inline GetPortConfResponse() : GetPortConfResponse(nullptr) {}
  ~GetPortConfResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPortConfResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetPortConfResponse(const GetPortConfResponse& from)
      : GetPortConfResponse(nullptr, from) {}
  GetPortConfResponse(GetPortConfResponse&& from) noexcept
    : GetPortConfResponse() {
    *this = ::std::move(from);
  }

  inline GetPortConfResponse& operator=(const GetPortConfResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPortConfResponse& operator=(GetPortConfResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPortConfResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPortConfResponse* internal_default_instance() {
    return reinterpret_cast<const GetPortConfResponse*>(
               &_GetPortConfResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetPortConfResponse& a, GetPortConfResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPortConfResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPortConfResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPortConfResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPortConfResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPortConfResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPortConfResponse& from) {
    GetPortConfResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPortConfResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetPortConfResponse";
  }
  protected:
  explicit GetPortConfResponse(::google::protobuf::Arena* arena);
  GetPortConfResponse(::google::protobuf::Arena* arena, const GetPortConfResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kConfFieldNumber = 2,
  };
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // .bess.pb.PortConf conf = 2;
  bool has_conf() const;
  void clear_conf() ;
  const ::bess::pb::PortConf& conf() const;
  PROTOBUF_NODISCARD ::bess::pb::PortConf* release_conf();
  ::bess::pb::PortConf* mutable_conf();
  void set_allocated_conf(::bess::pb::PortConf* value);
  void unsafe_arena_set_allocated_conf(::bess::pb::PortConf* value);
  ::bess::pb::PortConf* unsafe_arena_release_conf();

  private:
  const ::bess::pb::PortConf& _internal_conf() const;
  ::bess::pb::PortConf* _internal_mutable_conf();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetPortConfResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::bess::pb::Error* error_;
    ::bess::pb::PortConf* conf_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetModuleInfoResponse_OGate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetModuleInfoResponse.OGate) */ {
 public:
  inline GetModuleInfoResponse_OGate() : GetModuleInfoResponse_OGate(nullptr) {}
  ~GetModuleInfoResponse_OGate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetModuleInfoResponse_OGate(::google::protobuf::internal::ConstantInitialized);

  inline GetModuleInfoResponse_OGate(const GetModuleInfoResponse_OGate& from)
      : GetModuleInfoResponse_OGate(nullptr, from) {}
  GetModuleInfoResponse_OGate(GetModuleInfoResponse_OGate&& from) noexcept
    : GetModuleInfoResponse_OGate() {
    *this = ::std::move(from);
  }

  inline GetModuleInfoResponse_OGate& operator=(const GetModuleInfoResponse_OGate& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModuleInfoResponse_OGate& operator=(GetModuleInfoResponse_OGate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModuleInfoResponse_OGate& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModuleInfoResponse_OGate* internal_default_instance() {
    return reinterpret_cast<const GetModuleInfoResponse_OGate*>(
               &_GetModuleInfoResponse_OGate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(GetModuleInfoResponse_OGate& a, GetModuleInfoResponse_OGate& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModuleInfoResponse_OGate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModuleInfoResponse_OGate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModuleInfoResponse_OGate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModuleInfoResponse_OGate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetModuleInfoResponse_OGate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetModuleInfoResponse_OGate& from) {
    GetModuleInfoResponse_OGate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetModuleInfoResponse_OGate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetModuleInfoResponse.OGate";
  }
  protected:
  explicit GetModuleInfoResponse_OGate(::google::protobuf::Arena* arena);
  GetModuleInfoResponse_OGate(::google::protobuf::Arena* arena, const GetModuleInfoResponse_OGate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGatehooksFieldNumber = 9,
    kNameFieldNumber = 6,
    kOgateFieldNumber = 1,
    kCntFieldNumber = 2,
    kPktsFieldNumber = 3,
    kBytesFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kIgateFieldNumber = 7,
  };
  // repeated .bess.pb.GetModuleInfoResponse.GateHook gatehooks = 9;
  int gatehooks_size() const;
  private:
  int _internal_gatehooks_size() const;

  public:
  void clear_gatehooks() ;
  ::bess::pb::GetModuleInfoResponse_GateHook* mutable_gatehooks(int index);
  ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_GateHook >*
      mutable_gatehooks();
  private:
  const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_GateHook>& _internal_gatehooks() const;
  ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_GateHook>* _internal_mutable_gatehooks();
  public:
  const ::bess::pb::GetModuleInfoResponse_GateHook& gatehooks(int index) const;
  ::bess::pb::GetModuleInfoResponse_GateHook* add_gatehooks();
  const ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_GateHook >&
      gatehooks() const;
  // string name = 6;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // uint64 ogate = 1;
  void clear_ogate() ;
  ::uint64_t ogate() const;
  void set_ogate(::uint64_t value);

  private:
  ::uint64_t _internal_ogate() const;
  void _internal_set_ogate(::uint64_t value);

  public:
  // uint64 cnt = 2;
  void clear_cnt() ;
  ::uint64_t cnt() const;
  void set_cnt(::uint64_t value);

  private:
  ::uint64_t _internal_cnt() const;
  void _internal_set_cnt(::uint64_t value);

  public:
  // uint64 pkts = 3;
  void clear_pkts() ;
  ::uint64_t pkts() const;
  void set_pkts(::uint64_t value);

  private:
  ::uint64_t _internal_pkts() const;
  void _internal_set_pkts(::uint64_t value);

  public:
  // uint64 bytes = 4;
  void clear_bytes() ;
  ::uint64_t bytes() const;
  void set_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_bytes() const;
  void _internal_set_bytes(::uint64_t value);

  public:
  // double timestamp = 5;
  void clear_timestamp() ;
  double timestamp() const;
  void set_timestamp(double value);

  private:
  double _internal_timestamp() const;
  void _internal_set_timestamp(double value);

  public:
  // uint64 igate = 7;
  void clear_igate() ;
  ::uint64_t igate() const;
  void set_igate(::uint64_t value);

  private:
  ::uint64_t _internal_igate() const;
  void _internal_set_igate(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetModuleInfoResponse.OGate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 8, 1,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_GateHook > gatehooks_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint64_t ogate_;
    ::uint64_t cnt_;
    ::uint64_t pkts_;
    ::uint64_t bytes_;
    double timestamp_;
    ::uint64_t igate_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetModuleInfoResponse_IGate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetModuleInfoResponse.IGate) */ {
 public:
  inline GetModuleInfoResponse_IGate() : GetModuleInfoResponse_IGate(nullptr) {}
  ~GetModuleInfoResponse_IGate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetModuleInfoResponse_IGate(::google::protobuf::internal::ConstantInitialized);

  inline GetModuleInfoResponse_IGate(const GetModuleInfoResponse_IGate& from)
      : GetModuleInfoResponse_IGate(nullptr, from) {}
  GetModuleInfoResponse_IGate(GetModuleInfoResponse_IGate&& from) noexcept
    : GetModuleInfoResponse_IGate() {
    *this = ::std::move(from);
  }

  inline GetModuleInfoResponse_IGate& operator=(const GetModuleInfoResponse_IGate& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModuleInfoResponse_IGate& operator=(GetModuleInfoResponse_IGate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModuleInfoResponse_IGate& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModuleInfoResponse_IGate* internal_default_instance() {
    return reinterpret_cast<const GetModuleInfoResponse_IGate*>(
               &_GetModuleInfoResponse_IGate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(GetModuleInfoResponse_IGate& a, GetModuleInfoResponse_IGate& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModuleInfoResponse_IGate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModuleInfoResponse_IGate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModuleInfoResponse_IGate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModuleInfoResponse_IGate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetModuleInfoResponse_IGate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetModuleInfoResponse_IGate& from) {
    GetModuleInfoResponse_IGate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetModuleInfoResponse_IGate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetModuleInfoResponse.IGate";
  }
  protected:
  explicit GetModuleInfoResponse_IGate(::google::protobuf::Arena* arena);
  GetModuleInfoResponse_IGate(::google::protobuf::Arena* arena, const GetModuleInfoResponse_IGate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using OGate = GetModuleInfoResponse_IGate_OGate;

  // accessors -------------------------------------------------------

  enum : int {
    kOgatesFieldNumber = 2,
    kGatehooksFieldNumber = 8,
    kIgateFieldNumber = 1,
    kCntFieldNumber = 3,
    kPktsFieldNumber = 4,
    kBytesFieldNumber = 5,
    kTimestampFieldNumber = 6,
  };
  // repeated .bess.pb.GetModuleInfoResponse.IGate.OGate ogates = 2;
  int ogates_size() const;
  private:
  int _internal_ogates_size() const;

  public:
  void clear_ogates() ;
  ::bess::pb::GetModuleInfoResponse_IGate_OGate* mutable_ogates(int index);
  ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_IGate_OGate >*
      mutable_ogates();
  private:
  const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_IGate_OGate>& _internal_ogates() const;
  ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_IGate_OGate>* _internal_mutable_ogates();
  public:
  const ::bess::pb::GetModuleInfoResponse_IGate_OGate& ogates(int index) const;
  ::bess::pb::GetModuleInfoResponse_IGate_OGate* add_ogates();
  const ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_IGate_OGate >&
      ogates() const;
  // repeated .bess.pb.GetModuleInfoResponse.GateHook gatehooks = 8;
  int gatehooks_size() const;
  private:
  int _internal_gatehooks_size() const;

  public:
  void clear_gatehooks() ;
  ::bess::pb::GetModuleInfoResponse_GateHook* mutable_gatehooks(int index);
  ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_GateHook >*
      mutable_gatehooks();
  private:
  const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_GateHook>& _internal_gatehooks() const;
  ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_GateHook>* _internal_mutable_gatehooks();
  public:
  const ::bess::pb::GetModuleInfoResponse_GateHook& gatehooks(int index) const;
  ::bess::pb::GetModuleInfoResponse_GateHook* add_gatehooks();
  const ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_GateHook >&
      gatehooks() const;
  // uint64 igate = 1;
  void clear_igate() ;
  ::uint64_t igate() const;
  void set_igate(::uint64_t value);

  private:
  ::uint64_t _internal_igate() const;
  void _internal_set_igate(::uint64_t value);

  public:
  // uint64 cnt = 3;
  void clear_cnt() ;
  ::uint64_t cnt() const;
  void set_cnt(::uint64_t value);

  private:
  ::uint64_t _internal_cnt() const;
  void _internal_set_cnt(::uint64_t value);

  public:
  // uint64 pkts = 4;
  void clear_pkts() ;
  ::uint64_t pkts() const;
  void set_pkts(::uint64_t value);

  private:
  ::uint64_t _internal_pkts() const;
  void _internal_set_pkts(::uint64_t value);

  public:
  // uint64 bytes = 5;
  void clear_bytes() ;
  ::uint64_t bytes() const;
  void set_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_bytes() const;
  void _internal_set_bytes(::uint64_t value);

  public:
  // double timestamp = 6;
  void clear_timestamp() ;
  double timestamp() const;
  void set_timestamp(double value);

  private:
  double _internal_timestamp() const;
  void _internal_set_timestamp(double value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetModuleInfoResponse.IGate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_IGate_OGate > ogates_;
    ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_GateHook > gatehooks_;
    ::uint64_t igate_;
    ::uint64_t cnt_;
    ::uint64_t pkts_;
    ::uint64_t bytes_;
    double timestamp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetMclassInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetMclassInfoResponse) */ {
 public:
  inline GetMclassInfoResponse() : GetMclassInfoResponse(nullptr) {}
  ~GetMclassInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetMclassInfoResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetMclassInfoResponse(const GetMclassInfoResponse& from)
      : GetMclassInfoResponse(nullptr, from) {}
  GetMclassInfoResponse(GetMclassInfoResponse&& from) noexcept
    : GetMclassInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetMclassInfoResponse& operator=(const GetMclassInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMclassInfoResponse& operator=(GetMclassInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMclassInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMclassInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetMclassInfoResponse*>(
               &_GetMclassInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(GetMclassInfoResponse& a, GetMclassInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMclassInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMclassInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMclassInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMclassInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetMclassInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetMclassInfoResponse& from) {
    GetMclassInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetMclassInfoResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetMclassInfoResponse";
  }
  protected:
  explicit GetMclassInfoResponse(::google::protobuf::Arena* arena);
  GetMclassInfoResponse(::google::protobuf::Arena* arena, const GetMclassInfoResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmdsFieldNumber = 4,
    kCmdArgsFieldNumber = 5,
    kNameFieldNumber = 2,
    kHelpFieldNumber = 3,
    kErrorFieldNumber = 1,
  };
  // repeated string cmds = 4;
  int cmds_size() const;
  private:
  int _internal_cmds_size() const;

  public:
  void clear_cmds() ;
  const std::string& cmds(int index) const;
  std::string* mutable_cmds(int index);
  void set_cmds(int index, const std::string& value);
  void set_cmds(int index, std::string&& value);
  void set_cmds(int index, const char* value);
  void set_cmds(int index, const char* value, std::size_t size);
  void set_cmds(int index, absl::string_view value);
  std::string* add_cmds();
  void add_cmds(const std::string& value);
  void add_cmds(std::string&& value);
  void add_cmds(const char* value);
  void add_cmds(const char* value, std::size_t size);
  void add_cmds(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& cmds() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_cmds();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_cmds() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_cmds();

  public:
  // repeated string cmd_args = 5;
  int cmd_args_size() const;
  private:
  int _internal_cmd_args_size() const;

  public:
  void clear_cmd_args() ;
  const std::string& cmd_args(int index) const;
  std::string* mutable_cmd_args(int index);
  void set_cmd_args(int index, const std::string& value);
  void set_cmd_args(int index, std::string&& value);
  void set_cmd_args(int index, const char* value);
  void set_cmd_args(int index, const char* value, std::size_t size);
  void set_cmd_args(int index, absl::string_view value);
  std::string* add_cmd_args();
  void add_cmd_args(const std::string& value);
  void add_cmd_args(std::string&& value);
  void add_cmd_args(const char* value);
  void add_cmd_args(const char* value, std::size_t size);
  void add_cmd_args(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& cmd_args() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_cmd_args();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_cmd_args() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_cmd_args();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string help = 3;
  void clear_help() ;
  const std::string& help() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_help(Arg_&& arg, Args_... args);
  std::string* mutable_help();
  PROTOBUF_NODISCARD std::string* release_help();
  void set_allocated_help(std::string* value);

  private:
  const std::string& _internal_help() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_help(
      const std::string& value);
  std::string* _internal_mutable_help();

  public:
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetMclassInfoResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> cmds_;
    ::google::protobuf::RepeatedPtrField<std::string> cmd_args_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr help_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetLinkStatusResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetLinkStatusResponse) */ {
 public:
  inline GetLinkStatusResponse() : GetLinkStatusResponse(nullptr) {}
  ~GetLinkStatusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetLinkStatusResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetLinkStatusResponse(const GetLinkStatusResponse& from)
      : GetLinkStatusResponse(nullptr, from) {}
  GetLinkStatusResponse(GetLinkStatusResponse&& from) noexcept
    : GetLinkStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetLinkStatusResponse& operator=(const GetLinkStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLinkStatusResponse& operator=(GetLinkStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLinkStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLinkStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetLinkStatusResponse*>(
               &_GetLinkStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(GetLinkStatusResponse& a, GetLinkStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLinkStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLinkStatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLinkStatusResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLinkStatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetLinkStatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetLinkStatusResponse& from) {
    GetLinkStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetLinkStatusResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetLinkStatusResponse";
  }
  protected:
  explicit GetLinkStatusResponse(::google::protobuf::Arena* arena);
  GetLinkStatusResponse(::google::protobuf::Arena* arena, const GetLinkStatusResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kFullDuplexFieldNumber = 3,
    kAutonegFieldNumber = 4,
    kLinkUpFieldNumber = 5,
  };
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // uint32 speed = 2;
  void clear_speed() ;
  ::uint32_t speed() const;
  void set_speed(::uint32_t value);

  private:
  ::uint32_t _internal_speed() const;
  void _internal_set_speed(::uint32_t value);

  public:
  // bool full_duplex = 3;
  void clear_full_duplex() ;
  bool full_duplex() const;
  void set_full_duplex(bool value);

  private:
  bool _internal_full_duplex() const;
  void _internal_set_full_duplex(bool value);

  public:
  // bool autoneg = 4;
  void clear_autoneg() ;
  bool autoneg() const;
  void set_autoneg(bool value);

  private:
  bool _internal_autoneg() const;
  void _internal_set_autoneg(bool value);

  public:
  // bool link_up = 5;
  void clear_link_up() ;
  bool link_up() const;
  void set_link_up(bool value);

  private:
  bool _internal_link_up() const;
  void _internal_set_link_up(bool value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetLinkStatusResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::bess::pb::Error* error_;
    ::uint32_t speed_;
    bool full_duplex_;
    bool autoneg_;
    bool link_up_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetGateHookClassInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetGateHookClassInfoResponse) */ {
 public:
  inline GetGateHookClassInfoResponse() : GetGateHookClassInfoResponse(nullptr) {}
  ~GetGateHookClassInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetGateHookClassInfoResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetGateHookClassInfoResponse(const GetGateHookClassInfoResponse& from)
      : GetGateHookClassInfoResponse(nullptr, from) {}
  GetGateHookClassInfoResponse(GetGateHookClassInfoResponse&& from) noexcept
    : GetGateHookClassInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetGateHookClassInfoResponse& operator=(const GetGateHookClassInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetGateHookClassInfoResponse& operator=(GetGateHookClassInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetGateHookClassInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetGateHookClassInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetGateHookClassInfoResponse*>(
               &_GetGateHookClassInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(GetGateHookClassInfoResponse& a, GetGateHookClassInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetGateHookClassInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetGateHookClassInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetGateHookClassInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetGateHookClassInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetGateHookClassInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetGateHookClassInfoResponse& from) {
    GetGateHookClassInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetGateHookClassInfoResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetGateHookClassInfoResponse";
  }
  protected:
  explicit GetGateHookClassInfoResponse(::google::protobuf::Arena* arena);
  GetGateHookClassInfoResponse(::google::protobuf::Arena* arena, const GetGateHookClassInfoResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmdsFieldNumber = 4,
    kCmdArgsFieldNumber = 5,
    kNameFieldNumber = 2,
    kHelpFieldNumber = 3,
    kErrorFieldNumber = 1,
  };
  // repeated string cmds = 4;
  int cmds_size() const;
  private:
  int _internal_cmds_size() const;

  public:
  void clear_cmds() ;
  const std::string& cmds(int index) const;
  std::string* mutable_cmds(int index);
  void set_cmds(int index, const std::string& value);
  void set_cmds(int index, std::string&& value);
  void set_cmds(int index, const char* value);
  void set_cmds(int index, const char* value, std::size_t size);
  void set_cmds(int index, absl::string_view value);
  std::string* add_cmds();
  void add_cmds(const std::string& value);
  void add_cmds(std::string&& value);
  void add_cmds(const char* value);
  void add_cmds(const char* value, std::size_t size);
  void add_cmds(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& cmds() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_cmds();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_cmds() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_cmds();

  public:
  // repeated string cmd_args = 5;
  int cmd_args_size() const;
  private:
  int _internal_cmd_args_size() const;

  public:
  void clear_cmd_args() ;
  const std::string& cmd_args(int index) const;
  std::string* mutable_cmd_args(int index);
  void set_cmd_args(int index, const std::string& value);
  void set_cmd_args(int index, std::string&& value);
  void set_cmd_args(int index, const char* value);
  void set_cmd_args(int index, const char* value, std::size_t size);
  void set_cmd_args(int index, absl::string_view value);
  std::string* add_cmd_args();
  void add_cmd_args(const std::string& value);
  void add_cmd_args(std::string&& value);
  void add_cmd_args(const char* value);
  void add_cmd_args(const char* value, std::size_t size);
  void add_cmd_args(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& cmd_args() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_cmd_args();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_cmd_args() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_cmd_args();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string help = 3;
  void clear_help() ;
  const std::string& help() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_help(Arg_&& arg, Args_... args);
  std::string* mutable_help();
  PROTOBUF_NODISCARD std::string* release_help();
  void set_allocated_help(std::string* value);

  private:
  const std::string& _internal_help() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_help(
      const std::string& value);
  std::string* _internal_mutable_help();

  public:
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetGateHookClassInfoResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      65, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> cmds_;
    ::google::protobuf::RepeatedPtrField<std::string> cmd_args_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr help_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetDriverInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetDriverInfoResponse) */ {
 public:
  inline GetDriverInfoResponse() : GetDriverInfoResponse(nullptr) {}
  ~GetDriverInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetDriverInfoResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetDriverInfoResponse(const GetDriverInfoResponse& from)
      : GetDriverInfoResponse(nullptr, from) {}
  GetDriverInfoResponse(GetDriverInfoResponse&& from) noexcept
    : GetDriverInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetDriverInfoResponse& operator=(const GetDriverInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDriverInfoResponse& operator=(GetDriverInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDriverInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDriverInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetDriverInfoResponse*>(
               &_GetDriverInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetDriverInfoResponse& a, GetDriverInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDriverInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDriverInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDriverInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDriverInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetDriverInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetDriverInfoResponse& from) {
    GetDriverInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetDriverInfoResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetDriverInfoResponse";
  }
  protected:
  explicit GetDriverInfoResponse(::google::protobuf::Arena* arena);
  GetDriverInfoResponse(::google::protobuf::Arena* arena, const GetDriverInfoResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandsFieldNumber = 4,
    kNameFieldNumber = 2,
    kHelpFieldNumber = 3,
    kErrorFieldNumber = 1,
  };
  // repeated string commands = 4;
  int commands_size() const;
  private:
  int _internal_commands_size() const;

  public:
  void clear_commands() ;
  const std::string& commands(int index) const;
  std::string* mutable_commands(int index);
  void set_commands(int index, const std::string& value);
  void set_commands(int index, std::string&& value);
  void set_commands(int index, const char* value);
  void set_commands(int index, const char* value, std::size_t size);
  void set_commands(int index, absl::string_view value);
  std::string* add_commands();
  void add_commands(const std::string& value);
  void add_commands(std::string&& value);
  void add_commands(const char* value);
  void add_commands(const char* value, std::size_t size);
  void add_commands(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& commands() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_commands();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_commands() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_commands();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string help = 3;
  void clear_help() ;
  const std::string& help() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_help(Arg_&& arg, Args_... args);
  std::string* mutable_help();
  PROTOBUF_NODISCARD std::string* release_help();
  void set_allocated_help(std::string* value);

  private:
  const std::string& _internal_help() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_help(
      const std::string& value);
  std::string* _internal_mutable_help();

  public:
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetDriverInfoResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> commands_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr help_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GateHookInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GateHookInfo) */ {
 public:
  inline GateHookInfo() : GateHookInfo(nullptr) {}
  ~GateHookInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GateHookInfo(::google::protobuf::internal::ConstantInitialized);

  inline GateHookInfo(const GateHookInfo& from)
      : GateHookInfo(nullptr, from) {}
  GateHookInfo(GateHookInfo&& from) noexcept
    : GateHookInfo() {
    *this = ::std::move(from);
  }

  inline GateHookInfo& operator=(const GateHookInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GateHookInfo& operator=(GateHookInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GateHookInfo& default_instance() {
    return *internal_default_instance();
  }
  enum GateCase {
    kIgate = 4,
    kOgate = 5,
    GATE_NOT_SET = 0,
  };

  static inline const GateHookInfo* internal_default_instance() {
    return reinterpret_cast<const GateHookInfo*>(
               &_GateHookInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(GateHookInfo& a, GateHookInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GateHookInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GateHookInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GateHookInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GateHookInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GateHookInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GateHookInfo& from) {
    GateHookInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GateHookInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GateHookInfo";
  }
  protected:
  explicit GateHookInfo(::google::protobuf::Arena* arena);
  GateHookInfo(::google::protobuf::Arena* arena, const GateHookInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassNameFieldNumber = 1,
    kHookNameFieldNumber = 2,
    kModuleNameFieldNumber = 3,
    kArgFieldNumber = 6,
    kIgateFieldNumber = 4,
    kOgateFieldNumber = 5,
  };
  // string class_name = 1;
  void clear_class_name() ;
  const std::string& class_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_class_name(Arg_&& arg, Args_... args);
  std::string* mutable_class_name();
  PROTOBUF_NODISCARD std::string* release_class_name();
  void set_allocated_class_name(std::string* value);

  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(
      const std::string& value);
  std::string* _internal_mutable_class_name();

  public:
  // string hook_name = 2;
  void clear_hook_name() ;
  const std::string& hook_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hook_name(Arg_&& arg, Args_... args);
  std::string* mutable_hook_name();
  PROTOBUF_NODISCARD std::string* release_hook_name();
  void set_allocated_hook_name(std::string* value);

  private:
  const std::string& _internal_hook_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hook_name(
      const std::string& value);
  std::string* _internal_mutable_hook_name();

  public:
  // string module_name = 3;
  void clear_module_name() ;
  const std::string& module_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_module_name(Arg_&& arg, Args_... args);
  std::string* mutable_module_name();
  PROTOBUF_NODISCARD std::string* release_module_name();
  void set_allocated_module_name(std::string* value);

  private:
  const std::string& _internal_module_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_name(
      const std::string& value);
  std::string* _internal_mutable_module_name();

  public:
  // .google.protobuf.Any arg = 6;
  bool has_arg() const;
  void clear_arg() ;
  const ::google::protobuf::Any& arg() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_arg();
  ::google::protobuf::Any* mutable_arg();
  void set_allocated_arg(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_arg(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_arg();

  private:
  const ::google::protobuf::Any& _internal_arg() const;
  ::google::protobuf::Any* _internal_mutable_arg();

  public:
  // int64 igate = 4;
  bool has_igate() const;
  void clear_igate() ;
  ::int64_t igate() const;
  void set_igate(::int64_t value);

  private:
  ::int64_t _internal_igate() const;
  void _internal_set_igate(::int64_t value);

  public:
  // int64 ogate = 5;
  bool has_ogate() const;
  void clear_ogate() ;
  ::int64_t ogate() const;
  void set_ogate(::int64_t value);

  private:
  ::int64_t _internal_ogate() const;
  void _internal_set_ogate(::int64_t value);

  public:
  void clear_gate();
  GateCase gate_case() const;
  // @@protoc_insertion_point(class_scope:bess.pb.GateHookInfo)
 private:
  class _Internal;
  void set_has_igate();
  void set_has_ogate();

  inline bool has_gate() const;
  inline void clear_has_gate();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      59, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr class_name_;
    ::google::protobuf::internal::ArenaStringPtr hook_name_;
    ::google::protobuf::internal::ArenaStringPtr module_name_;
    ::google::protobuf::Any* arg_;
    union GateUnion {
      constexpr GateUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t igate_;
      ::int64_t ogate_;
    } gate_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class EmptyResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.EmptyResponse) */ {
 public:
  inline EmptyResponse() : EmptyResponse(nullptr) {}
  ~EmptyResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EmptyResponse(::google::protobuf::internal::ConstantInitialized);

  inline EmptyResponse(const EmptyResponse& from)
      : EmptyResponse(nullptr, from) {}
  EmptyResponse(EmptyResponse&& from) noexcept
    : EmptyResponse() {
    *this = ::std::move(from);
  }

  inline EmptyResponse& operator=(const EmptyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyResponse& operator=(EmptyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyResponse* internal_default_instance() {
    return reinterpret_cast<const EmptyResponse*>(
               &_EmptyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EmptyResponse& a, EmptyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EmptyResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EmptyResponse& from) {
    EmptyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EmptyResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.EmptyResponse";
  }
  protected:
  explicit EmptyResponse(::google::protobuf::Arena* arena);
  EmptyResponse(::google::protobuf::Arena* arena, const EmptyResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.EmptyResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class DumpMempoolResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.DumpMempoolResponse) */ {
 public:
  inline DumpMempoolResponse() : DumpMempoolResponse(nullptr) {}
  ~DumpMempoolResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DumpMempoolResponse(::google::protobuf::internal::ConstantInitialized);

  inline DumpMempoolResponse(const DumpMempoolResponse& from)
      : DumpMempoolResponse(nullptr, from) {}
  DumpMempoolResponse(DumpMempoolResponse&& from) noexcept
    : DumpMempoolResponse() {
    *this = ::std::move(from);
  }

  inline DumpMempoolResponse& operator=(const DumpMempoolResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DumpMempoolResponse& operator=(DumpMempoolResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DumpMempoolResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DumpMempoolResponse* internal_default_instance() {
    return reinterpret_cast<const DumpMempoolResponse*>(
               &_DumpMempoolResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(DumpMempoolResponse& a, DumpMempoolResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DumpMempoolResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DumpMempoolResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DumpMempoolResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DumpMempoolResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DumpMempoolResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DumpMempoolResponse& from) {
    DumpMempoolResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DumpMempoolResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.DumpMempoolResponse";
  }
  protected:
  explicit DumpMempoolResponse(::google::protobuf::Arena* arena);
  DumpMempoolResponse(::google::protobuf::Arena* arena, const DumpMempoolResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDumpsFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated .bess.pb.MempoolDump dumps = 2;
  int dumps_size() const;
  private:
  int _internal_dumps_size() const;

  public:
  void clear_dumps() ;
  ::bess::pb::MempoolDump* mutable_dumps(int index);
  ::google::protobuf::RepeatedPtrField< ::bess::pb::MempoolDump >*
      mutable_dumps();
  private:
  const ::google::protobuf::RepeatedPtrField<::bess::pb::MempoolDump>& _internal_dumps() const;
  ::google::protobuf::RepeatedPtrField<::bess::pb::MempoolDump>* _internal_mutable_dumps();
  public:
  const ::bess::pb::MempoolDump& dumps(int index) const;
  ::bess::pb::MempoolDump* add_dumps();
  const ::google::protobuf::RepeatedPtrField< ::bess::pb::MempoolDump >&
      dumps() const;
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.DumpMempoolResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::bess::pb::MempoolDump > dumps_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class CreatePortResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.CreatePortResponse) */ {
 public:
  inline CreatePortResponse() : CreatePortResponse(nullptr) {}
  ~CreatePortResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreatePortResponse(::google::protobuf::internal::ConstantInitialized);

  inline CreatePortResponse(const CreatePortResponse& from)
      : CreatePortResponse(nullptr, from) {}
  CreatePortResponse(CreatePortResponse&& from) noexcept
    : CreatePortResponse() {
    *this = ::std::move(from);
  }

  inline CreatePortResponse& operator=(const CreatePortResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePortResponse& operator=(CreatePortResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePortResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePortResponse* internal_default_instance() {
    return reinterpret_cast<const CreatePortResponse*>(
               &_CreatePortResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CreatePortResponse& a, CreatePortResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePortResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePortResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatePortResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatePortResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreatePortResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreatePortResponse& from) {
    CreatePortResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreatePortResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.CreatePortResponse";
  }
  protected:
  explicit CreatePortResponse(::google::protobuf::Arena* arena);
  CreatePortResponse(::google::protobuf::Arena* arena, const CreatePortResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kMacAddrFieldNumber = 3,
    kErrorFieldNumber = 1,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string mac_addr = 3;
  void clear_mac_addr() ;
  const std::string& mac_addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mac_addr(Arg_&& arg, Args_... args);
  std::string* mutable_mac_addr();
  PROTOBUF_NODISCARD std::string* release_mac_addr();
  void set_allocated_mac_addr(std::string* value);

  private:
  const std::string& _internal_mac_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_addr(
      const std::string& value);
  std::string* _internal_mutable_mac_addr();

  public:
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.CreatePortResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr mac_addr_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class CreatePortRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.CreatePortRequest) */ {
 public:
  inline CreatePortRequest() : CreatePortRequest(nullptr) {}
  ~CreatePortRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreatePortRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreatePortRequest(const CreatePortRequest& from)
      : CreatePortRequest(nullptr, from) {}
  CreatePortRequest(CreatePortRequest&& from) noexcept
    : CreatePortRequest() {
    *this = ::std::move(from);
  }

  inline CreatePortRequest& operator=(const CreatePortRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePortRequest& operator=(CreatePortRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePortRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePortRequest* internal_default_instance() {
    return reinterpret_cast<const CreatePortRequest*>(
               &_CreatePortRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CreatePortRequest& a, CreatePortRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePortRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePortRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatePortRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatePortRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreatePortRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreatePortRequest& from) {
    CreatePortRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreatePortRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.CreatePortRequest";
  }
  protected:
  explicit CreatePortRequest(::google::protobuf::Arena* arena);
  CreatePortRequest(::google::protobuf::Arena* arena, const CreatePortRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDriverFieldNumber = 2,
    kArgFieldNumber = 7,
    kNumIncQFieldNumber = 3,
    kNumOutQFieldNumber = 4,
    kSizeIncQFieldNumber = 5,
    kSizeOutQFieldNumber = 6,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string driver = 2;
  void clear_driver() ;
  const std::string& driver() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_driver(Arg_&& arg, Args_... args);
  std::string* mutable_driver();
  PROTOBUF_NODISCARD std::string* release_driver();
  void set_allocated_driver(std::string* value);

  private:
  const std::string& _internal_driver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver(
      const std::string& value);
  std::string* _internal_mutable_driver();

  public:
  // .google.protobuf.Any arg = 7;
  bool has_arg() const;
  void clear_arg() ;
  const ::google::protobuf::Any& arg() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_arg();
  ::google::protobuf::Any* mutable_arg();
  void set_allocated_arg(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_arg(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_arg();

  private:
  const ::google::protobuf::Any& _internal_arg() const;
  ::google::protobuf::Any* _internal_mutable_arg();

  public:
  // uint64 num_inc_q = 3;
  void clear_num_inc_q() ;
  ::uint64_t num_inc_q() const;
  void set_num_inc_q(::uint64_t value);

  private:
  ::uint64_t _internal_num_inc_q() const;
  void _internal_set_num_inc_q(::uint64_t value);

  public:
  // uint64 num_out_q = 4;
  void clear_num_out_q() ;
  ::uint64_t num_out_q() const;
  void set_num_out_q(::uint64_t value);

  private:
  ::uint64_t _internal_num_out_q() const;
  void _internal_set_num_out_q(::uint64_t value);

  public:
  // uint64 size_inc_q = 5;
  void clear_size_inc_q() ;
  ::uint64_t size_inc_q() const;
  void set_size_inc_q(::uint64_t value);

  private:
  ::uint64_t _internal_size_inc_q() const;
  void _internal_set_size_inc_q(::uint64_t value);

  public:
  // uint64 size_out_q = 6;
  void clear_size_out_q() ;
  ::uint64_t size_out_q() const;
  void set_size_out_q(::uint64_t value);

  private:
  ::uint64_t _internal_size_out_q() const;
  void _internal_set_size_out_q(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.CreatePortRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr driver_;
    ::google::protobuf::Any* arg_;
    ::uint64_t num_inc_q_;
    ::uint64_t num_out_q_;
    ::uint64_t size_inc_q_;
    ::uint64_t size_out_q_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class CreateModuleResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.CreateModuleResponse) */ {
 public:
  inline CreateModuleResponse() : CreateModuleResponse(nullptr) {}
  ~CreateModuleResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateModuleResponse(::google::protobuf::internal::ConstantInitialized);

  inline CreateModuleResponse(const CreateModuleResponse& from)
      : CreateModuleResponse(nullptr, from) {}
  CreateModuleResponse(CreateModuleResponse&& from) noexcept
    : CreateModuleResponse() {
    *this = ::std::move(from);
  }

  inline CreateModuleResponse& operator=(const CreateModuleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateModuleResponse& operator=(CreateModuleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateModuleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateModuleResponse* internal_default_instance() {
    return reinterpret_cast<const CreateModuleResponse*>(
               &_CreateModuleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(CreateModuleResponse& a, CreateModuleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateModuleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateModuleResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateModuleResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateModuleResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateModuleResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateModuleResponse& from) {
    CreateModuleResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateModuleResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.CreateModuleResponse";
  }
  protected:
  explicit CreateModuleResponse(::google::protobuf::Arena* arena);
  CreateModuleResponse(::google::protobuf::Arena* arena, const CreateModuleResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.CreateModuleResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class CreateModuleRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.CreateModuleRequest) */ {
 public:
  inline CreateModuleRequest() : CreateModuleRequest(nullptr) {}
  ~CreateModuleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateModuleRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreateModuleRequest(const CreateModuleRequest& from)
      : CreateModuleRequest(nullptr, from) {}
  CreateModuleRequest(CreateModuleRequest&& from) noexcept
    : CreateModuleRequest() {
    *this = ::std::move(from);
  }

  inline CreateModuleRequest& operator=(const CreateModuleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateModuleRequest& operator=(CreateModuleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateModuleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateModuleRequest* internal_default_instance() {
    return reinterpret_cast<const CreateModuleRequest*>(
               &_CreateModuleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(CreateModuleRequest& a, CreateModuleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateModuleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateModuleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateModuleRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateModuleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateModuleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateModuleRequest& from) {
    CreateModuleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateModuleRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.CreateModuleRequest";
  }
  protected:
  explicit CreateModuleRequest(::google::protobuf::Arena* arena);
  CreateModuleRequest(::google::protobuf::Arena* arena, const CreateModuleRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kMclassFieldNumber = 2,
    kArgFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string mclass = 2;
  void clear_mclass() ;
  const std::string& mclass() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mclass(Arg_&& arg, Args_... args);
  std::string* mutable_mclass();
  PROTOBUF_NODISCARD std::string* release_mclass();
  void set_allocated_mclass(std::string* value);

  private:
  const std::string& _internal_mclass() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mclass(
      const std::string& value);
  std::string* _internal_mutable_mclass();

  public:
  // .google.protobuf.Any arg = 3;
  bool has_arg() const;
  void clear_arg() ;
  const ::google::protobuf::Any& arg() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_arg();
  ::google::protobuf::Any* mutable_arg();
  void set_allocated_arg(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_arg(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_arg();

  private:
  const ::google::protobuf::Any& _internal_arg() const;
  ::google::protobuf::Any* _internal_mutable_arg();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.CreateModuleRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr mclass_;
    ::google::protobuf::Any* arg_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ConfigureResumeHookRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ConfigureResumeHookRequest) */ {
 public:
  inline ConfigureResumeHookRequest() : ConfigureResumeHookRequest(nullptr) {}
  ~ConfigureResumeHookRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConfigureResumeHookRequest(::google::protobuf::internal::ConstantInitialized);

  inline ConfigureResumeHookRequest(const ConfigureResumeHookRequest& from)
      : ConfigureResumeHookRequest(nullptr, from) {}
  ConfigureResumeHookRequest(ConfigureResumeHookRequest&& from) noexcept
    : ConfigureResumeHookRequest() {
    *this = ::std::move(from);
  }

  inline ConfigureResumeHookRequest& operator=(const ConfigureResumeHookRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigureResumeHookRequest& operator=(ConfigureResumeHookRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigureResumeHookRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigureResumeHookRequest* internal_default_instance() {
    return reinterpret_cast<const ConfigureResumeHookRequest*>(
               &_ConfigureResumeHookRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(ConfigureResumeHookRequest& a, ConfigureResumeHookRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigureResumeHookRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigureResumeHookRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigureResumeHookRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigureResumeHookRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConfigureResumeHookRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ConfigureResumeHookRequest& from) {
    ConfigureResumeHookRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConfigureResumeHookRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ConfigureResumeHookRequest";
  }
  protected:
  explicit ConfigureResumeHookRequest(::google::protobuf::Arena* arena);
  ConfigureResumeHookRequest(::google::protobuf::Arena* arena, const ConfigureResumeHookRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHookNameFieldNumber = 1,
    kArgFieldNumber = 3,
    kEnableFieldNumber = 2,
  };
  // string hook_name = 1;
  void clear_hook_name() ;
  const std::string& hook_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hook_name(Arg_&& arg, Args_... args);
  std::string* mutable_hook_name();
  PROTOBUF_NODISCARD std::string* release_hook_name();
  void set_allocated_hook_name(std::string* value);

  private:
  const std::string& _internal_hook_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hook_name(
      const std::string& value);
  std::string* _internal_mutable_hook_name();

  public:
  // .google.protobuf.Any arg = 3;
  bool has_arg() const;
  void clear_arg() ;
  const ::google::protobuf::Any& arg() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_arg();
  ::google::protobuf::Any* mutable_arg();
  void set_allocated_arg(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_arg(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_arg();

  private:
  const ::google::protobuf::Any& _internal_arg() const;
  ::google::protobuf::Any* _internal_mutable_arg();

  public:
  // bool enable = 2;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ConfigureResumeHookRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr hook_name_;
    ::google::protobuf::Any* arg_;
    bool enable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ConfigureGateHookResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ConfigureGateHookResponse) */ {
 public:
  inline ConfigureGateHookResponse() : ConfigureGateHookResponse(nullptr) {}
  ~ConfigureGateHookResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConfigureGateHookResponse(::google::protobuf::internal::ConstantInitialized);

  inline ConfigureGateHookResponse(const ConfigureGateHookResponse& from)
      : ConfigureGateHookResponse(nullptr, from) {}
  ConfigureGateHookResponse(ConfigureGateHookResponse&& from) noexcept
    : ConfigureGateHookResponse() {
    *this = ::std::move(from);
  }

  inline ConfigureGateHookResponse& operator=(const ConfigureGateHookResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigureGateHookResponse& operator=(ConfigureGateHookResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigureGateHookResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigureGateHookResponse* internal_default_instance() {
    return reinterpret_cast<const ConfigureGateHookResponse*>(
               &_ConfigureGateHookResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(ConfigureGateHookResponse& a, ConfigureGateHookResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigureGateHookResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigureGateHookResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigureGateHookResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigureGateHookResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConfigureGateHookResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ConfigureGateHookResponse& from) {
    ConfigureGateHookResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConfigureGateHookResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ConfigureGateHookResponse";
  }
  protected:
  explicit ConfigureGateHookResponse(::google::protobuf::Arena* arena);
  ConfigureGateHookResponse(::google::protobuf::Arena* arena, const ConfigureGateHookResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ConfigureGateHookResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class CommandResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.CommandResponse) */ {
 public:
  inline CommandResponse() : CommandResponse(nullptr) {}
  ~CommandResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandResponse(const CommandResponse& from)
      : CommandResponse(nullptr, from) {}
  CommandResponse(CommandResponse&& from) noexcept
    : CommandResponse() {
    *this = ::std::move(from);
  }

  inline CommandResponse& operator=(const CommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandResponse& operator=(CommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandResponse* internal_default_instance() {
    return reinterpret_cast<const CommandResponse*>(
               &_CommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(CommandResponse& a, CommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CommandResponse& from) {
    CommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.CommandResponse";
  }
  protected:
  explicit CommandResponse(::google::protobuf::Arena* arena);
  CommandResponse(::google::protobuf::Arena* arena, const CommandResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // .google.protobuf.Any data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::google::protobuf::Any& data() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_data();
  ::google::protobuf::Any* mutable_data();
  void set_allocated_data(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_data(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_data();

  private:
  const ::google::protobuf::Any& _internal_data() const;
  ::google::protobuf::Any* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.CommandResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::bess::pb::Error* error_;
    ::google::protobuf::Any* data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class CommandRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.CommandRequest) */ {
 public:
  inline CommandRequest() : CommandRequest(nullptr) {}
  ~CommandRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandRequest(::google::protobuf::internal::ConstantInitialized);

  inline CommandRequest(const CommandRequest& from)
      : CommandRequest(nullptr, from) {}
  CommandRequest(CommandRequest&& from) noexcept
    : CommandRequest() {
    *this = ::std::move(from);
  }

  inline CommandRequest& operator=(const CommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandRequest& operator=(CommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandRequest* internal_default_instance() {
    return reinterpret_cast<const CommandRequest*>(
               &_CommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(CommandRequest& a, CommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CommandRequest& from) {
    CommandRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.CommandRequest";
  }
  protected:
  explicit CommandRequest(::google::protobuf::Arena* arena);
  CommandRequest(::google::protobuf::Arena* arena, const CommandRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCmdFieldNumber = 2,
    kArgFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string cmd = 2;
  void clear_cmd() ;
  const std::string& cmd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cmd(Arg_&& arg, Args_... args);
  std::string* mutable_cmd();
  PROTOBUF_NODISCARD std::string* release_cmd();
  void set_allocated_cmd(std::string* value);

  private:
  const std::string& _internal_cmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd(
      const std::string& value);
  std::string* _internal_mutable_cmd();

  public:
  // .google.protobuf.Any arg = 3;
  bool has_arg() const;
  void clear_arg() ;
  const ::google::protobuf::Any& arg() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_arg();
  ::google::protobuf::Any* mutable_arg();
  void set_allocated_arg(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_arg(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_arg();

  private:
  const ::google::protobuf::Any& _internal_arg() const;
  ::google::protobuf::Any* _internal_mutable_arg();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.CommandRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr cmd_;
    ::google::protobuf::Any* arg_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class CheckSchedulingConstraintsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.CheckSchedulingConstraintsResponse) */ {
 public:
  inline CheckSchedulingConstraintsResponse() : CheckSchedulingConstraintsResponse(nullptr) {}
  ~CheckSchedulingConstraintsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CheckSchedulingConstraintsResponse(::google::protobuf::internal::ConstantInitialized);

  inline CheckSchedulingConstraintsResponse(const CheckSchedulingConstraintsResponse& from)
      : CheckSchedulingConstraintsResponse(nullptr, from) {}
  CheckSchedulingConstraintsResponse(CheckSchedulingConstraintsResponse&& from) noexcept
    : CheckSchedulingConstraintsResponse() {
    *this = ::std::move(from);
  }

  inline CheckSchedulingConstraintsResponse& operator=(const CheckSchedulingConstraintsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckSchedulingConstraintsResponse& operator=(CheckSchedulingConstraintsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckSchedulingConstraintsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckSchedulingConstraintsResponse* internal_default_instance() {
    return reinterpret_cast<const CheckSchedulingConstraintsResponse*>(
               &_CheckSchedulingConstraintsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CheckSchedulingConstraintsResponse& a, CheckSchedulingConstraintsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckSchedulingConstraintsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckSchedulingConstraintsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckSchedulingConstraintsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckSchedulingConstraintsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckSchedulingConstraintsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CheckSchedulingConstraintsResponse& from) {
    CheckSchedulingConstraintsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CheckSchedulingConstraintsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.CheckSchedulingConstraintsResponse";
  }
  protected:
  explicit CheckSchedulingConstraintsResponse(::google::protobuf::Arena* arena);
  CheckSchedulingConstraintsResponse(::google::protobuf::Arena* arena, const CheckSchedulingConstraintsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ViolatingClass = CheckSchedulingConstraintsResponse_ViolatingClass;
  using ViolatingModule = CheckSchedulingConstraintsResponse_ViolatingModule;

  // accessors -------------------------------------------------------

  enum : int {
    kViolationsFieldNumber = 3,
    kModulesFieldNumber = 4,
    kErrorFieldNumber = 1,
    kFatalFieldNumber = 2,
  };
  // repeated .bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass violations = 3;
  int violations_size() const;
  private:
  int _internal_violations_size() const;

  public:
  void clear_violations() ;
  ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass* mutable_violations(int index);
  ::google::protobuf::RepeatedPtrField< ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass >*
      mutable_violations();
  private:
  const ::google::protobuf::RepeatedPtrField<::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass>& _internal_violations() const;
  ::google::protobuf::RepeatedPtrField<::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass>* _internal_mutable_violations();
  public:
  const ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass& violations(int index) const;
  ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass* add_violations();
  const ::google::protobuf::RepeatedPtrField< ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass >&
      violations() const;
  // repeated .bess.pb.CheckSchedulingConstraintsResponse.ViolatingModule modules = 4;
  int modules_size() const;
  private:
  int _internal_modules_size() const;

  public:
  void clear_modules() ;
  ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule* mutable_modules(int index);
  ::google::protobuf::RepeatedPtrField< ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule >*
      mutable_modules();
  private:
  const ::google::protobuf::RepeatedPtrField<::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule>& _internal_modules() const;
  ::google::protobuf::RepeatedPtrField<::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule>* _internal_mutable_modules();
  public:
  const ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule& modules(int index) const;
  ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule* add_modules();
  const ::google::protobuf::RepeatedPtrField< ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule >&
      modules() const;
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // bool fatal = 2;
  void clear_fatal() ;
  bool fatal() const;
  void set_fatal(bool value);

  private:
  bool _internal_fatal() const;
  void _internal_set_fatal(bool value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.CheckSchedulingConstraintsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass > violations_;
    ::google::protobuf::RepeatedPtrField< ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule > modules_;
    ::bess::pb::Error* error_;
    bool fatal_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class UpdateTcParentRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.UpdateTcParentRequest) */ {
 public:
  inline UpdateTcParentRequest() : UpdateTcParentRequest(nullptr) {}
  ~UpdateTcParentRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateTcParentRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateTcParentRequest(const UpdateTcParentRequest& from)
      : UpdateTcParentRequest(nullptr, from) {}
  UpdateTcParentRequest(UpdateTcParentRequest&& from) noexcept
    : UpdateTcParentRequest() {
    *this = ::std::move(from);
  }

  inline UpdateTcParentRequest& operator=(const UpdateTcParentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTcParentRequest& operator=(UpdateTcParentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTcParentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTcParentRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateTcParentRequest*>(
               &_UpdateTcParentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UpdateTcParentRequest& a, UpdateTcParentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateTcParentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTcParentRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTcParentRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateTcParentRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateTcParentRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateTcParentRequest& from) {
    UpdateTcParentRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateTcParentRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.UpdateTcParentRequest";
  }
  protected:
  explicit UpdateTcParentRequest(::google::protobuf::Arena* arena);
  UpdateTcParentRequest(::google::protobuf::Arena* arena, const UpdateTcParentRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassFieldNumber = 1,
  };
  // .bess.pb.TrafficClass class = 1;
  bool has_class_() const;
  void clear_class_() ;
  const ::bess::pb::TrafficClass& class_() const;
  PROTOBUF_NODISCARD ::bess::pb::TrafficClass* release_class_();
  ::bess::pb::TrafficClass* mutable_class_();
  void set_allocated_class_(::bess::pb::TrafficClass* value);
  void unsafe_arena_set_allocated_class_(::bess::pb::TrafficClass* value);
  ::bess::pb::TrafficClass* unsafe_arena_release_class_();

  private:
  const ::bess::pb::TrafficClass& _internal_class_() const;
  ::bess::pb::TrafficClass* _internal_mutable_class_();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.UpdateTcParentRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::bess::pb::TrafficClass* class__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class UpdateTcParamsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.UpdateTcParamsRequest) */ {
 public:
  inline UpdateTcParamsRequest() : UpdateTcParamsRequest(nullptr) {}
  ~UpdateTcParamsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateTcParamsRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateTcParamsRequest(const UpdateTcParamsRequest& from)
      : UpdateTcParamsRequest(nullptr, from) {}
  UpdateTcParamsRequest(UpdateTcParamsRequest&& from) noexcept
    : UpdateTcParamsRequest() {
    *this = ::std::move(from);
  }

  inline UpdateTcParamsRequest& operator=(const UpdateTcParamsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTcParamsRequest& operator=(UpdateTcParamsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTcParamsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTcParamsRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateTcParamsRequest*>(
               &_UpdateTcParamsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UpdateTcParamsRequest& a, UpdateTcParamsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateTcParamsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTcParamsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTcParamsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateTcParamsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateTcParamsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateTcParamsRequest& from) {
    UpdateTcParamsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateTcParamsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.UpdateTcParamsRequest";
  }
  protected:
  explicit UpdateTcParamsRequest(::google::protobuf::Arena* arena);
  UpdateTcParamsRequest(::google::protobuf::Arena* arena, const UpdateTcParamsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassFieldNumber = 1,
  };
  // .bess.pb.TrafficClass class = 1;
  bool has_class_() const;
  void clear_class_() ;
  const ::bess::pb::TrafficClass& class_() const;
  PROTOBUF_NODISCARD ::bess::pb::TrafficClass* release_class_();
  ::bess::pb::TrafficClass* mutable_class_();
  void set_allocated_class_(::bess::pb::TrafficClass* value);
  void unsafe_arena_set_allocated_class_(::bess::pb::TrafficClass* value);
  ::bess::pb::TrafficClass* unsafe_arena_release_class_();

  private:
  const ::bess::pb::TrafficClass& _internal_class_() const;
  ::bess::pb::TrafficClass* _internal_mutable_class_();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.UpdateTcParamsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::bess::pb::TrafficClass* class__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ListTcsResponse_TrafficClassStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ListTcsResponse.TrafficClassStatus) */ {
 public:
  inline ListTcsResponse_TrafficClassStatus() : ListTcsResponse_TrafficClassStatus(nullptr) {}
  ~ListTcsResponse_TrafficClassStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListTcsResponse_TrafficClassStatus(::google::protobuf::internal::ConstantInitialized);

  inline ListTcsResponse_TrafficClassStatus(const ListTcsResponse_TrafficClassStatus& from)
      : ListTcsResponse_TrafficClassStatus(nullptr, from) {}
  ListTcsResponse_TrafficClassStatus(ListTcsResponse_TrafficClassStatus&& from) noexcept
    : ListTcsResponse_TrafficClassStatus() {
    *this = ::std::move(from);
  }

  inline ListTcsResponse_TrafficClassStatus& operator=(const ListTcsResponse_TrafficClassStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTcsResponse_TrafficClassStatus& operator=(ListTcsResponse_TrafficClassStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTcsResponse_TrafficClassStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTcsResponse_TrafficClassStatus* internal_default_instance() {
    return reinterpret_cast<const ListTcsResponse_TrafficClassStatus*>(
               &_ListTcsResponse_TrafficClassStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ListTcsResponse_TrafficClassStatus& a, ListTcsResponse_TrafficClassStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTcsResponse_TrafficClassStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTcsResponse_TrafficClassStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTcsResponse_TrafficClassStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTcsResponse_TrafficClassStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListTcsResponse_TrafficClassStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListTcsResponse_TrafficClassStatus& from) {
    ListTcsResponse_TrafficClassStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListTcsResponse_TrafficClassStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ListTcsResponse.TrafficClassStatus";
  }
  protected:
  explicit ListTcsResponse_TrafficClassStatus(::google::protobuf::Arena* arena);
  ListTcsResponse_TrafficClassStatus(::google::protobuf::Arena* arena, const ListTcsResponse_TrafficClassStatus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 2,
    kClassFieldNumber = 1,
  };
  // string parent = 2;
  void clear_parent() ;
  const std::string& parent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent(Arg_&& arg, Args_... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* value);

  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(
      const std::string& value);
  std::string* _internal_mutable_parent();

  public:
  // .bess.pb.TrafficClass class = 1;
  bool has_class_() const;
  void clear_class_() ;
  const ::bess::pb::TrafficClass& class_() const;
  PROTOBUF_NODISCARD ::bess::pb::TrafficClass* release_class_();
  ::bess::pb::TrafficClass* mutable_class_();
  void set_allocated_class_(::bess::pb::TrafficClass* value);
  void unsafe_arena_set_allocated_class_(::bess::pb::TrafficClass* value);
  ::bess::pb::TrafficClass* unsafe_arena_release_class_();

  private:
  const ::bess::pb::TrafficClass& _internal_class_() const;
  ::bess::pb::TrafficClass* _internal_mutable_class_();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ListTcsResponse.TrafficClassStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr parent_;
    ::bess::pb::TrafficClass* class__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ListPortsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ListPortsResponse) */ {
 public:
  inline ListPortsResponse() : ListPortsResponse(nullptr) {}
  ~ListPortsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListPortsResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListPortsResponse(const ListPortsResponse& from)
      : ListPortsResponse(nullptr, from) {}
  ListPortsResponse(ListPortsResponse&& from) noexcept
    : ListPortsResponse() {
    *this = ::std::move(from);
  }

  inline ListPortsResponse& operator=(const ListPortsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPortsResponse& operator=(ListPortsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPortsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPortsResponse* internal_default_instance() {
    return reinterpret_cast<const ListPortsResponse*>(
               &_ListPortsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ListPortsResponse& a, ListPortsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPortsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPortsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPortsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPortsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListPortsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListPortsResponse& from) {
    ListPortsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListPortsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ListPortsResponse";
  }
  protected:
  explicit ListPortsResponse(::google::protobuf::Arena* arena);
  ListPortsResponse(::google::protobuf::Arena* arena, const ListPortsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Port = ListPortsResponse_Port;

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated .bess.pb.ListPortsResponse.Port ports = 2;
  int ports_size() const;
  private:
  int _internal_ports_size() const;

  public:
  void clear_ports() ;
  ::bess::pb::ListPortsResponse_Port* mutable_ports(int index);
  ::google::protobuf::RepeatedPtrField< ::bess::pb::ListPortsResponse_Port >*
      mutable_ports();
  private:
  const ::google::protobuf::RepeatedPtrField<::bess::pb::ListPortsResponse_Port>& _internal_ports() const;
  ::google::protobuf::RepeatedPtrField<::bess::pb::ListPortsResponse_Port>* _internal_mutable_ports();
  public:
  const ::bess::pb::ListPortsResponse_Port& ports(int index) const;
  ::bess::pb::ListPortsResponse_Port* add_ports();
  const ::google::protobuf::RepeatedPtrField< ::bess::pb::ListPortsResponse_Port >&
      ports() const;
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ListPortsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::bess::pb::ListPortsResponse_Port > ports_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ListGateHooksResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ListGateHooksResponse) */ {
 public:
  inline ListGateHooksResponse() : ListGateHooksResponse(nullptr) {}
  ~ListGateHooksResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListGateHooksResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListGateHooksResponse(const ListGateHooksResponse& from)
      : ListGateHooksResponse(nullptr, from) {}
  ListGateHooksResponse(ListGateHooksResponse&& from) noexcept
    : ListGateHooksResponse() {
    *this = ::std::move(from);
  }

  inline ListGateHooksResponse& operator=(const ListGateHooksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListGateHooksResponse& operator=(ListGateHooksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListGateHooksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListGateHooksResponse* internal_default_instance() {
    return reinterpret_cast<const ListGateHooksResponse*>(
               &_ListGateHooksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(ListGateHooksResponse& a, ListGateHooksResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListGateHooksResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListGateHooksResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListGateHooksResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListGateHooksResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListGateHooksResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListGateHooksResponse& from) {
    ListGateHooksResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListGateHooksResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ListGateHooksResponse";
  }
  protected:
  explicit ListGateHooksResponse(::google::protobuf::Arena* arena);
  ListGateHooksResponse(::google::protobuf::Arena* arena, const ListGateHooksResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHooksFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated .bess.pb.GateHookInfo hooks = 2;
  int hooks_size() const;
  private:
  int _internal_hooks_size() const;

  public:
  void clear_hooks() ;
  ::bess::pb::GateHookInfo* mutable_hooks(int index);
  ::google::protobuf::RepeatedPtrField< ::bess::pb::GateHookInfo >*
      mutable_hooks();
  private:
  const ::google::protobuf::RepeatedPtrField<::bess::pb::GateHookInfo>& _internal_hooks() const;
  ::google::protobuf::RepeatedPtrField<::bess::pb::GateHookInfo>* _internal_mutable_hooks();
  public:
  const ::bess::pb::GateHookInfo& hooks(int index) const;
  ::bess::pb::GateHookInfo* add_hooks();
  const ::google::protobuf::RepeatedPtrField< ::bess::pb::GateHookInfo >&
      hooks() const;
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ListGateHooksResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::bess::pb::GateHookInfo > hooks_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GetModuleInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GetModuleInfoResponse) */ {
 public:
  inline GetModuleInfoResponse() : GetModuleInfoResponse(nullptr) {}
  ~GetModuleInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetModuleInfoResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetModuleInfoResponse(const GetModuleInfoResponse& from)
      : GetModuleInfoResponse(nullptr, from) {}
  GetModuleInfoResponse(GetModuleInfoResponse&& from) noexcept
    : GetModuleInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetModuleInfoResponse& operator=(const GetModuleInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModuleInfoResponse& operator=(GetModuleInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModuleInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModuleInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetModuleInfoResponse*>(
               &_GetModuleInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(GetModuleInfoResponse& a, GetModuleInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModuleInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModuleInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModuleInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModuleInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetModuleInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetModuleInfoResponse& from) {
    GetModuleInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetModuleInfoResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GetModuleInfoResponse";
  }
  protected:
  explicit GetModuleInfoResponse(::google::protobuf::Arena* arena);
  GetModuleInfoResponse(::google::protobuf::Arena* arena, const GetModuleInfoResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using GateHook = GetModuleInfoResponse_GateHook;
  using IGate = GetModuleInfoResponse_IGate;
  using OGate = GetModuleInfoResponse_OGate;
  using Attribute = GetModuleInfoResponse_Attribute;

  // accessors -------------------------------------------------------

  enum : int {
    kIgatesFieldNumber = 6,
    kOgatesFieldNumber = 7,
    kMetadataFieldNumber = 8,
    kNameFieldNumber = 2,
    kMclassFieldNumber = 3,
    kDescFieldNumber = 4,
    kErrorFieldNumber = 1,
    kDeadendsFieldNumber = 9,
  };
  // repeated .bess.pb.GetModuleInfoResponse.IGate igates = 6;
  int igates_size() const;
  private:
  int _internal_igates_size() const;

  public:
  void clear_igates() ;
  ::bess::pb::GetModuleInfoResponse_IGate* mutable_igates(int index);
  ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_IGate >*
      mutable_igates();
  private:
  const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_IGate>& _internal_igates() const;
  ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_IGate>* _internal_mutable_igates();
  public:
  const ::bess::pb::GetModuleInfoResponse_IGate& igates(int index) const;
  ::bess::pb::GetModuleInfoResponse_IGate* add_igates();
  const ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_IGate >&
      igates() const;
  // repeated .bess.pb.GetModuleInfoResponse.OGate ogates = 7;
  int ogates_size() const;
  private:
  int _internal_ogates_size() const;

  public:
  void clear_ogates() ;
  ::bess::pb::GetModuleInfoResponse_OGate* mutable_ogates(int index);
  ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_OGate >*
      mutable_ogates();
  private:
  const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_OGate>& _internal_ogates() const;
  ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_OGate>* _internal_mutable_ogates();
  public:
  const ::bess::pb::GetModuleInfoResponse_OGate& ogates(int index) const;
  ::bess::pb::GetModuleInfoResponse_OGate* add_ogates();
  const ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_OGate >&
      ogates() const;
  // repeated .bess.pb.GetModuleInfoResponse.Attribute metadata = 8;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  ::bess::pb::GetModuleInfoResponse_Attribute* mutable_metadata(int index);
  ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_Attribute >*
      mutable_metadata();
  private:
  const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_Attribute>& _internal_metadata() const;
  ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_Attribute>* _internal_mutable_metadata();
  public:
  const ::bess::pb::GetModuleInfoResponse_Attribute& metadata(int index) const;
  ::bess::pb::GetModuleInfoResponse_Attribute* add_metadata();
  const ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_Attribute >&
      metadata() const;
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string mclass = 3;
  void clear_mclass() ;
  const std::string& mclass() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mclass(Arg_&& arg, Args_... args);
  std::string* mutable_mclass();
  PROTOBUF_NODISCARD std::string* release_mclass();
  void set_allocated_mclass(std::string* value);

  private:
  const std::string& _internal_mclass() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mclass(
      const std::string& value);
  std::string* _internal_mutable_mclass();

  public:
  // string desc = 4;
  void clear_desc() ;
  const std::string& desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_desc(Arg_&& arg, Args_... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* value);

  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(
      const std::string& value);
  std::string* _internal_mutable_desc();

  public:
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // uint64 deadends = 9;
  void clear_deadends() ;
  ::uint64_t deadends() const;
  void set_deadends(::uint64_t value);

  private:
  ::uint64_t _internal_deadends() const;
  void _internal_set_deadends(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GetModuleInfoResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 8, 4,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_IGate > igates_;
    ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_OGate > ogates_;
    ::google::protobuf::RepeatedPtrField< ::bess::pb::GetModuleInfoResponse_Attribute > metadata_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr mclass_;
    ::google::protobuf::internal::ArenaStringPtr desc_;
    ::bess::pb::Error* error_;
    ::uint64_t deadends_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class GateHookCommandRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.GateHookCommandRequest) */ {
 public:
  inline GateHookCommandRequest() : GateHookCommandRequest(nullptr) {}
  ~GateHookCommandRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GateHookCommandRequest(::google::protobuf::internal::ConstantInitialized);

  inline GateHookCommandRequest(const GateHookCommandRequest& from)
      : GateHookCommandRequest(nullptr, from) {}
  GateHookCommandRequest(GateHookCommandRequest&& from) noexcept
    : GateHookCommandRequest() {
    *this = ::std::move(from);
  }

  inline GateHookCommandRequest& operator=(const GateHookCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GateHookCommandRequest& operator=(GateHookCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GateHookCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GateHookCommandRequest* internal_default_instance() {
    return reinterpret_cast<const GateHookCommandRequest*>(
               &_GateHookCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(GateHookCommandRequest& a, GateHookCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GateHookCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GateHookCommandRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GateHookCommandRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GateHookCommandRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GateHookCommandRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GateHookCommandRequest& from) {
    GateHookCommandRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GateHookCommandRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.GateHookCommandRequest";
  }
  protected:
  explicit GateHookCommandRequest(::google::protobuf::Arena* arena);
  GateHookCommandRequest(::google::protobuf::Arena* arena, const GateHookCommandRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmdFieldNumber = 2,
    kHookFieldNumber = 1,
  };
  // string cmd = 2;
  void clear_cmd() ;
  const std::string& cmd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cmd(Arg_&& arg, Args_... args);
  std::string* mutable_cmd();
  PROTOBUF_NODISCARD std::string* release_cmd();
  void set_allocated_cmd(std::string* value);

  private:
  const std::string& _internal_cmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd(
      const std::string& value);
  std::string* _internal_mutable_cmd();

  public:
  // .bess.pb.GateHookInfo hook = 1;
  bool has_hook() const;
  void clear_hook() ;
  const ::bess::pb::GateHookInfo& hook() const;
  PROTOBUF_NODISCARD ::bess::pb::GateHookInfo* release_hook();
  ::bess::pb::GateHookInfo* mutable_hook();
  void set_allocated_hook(::bess::pb::GateHookInfo* value);
  void unsafe_arena_set_allocated_hook(::bess::pb::GateHookInfo* value);
  ::bess::pb::GateHookInfo* unsafe_arena_release_hook();

  private:
  const ::bess::pb::GateHookInfo& _internal_hook() const;
  ::bess::pb::GateHookInfo* _internal_mutable_hook();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.GateHookCommandRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr cmd_;
    ::bess::pb::GateHookInfo* hook_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ConfigureGateHookRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ConfigureGateHookRequest) */ {
 public:
  inline ConfigureGateHookRequest() : ConfigureGateHookRequest(nullptr) {}
  ~ConfigureGateHookRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConfigureGateHookRequest(::google::protobuf::internal::ConstantInitialized);

  inline ConfigureGateHookRequest(const ConfigureGateHookRequest& from)
      : ConfigureGateHookRequest(nullptr, from) {}
  ConfigureGateHookRequest(ConfigureGateHookRequest&& from) noexcept
    : ConfigureGateHookRequest() {
    *this = ::std::move(from);
  }

  inline ConfigureGateHookRequest& operator=(const ConfigureGateHookRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigureGateHookRequest& operator=(ConfigureGateHookRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigureGateHookRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigureGateHookRequest* internal_default_instance() {
    return reinterpret_cast<const ConfigureGateHookRequest*>(
               &_ConfigureGateHookRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(ConfigureGateHookRequest& a, ConfigureGateHookRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigureGateHookRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigureGateHookRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigureGateHookRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigureGateHookRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConfigureGateHookRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ConfigureGateHookRequest& from) {
    ConfigureGateHookRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ConfigureGateHookRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ConfigureGateHookRequest";
  }
  protected:
  explicit ConfigureGateHookRequest(::google::protobuf::Arena* arena);
  ConfigureGateHookRequest(::google::protobuf::Arena* arena, const ConfigureGateHookRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHookFieldNumber = 1,
    kEnableFieldNumber = 2,
  };
  // .bess.pb.GateHookInfo hook = 1;
  bool has_hook() const;
  void clear_hook() ;
  const ::bess::pb::GateHookInfo& hook() const;
  PROTOBUF_NODISCARD ::bess::pb::GateHookInfo* release_hook();
  ::bess::pb::GateHookInfo* mutable_hook();
  void set_allocated_hook(::bess::pb::GateHookInfo* value);
  void unsafe_arena_set_allocated_hook(::bess::pb::GateHookInfo* value);
  ::bess::pb::GateHookInfo* unsafe_arena_release_hook();

  private:
  const ::bess::pb::GateHookInfo& _internal_hook() const;
  ::bess::pb::GateHookInfo* _internal_mutable_hook();

  public:
  // bool enable = 2;
  void clear_enable() ;
  bool enable() const;
  void set_enable(bool value);

  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ConfigureGateHookRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::bess::pb::GateHookInfo* hook_;
    bool enable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class AddTcRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.AddTcRequest) */ {
 public:
  inline AddTcRequest() : AddTcRequest(nullptr) {}
  ~AddTcRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddTcRequest(::google::protobuf::internal::ConstantInitialized);

  inline AddTcRequest(const AddTcRequest& from)
      : AddTcRequest(nullptr, from) {}
  AddTcRequest(AddTcRequest&& from) noexcept
    : AddTcRequest() {
    *this = ::std::move(from);
  }

  inline AddTcRequest& operator=(const AddTcRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddTcRequest& operator=(AddTcRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddTcRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddTcRequest* internal_default_instance() {
    return reinterpret_cast<const AddTcRequest*>(
               &_AddTcRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AddTcRequest& a, AddTcRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddTcRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddTcRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddTcRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddTcRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddTcRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddTcRequest& from) {
    AddTcRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddTcRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.AddTcRequest";
  }
  protected:
  explicit AddTcRequest(::google::protobuf::Arena* arena);
  AddTcRequest(::google::protobuf::Arena* arena, const AddTcRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassFieldNumber = 1,
  };
  // .bess.pb.TrafficClass class = 1;
  bool has_class_() const;
  void clear_class_() ;
  const ::bess::pb::TrafficClass& class_() const;
  PROTOBUF_NODISCARD ::bess::pb::TrafficClass* release_class_();
  ::bess::pb::TrafficClass* mutable_class_();
  void set_allocated_class_(::bess::pb::TrafficClass* value);
  void unsafe_arena_set_allocated_class_(::bess::pb::TrafficClass* value);
  ::bess::pb::TrafficClass* unsafe_arena_release_class_();

  private:
  const ::bess::pb::TrafficClass& _internal_class_() const;
  ::bess::pb::TrafficClass* _internal_mutable_class_();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.AddTcRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::bess::pb::TrafficClass* class__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};// -------------------------------------------------------------------

class ListTcsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bess.pb.ListTcsResponse) */ {
 public:
  inline ListTcsResponse() : ListTcsResponse(nullptr) {}
  ~ListTcsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListTcsResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListTcsResponse(const ListTcsResponse& from)
      : ListTcsResponse(nullptr, from) {}
  ListTcsResponse(ListTcsResponse&& from) noexcept
    : ListTcsResponse() {
    *this = ::std::move(from);
  }

  inline ListTcsResponse& operator=(const ListTcsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTcsResponse& operator=(ListTcsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTcsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTcsResponse* internal_default_instance() {
    return reinterpret_cast<const ListTcsResponse*>(
               &_ListTcsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ListTcsResponse& a, ListTcsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTcsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTcsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTcsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTcsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListTcsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListTcsResponse& from) {
    ListTcsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListTcsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "bess.pb.ListTcsResponse";
  }
  protected:
  explicit ListTcsResponse(::google::protobuf::Arena* arena);
  ListTcsResponse(::google::protobuf::Arena* arena, const ListTcsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TrafficClassStatus = ListTcsResponse_TrafficClassStatus;

  // accessors -------------------------------------------------------

  enum : int {
    kClassesStatusFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated .bess.pb.ListTcsResponse.TrafficClassStatus classes_status = 2;
  int classes_status_size() const;
  private:
  int _internal_classes_status_size() const;

  public:
  void clear_classes_status() ;
  ::bess::pb::ListTcsResponse_TrafficClassStatus* mutable_classes_status(int index);
  ::google::protobuf::RepeatedPtrField< ::bess::pb::ListTcsResponse_TrafficClassStatus >*
      mutable_classes_status();
  private:
  const ::google::protobuf::RepeatedPtrField<::bess::pb::ListTcsResponse_TrafficClassStatus>& _internal_classes_status() const;
  ::google::protobuf::RepeatedPtrField<::bess::pb::ListTcsResponse_TrafficClassStatus>* _internal_mutable_classes_status();
  public:
  const ::bess::pb::ListTcsResponse_TrafficClassStatus& classes_status(int index) const;
  ::bess::pb::ListTcsResponse_TrafficClassStatus* add_classes_status();
  const ::google::protobuf::RepeatedPtrField< ::bess::pb::ListTcsResponse_TrafficClassStatus >&
      classes_status() const;
  // .bess.pb.Error error = 1;
  bool has_error() const;
  void clear_error() ;
  const ::bess::pb::Error& error() const;
  PROTOBUF_NODISCARD ::bess::pb::Error* release_error();
  ::bess::pb::Error* mutable_error();
  void set_allocated_error(::bess::pb::Error* value);
  void unsafe_arena_set_allocated_error(::bess::pb::Error* value);
  ::bess::pb::Error* unsafe_arena_release_error();

  private:
  const ::bess::pb::Error& _internal_error() const;
  ::bess::pb::Error* _internal_mutable_error();

  public:
  // @@protoc_insertion_point(class_scope:bess.pb.ListTcsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::bess::pb::ListTcsResponse_TrafficClassStatus > classes_status_;
    ::bess::pb::Error* error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bess_5fmsg_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EmptyRequest

// -------------------------------------------------------------------

// EmptyResponse

// .bess.pb.Error error = 1;
inline bool EmptyResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& EmptyResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& EmptyResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.EmptyResponse.error)
  return _internal_error();
}
inline void EmptyResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.EmptyResponse.error)
}
inline ::bess::pb::Error* EmptyResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* EmptyResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.EmptyResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* EmptyResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* EmptyResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.EmptyResponse.error)
  return _msg;
}
inline void EmptyResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.EmptyResponse.error)
}

// -------------------------------------------------------------------

// VersionResponse

// .bess.pb.Error error = 1;
inline bool VersionResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& VersionResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& VersionResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.VersionResponse.error)
  return _internal_error();
}
inline void VersionResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.VersionResponse.error)
}
inline ::bess::pb::Error* VersionResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* VersionResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.VersionResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* VersionResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* VersionResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.VersionResponse.error)
  return _msg;
}
inline void VersionResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.VersionResponse.error)
}

// string version = 2;
inline void VersionResponse::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& VersionResponse::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.VersionResponse.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VersionResponse::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.VersionResponse.version)
}
inline std::string* VersionResponse::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:bess.pb.VersionResponse.version)
  return _s;
}
inline const std::string& VersionResponse::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void VersionResponse::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* VersionResponse::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* VersionResponse::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.VersionResponse.version)
  return _impl_.version_.Release();
}
inline void VersionResponse::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.VersionResponse.version)
}

// -------------------------------------------------------------------

// ImportPluginRequest

// string path = 1;
inline void ImportPluginRequest::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& ImportPluginRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ImportPluginRequest.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImportPluginRequest::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.ImportPluginRequest.path)
}
inline std::string* ImportPluginRequest::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:bess.pb.ImportPluginRequest.path)
  return _s;
}
inline const std::string& ImportPluginRequest::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void ImportPluginRequest::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* ImportPluginRequest::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* ImportPluginRequest::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ImportPluginRequest.path)
  return _impl_.path_.Release();
}
inline void ImportPluginRequest::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ImportPluginRequest.path)
}

// -------------------------------------------------------------------

// UnloadPluginRequest

// string path = 1;
inline void UnloadPluginRequest::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& UnloadPluginRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.UnloadPluginRequest.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UnloadPluginRequest::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.UnloadPluginRequest.path)
}
inline std::string* UnloadPluginRequest::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:bess.pb.UnloadPluginRequest.path)
  return _s;
}
inline const std::string& UnloadPluginRequest::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void UnloadPluginRequest::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* UnloadPluginRequest::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* UnloadPluginRequest::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.UnloadPluginRequest.path)
  return _impl_.path_.Release();
}
inline void UnloadPluginRequest::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.UnloadPluginRequest.path)
}

// -------------------------------------------------------------------

// ListPluginsResponse

// .bess.pb.Error error = 1;
inline bool ListPluginsResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& ListPluginsResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& ListPluginsResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListPluginsResponse.error)
  return _internal_error();
}
inline void ListPluginsResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.ListPluginsResponse.error)
}
inline ::bess::pb::Error* ListPluginsResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* ListPluginsResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListPluginsResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* ListPluginsResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* ListPluginsResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListPluginsResponse.error)
  return _msg;
}
inline void ListPluginsResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListPluginsResponse.error)
}

// repeated string paths = 2;
inline int ListPluginsResponse::_internal_paths_size() const {
  return _internal_paths().size();
}
inline int ListPluginsResponse::paths_size() const {
  return _internal_paths_size();
}
inline void ListPluginsResponse::clear_paths() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.paths_.Clear();
}
inline std::string* ListPluginsResponse::add_paths()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_paths()->Add();
  // @@protoc_insertion_point(field_add_mutable:bess.pb.ListPluginsResponse.paths)
  return _s;
}
inline const std::string& ListPluginsResponse::paths(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListPluginsResponse.paths)
  return _internal_paths().Get(index);
}
inline std::string* ListPluginsResponse::mutable_paths(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.ListPluginsResponse.paths)
  return _internal_mutable_paths()->Mutable(index);
}
inline void ListPluginsResponse::set_paths(int index, const std::string& value) {
  _internal_mutable_paths()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bess.pb.ListPluginsResponse.paths)
}
inline void ListPluginsResponse::set_paths(int index, std::string&& value) {
  _internal_mutable_paths()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bess.pb.ListPluginsResponse.paths)
}
inline void ListPluginsResponse::set_paths(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_paths()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bess.pb.ListPluginsResponse.paths)
}
inline void ListPluginsResponse::set_paths(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_paths()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bess.pb.ListPluginsResponse.paths)
}
inline void ListPluginsResponse::set_paths(int index, absl::string_view value) {
  _internal_mutable_paths()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:bess.pb.ListPluginsResponse.paths)
}
inline void ListPluginsResponse::add_paths(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_paths()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:bess.pb.ListPluginsResponse.paths)
}
inline void ListPluginsResponse::add_paths(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_paths()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:bess.pb.ListPluginsResponse.paths)
}
inline void ListPluginsResponse::add_paths(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_paths()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bess.pb.ListPluginsResponse.paths)
}
inline void ListPluginsResponse::add_paths(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_paths()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bess.pb.ListPluginsResponse.paths)
}
inline void ListPluginsResponse::add_paths(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_paths()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:bess.pb.ListPluginsResponse.paths)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ListPluginsResponse::paths() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.ListPluginsResponse.paths)
  return _internal_paths();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ListPluginsResponse::mutable_paths() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.ListPluginsResponse.paths)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_paths();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ListPluginsResponse::_internal_paths() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.paths_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ListPluginsResponse::_internal_mutable_paths() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.paths_;
}

// -------------------------------------------------------------------

// ListWorkersResponse_WorkerStatus

// int64 wid = 1;
inline void ListWorkersResponse_WorkerStatus::clear_wid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wid_ = ::int64_t{0};
}
inline ::int64_t ListWorkersResponse_WorkerStatus::wid() const {
  // @@protoc_insertion_point(field_get:bess.pb.ListWorkersResponse.WorkerStatus.wid)
  return _internal_wid();
}
inline void ListWorkersResponse_WorkerStatus::set_wid(::int64_t value) {
  _internal_set_wid(value);
  // @@protoc_insertion_point(field_set:bess.pb.ListWorkersResponse.WorkerStatus.wid)
}
inline ::int64_t ListWorkersResponse_WorkerStatus::_internal_wid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wid_;
}
inline void ListWorkersResponse_WorkerStatus::_internal_set_wid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wid_ = value;
}

// int64 core = 2;
inline void ListWorkersResponse_WorkerStatus::clear_core() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.core_ = ::int64_t{0};
}
inline ::int64_t ListWorkersResponse_WorkerStatus::core() const {
  // @@protoc_insertion_point(field_get:bess.pb.ListWorkersResponse.WorkerStatus.core)
  return _internal_core();
}
inline void ListWorkersResponse_WorkerStatus::set_core(::int64_t value) {
  _internal_set_core(value);
  // @@protoc_insertion_point(field_set:bess.pb.ListWorkersResponse.WorkerStatus.core)
}
inline ::int64_t ListWorkersResponse_WorkerStatus::_internal_core() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.core_;
}
inline void ListWorkersResponse_WorkerStatus::_internal_set_core(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.core_ = value;
}

// bool running = 3;
inline void ListWorkersResponse_WorkerStatus::clear_running() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.running_ = false;
}
inline bool ListWorkersResponse_WorkerStatus::running() const {
  // @@protoc_insertion_point(field_get:bess.pb.ListWorkersResponse.WorkerStatus.running)
  return _internal_running();
}
inline void ListWorkersResponse_WorkerStatus::set_running(bool value) {
  _internal_set_running(value);
  // @@protoc_insertion_point(field_set:bess.pb.ListWorkersResponse.WorkerStatus.running)
}
inline bool ListWorkersResponse_WorkerStatus::_internal_running() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.running_;
}
inline void ListWorkersResponse_WorkerStatus::_internal_set_running(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.running_ = value;
}

// int64 num_tcs = 4;
inline void ListWorkersResponse_WorkerStatus::clear_num_tcs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_tcs_ = ::int64_t{0};
}
inline ::int64_t ListWorkersResponse_WorkerStatus::num_tcs() const {
  // @@protoc_insertion_point(field_get:bess.pb.ListWorkersResponse.WorkerStatus.num_tcs)
  return _internal_num_tcs();
}
inline void ListWorkersResponse_WorkerStatus::set_num_tcs(::int64_t value) {
  _internal_set_num_tcs(value);
  // @@protoc_insertion_point(field_set:bess.pb.ListWorkersResponse.WorkerStatus.num_tcs)
}
inline ::int64_t ListWorkersResponse_WorkerStatus::_internal_num_tcs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_tcs_;
}
inline void ListWorkersResponse_WorkerStatus::_internal_set_num_tcs(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_tcs_ = value;
}

// int64 silent_drops = 5;
inline void ListWorkersResponse_WorkerStatus::clear_silent_drops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.silent_drops_ = ::int64_t{0};
}
inline ::int64_t ListWorkersResponse_WorkerStatus::silent_drops() const {
  // @@protoc_insertion_point(field_get:bess.pb.ListWorkersResponse.WorkerStatus.silent_drops)
  return _internal_silent_drops();
}
inline void ListWorkersResponse_WorkerStatus::set_silent_drops(::int64_t value) {
  _internal_set_silent_drops(value);
  // @@protoc_insertion_point(field_set:bess.pb.ListWorkersResponse.WorkerStatus.silent_drops)
}
inline ::int64_t ListWorkersResponse_WorkerStatus::_internal_silent_drops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.silent_drops_;
}
inline void ListWorkersResponse_WorkerStatus::_internal_set_silent_drops(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.silent_drops_ = value;
}

// -------------------------------------------------------------------

// ListWorkersResponse

// .bess.pb.Error error = 1;
inline bool ListWorkersResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& ListWorkersResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& ListWorkersResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListWorkersResponse.error)
  return _internal_error();
}
inline void ListWorkersResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.ListWorkersResponse.error)
}
inline ::bess::pb::Error* ListWorkersResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* ListWorkersResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListWorkersResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* ListWorkersResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* ListWorkersResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListWorkersResponse.error)
  return _msg;
}
inline void ListWorkersResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListWorkersResponse.error)
}

// repeated .bess.pb.ListWorkersResponse.WorkerStatus workers_status = 2;
inline int ListWorkersResponse::_internal_workers_status_size() const {
  return _internal_workers_status().size();
}
inline int ListWorkersResponse::workers_status_size() const {
  return _internal_workers_status_size();
}
inline void ListWorkersResponse::clear_workers_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workers_status_.Clear();
}
inline ::bess::pb::ListWorkersResponse_WorkerStatus* ListWorkersResponse::mutable_workers_status(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.ListWorkersResponse.workers_status)
  return _internal_mutable_workers_status()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::ListWorkersResponse_WorkerStatus>* ListWorkersResponse::mutable_workers_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.ListWorkersResponse.workers_status)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_workers_status();
}
inline const ::bess::pb::ListWorkersResponse_WorkerStatus& ListWorkersResponse::workers_status(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListWorkersResponse.workers_status)
  return _internal_workers_status().Get(index);
}
inline ::bess::pb::ListWorkersResponse_WorkerStatus* ListWorkersResponse::add_workers_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::bess::pb::ListWorkersResponse_WorkerStatus* _add = _internal_mutable_workers_status()->Add();
  // @@protoc_insertion_point(field_add:bess.pb.ListWorkersResponse.workers_status)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::ListWorkersResponse_WorkerStatus>& ListWorkersResponse::workers_status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.ListWorkersResponse.workers_status)
  return _internal_workers_status();
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::ListWorkersResponse_WorkerStatus>&
ListWorkersResponse::_internal_workers_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.workers_status_;
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::ListWorkersResponse_WorkerStatus>*
ListWorkersResponse::_internal_mutable_workers_status() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.workers_status_;
}

// -------------------------------------------------------------------

// AddWorkerRequest

// int64 wid = 1;
inline void AddWorkerRequest::clear_wid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wid_ = ::int64_t{0};
}
inline ::int64_t AddWorkerRequest::wid() const {
  // @@protoc_insertion_point(field_get:bess.pb.AddWorkerRequest.wid)
  return _internal_wid();
}
inline void AddWorkerRequest::set_wid(::int64_t value) {
  _internal_set_wid(value);
  // @@protoc_insertion_point(field_set:bess.pb.AddWorkerRequest.wid)
}
inline ::int64_t AddWorkerRequest::_internal_wid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wid_;
}
inline void AddWorkerRequest::_internal_set_wid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wid_ = value;
}

// int64 core = 2;
inline void AddWorkerRequest::clear_core() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.core_ = ::int64_t{0};
}
inline ::int64_t AddWorkerRequest::core() const {
  // @@protoc_insertion_point(field_get:bess.pb.AddWorkerRequest.core)
  return _internal_core();
}
inline void AddWorkerRequest::set_core(::int64_t value) {
  _internal_set_core(value);
  // @@protoc_insertion_point(field_set:bess.pb.AddWorkerRequest.core)
}
inline ::int64_t AddWorkerRequest::_internal_core() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.core_;
}
inline void AddWorkerRequest::_internal_set_core(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.core_ = value;
}

// string scheduler = 3;
inline void AddWorkerRequest::clear_scheduler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scheduler_.ClearToEmpty();
}
inline const std::string& AddWorkerRequest::scheduler() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.AddWorkerRequest.scheduler)
  return _internal_scheduler();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddWorkerRequest::set_scheduler(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.scheduler_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.AddWorkerRequest.scheduler)
}
inline std::string* AddWorkerRequest::mutable_scheduler() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_scheduler();
  // @@protoc_insertion_point(field_mutable:bess.pb.AddWorkerRequest.scheduler)
  return _s;
}
inline const std::string& AddWorkerRequest::_internal_scheduler() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scheduler_.Get();
}
inline void AddWorkerRequest::_internal_set_scheduler(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.scheduler_.Set(value, GetArena());
}
inline std::string* AddWorkerRequest::_internal_mutable_scheduler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.scheduler_.Mutable( GetArena());
}
inline std::string* AddWorkerRequest::release_scheduler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.AddWorkerRequest.scheduler)
  return _impl_.scheduler_.Release();
}
inline void AddWorkerRequest::set_allocated_scheduler(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scheduler_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.scheduler_.IsDefault()) {
          _impl_.scheduler_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.AddWorkerRequest.scheduler)
}

// -------------------------------------------------------------------

// DestroyWorkerRequest

// int64 wid = 1;
inline void DestroyWorkerRequest::clear_wid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wid_ = ::int64_t{0};
}
inline ::int64_t DestroyWorkerRequest::wid() const {
  // @@protoc_insertion_point(field_get:bess.pb.DestroyWorkerRequest.wid)
  return _internal_wid();
}
inline void DestroyWorkerRequest::set_wid(::int64_t value) {
  _internal_set_wid(value);
  // @@protoc_insertion_point(field_set:bess.pb.DestroyWorkerRequest.wid)
}
inline ::int64_t DestroyWorkerRequest::_internal_wid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wid_;
}
inline void DestroyWorkerRequest::_internal_set_wid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wid_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TrafficClass

// string parent = 1;
inline void TrafficClass::clear_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& TrafficClass::parent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.TrafficClass.parent)
  return _internal_parent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficClass::set_parent(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.TrafficClass.parent)
}
inline std::string* TrafficClass::mutable_parent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:bess.pb.TrafficClass.parent)
  return _s;
}
inline const std::string& TrafficClass::_internal_parent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parent_.Get();
}
inline void TrafficClass::_internal_set_parent(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_.Set(value, GetArena());
}
inline std::string* TrafficClass::_internal_mutable_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.parent_.Mutable( GetArena());
}
inline std::string* TrafficClass::release_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.TrafficClass.parent)
  return _impl_.parent_.Release();
}
inline void TrafficClass::set_allocated_parent(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_.IsDefault()) {
          _impl_.parent_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.TrafficClass.parent)
}

// string name = 2;
inline void TrafficClass::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TrafficClass::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.TrafficClass.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficClass::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.TrafficClass.name)
}
inline std::string* TrafficClass::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.TrafficClass.name)
  return _s;
}
inline const std::string& TrafficClass::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TrafficClass::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* TrafficClass::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* TrafficClass::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.TrafficClass.name)
  return _impl_.name_.Release();
}
inline void TrafficClass::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.TrafficClass.name)
}

// bool blocked = 3;
inline void TrafficClass::clear_blocked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blocked_ = false;
}
inline bool TrafficClass::blocked() const {
  // @@protoc_insertion_point(field_get:bess.pb.TrafficClass.blocked)
  return _internal_blocked();
}
inline void TrafficClass::set_blocked(bool value) {
  _internal_set_blocked(value);
  // @@protoc_insertion_point(field_set:bess.pb.TrafficClass.blocked)
}
inline bool TrafficClass::_internal_blocked() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blocked_;
}
inline void TrafficClass::_internal_set_blocked(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.blocked_ = value;
}

// string policy = 4;
inline void TrafficClass::clear_policy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.policy_.ClearToEmpty();
}
inline const std::string& TrafficClass::policy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.TrafficClass.policy)
  return _internal_policy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficClass::set_policy(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.policy_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.TrafficClass.policy)
}
inline std::string* TrafficClass::mutable_policy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_policy();
  // @@protoc_insertion_point(field_mutable:bess.pb.TrafficClass.policy)
  return _s;
}
inline const std::string& TrafficClass::_internal_policy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.policy_.Get();
}
inline void TrafficClass::_internal_set_policy(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.policy_.Set(value, GetArena());
}
inline std::string* TrafficClass::_internal_mutable_policy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.policy_.Mutable( GetArena());
}
inline std::string* TrafficClass::release_policy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.TrafficClass.policy)
  return _impl_.policy_.Release();
}
inline void TrafficClass::set_allocated_policy(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.policy_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.policy_.IsDefault()) {
          _impl_.policy_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.TrafficClass.policy)
}

// string resource = 5;
inline void TrafficClass::clear_resource() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resource_.ClearToEmpty();
}
inline const std::string& TrafficClass::resource() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.TrafficClass.resource)
  return _internal_resource();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficClass::set_resource(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.resource_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.TrafficClass.resource)
}
inline std::string* TrafficClass::mutable_resource() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:bess.pb.TrafficClass.resource)
  return _s;
}
inline const std::string& TrafficClass::_internal_resource() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resource_.Get();
}
inline void TrafficClass::_internal_set_resource(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.resource_.Set(value, GetArena());
}
inline std::string* TrafficClass::_internal_mutable_resource() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.resource_.Mutable( GetArena());
}
inline std::string* TrafficClass::release_resource() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.TrafficClass.resource)
  return _impl_.resource_.Release();
}
inline void TrafficClass::set_allocated_resource(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resource_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.resource_.IsDefault()) {
          _impl_.resource_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.TrafficClass.resource)
}

// int64 priority = 6;
inline bool TrafficClass::has_priority() const {
  return arg_case() == kPriority;
}
inline void TrafficClass::set_has_priority() {
  _impl_._oneof_case_[0] = kPriority;
}
inline void TrafficClass::clear_priority() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (arg_case() == kPriority) {
    _impl_.arg_.priority_ = ::int64_t{0};
    clear_has_arg();
  }
}
inline ::int64_t TrafficClass::priority() const {
  // @@protoc_insertion_point(field_get:bess.pb.TrafficClass.priority)
  return _internal_priority();
}
inline void TrafficClass::set_priority(::int64_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:bess.pb.TrafficClass.priority)
}
inline ::int64_t TrafficClass::_internal_priority() const {
  if (arg_case() == kPriority) {
    return _impl_.arg_.priority_;
  }
  return ::int64_t{0};
}
inline void TrafficClass::_internal_set_priority(::int64_t value) {
  if (arg_case() != kPriority) {
    clear_arg();
    set_has_priority();
  }
  _impl_.arg_.priority_ = value;
}

// int64 share = 7;
inline bool TrafficClass::has_share() const {
  return arg_case() == kShare;
}
inline void TrafficClass::set_has_share() {
  _impl_._oneof_case_[0] = kShare;
}
inline void TrafficClass::clear_share() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (arg_case() == kShare) {
    _impl_.arg_.share_ = ::int64_t{0};
    clear_has_arg();
  }
}
inline ::int64_t TrafficClass::share() const {
  // @@protoc_insertion_point(field_get:bess.pb.TrafficClass.share)
  return _internal_share();
}
inline void TrafficClass::set_share(::int64_t value) {
  _internal_set_share(value);
  // @@protoc_insertion_point(field_set:bess.pb.TrafficClass.share)
}
inline ::int64_t TrafficClass::_internal_share() const {
  if (arg_case() == kShare) {
    return _impl_.arg_.share_;
  }
  return ::int64_t{0};
}
inline void TrafficClass::_internal_set_share(::int64_t value) {
  if (arg_case() != kShare) {
    clear_arg();
    set_has_share();
  }
  _impl_.arg_.share_ = value;
}

// int64 wid = 8;
inline void TrafficClass::clear_wid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wid_ = ::int64_t{0};
}
inline ::int64_t TrafficClass::wid() const {
  // @@protoc_insertion_point(field_get:bess.pb.TrafficClass.wid)
  return _internal_wid();
}
inline void TrafficClass::set_wid(::int64_t value) {
  _internal_set_wid(value);
  // @@protoc_insertion_point(field_set:bess.pb.TrafficClass.wid)
}
inline ::int64_t TrafficClass::_internal_wid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wid_;
}
inline void TrafficClass::_internal_set_wid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wid_ = value;
}

// map<string, int64> limit = 9;
inline int TrafficClass::_internal_limit_size() const {
  return _internal_limit().size();
}
inline int TrafficClass::limit_size() const {
  return _internal_limit_size();
}
inline void TrafficClass::clear_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.limit_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int64_t>& TrafficClass::_internal_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.limit_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int64_t>& TrafficClass::limit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:bess.pb.TrafficClass.limit)
  return _internal_limit();
}
inline ::google::protobuf::Map<std::string, ::int64_t>* TrafficClass::_internal_mutable_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.limit_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int64_t>* TrafficClass::mutable_limit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:bess.pb.TrafficClass.limit)
  return _internal_mutable_limit();
}

// map<string, int64> max_burst = 10;
inline int TrafficClass::_internal_max_burst_size() const {
  return _internal_max_burst().size();
}
inline int TrafficClass::max_burst_size() const {
  return _internal_max_burst_size();
}
inline void TrafficClass::clear_max_burst() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_burst_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int64_t>& TrafficClass::_internal_max_burst() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_burst_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int64_t>& TrafficClass::max_burst() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:bess.pb.TrafficClass.max_burst)
  return _internal_max_burst();
}
inline ::google::protobuf::Map<std::string, ::int64_t>* TrafficClass::_internal_mutable_max_burst() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.max_burst_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int64_t>* TrafficClass::mutable_max_burst() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:bess.pb.TrafficClass.max_burst)
  return _internal_mutable_max_burst();
}

// string leaf_module_name = 11;
inline void TrafficClass::clear_leaf_module_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leaf_module_name_.ClearToEmpty();
}
inline const std::string& TrafficClass::leaf_module_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.TrafficClass.leaf_module_name)
  return _internal_leaf_module_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficClass::set_leaf_module_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leaf_module_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.TrafficClass.leaf_module_name)
}
inline std::string* TrafficClass::mutable_leaf_module_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_leaf_module_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.TrafficClass.leaf_module_name)
  return _s;
}
inline const std::string& TrafficClass::_internal_leaf_module_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leaf_module_name_.Get();
}
inline void TrafficClass::_internal_set_leaf_module_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leaf_module_name_.Set(value, GetArena());
}
inline std::string* TrafficClass::_internal_mutable_leaf_module_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.leaf_module_name_.Mutable( GetArena());
}
inline std::string* TrafficClass::release_leaf_module_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.TrafficClass.leaf_module_name)
  return _impl_.leaf_module_name_.Release();
}
inline void TrafficClass::set_allocated_leaf_module_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leaf_module_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.leaf_module_name_.IsDefault()) {
          _impl_.leaf_module_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.TrafficClass.leaf_module_name)
}

// uint64 leaf_module_taskid = 12;
inline void TrafficClass::clear_leaf_module_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leaf_module_taskid_ = ::uint64_t{0u};
}
inline ::uint64_t TrafficClass::leaf_module_taskid() const {
  // @@protoc_insertion_point(field_get:bess.pb.TrafficClass.leaf_module_taskid)
  return _internal_leaf_module_taskid();
}
inline void TrafficClass::set_leaf_module_taskid(::uint64_t value) {
  _internal_set_leaf_module_taskid(value);
  // @@protoc_insertion_point(field_set:bess.pb.TrafficClass.leaf_module_taskid)
}
inline ::uint64_t TrafficClass::_internal_leaf_module_taskid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leaf_module_taskid_;
}
inline void TrafficClass::_internal_set_leaf_module_taskid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leaf_module_taskid_ = value;
}

inline bool TrafficClass::has_arg() const {
  return arg_case() != ARG_NOT_SET;
}
inline void TrafficClass::clear_has_arg() {
  _impl_._oneof_case_[0] = ARG_NOT_SET;
}
inline TrafficClass::ArgCase TrafficClass::arg_case() const {
  return TrafficClass::ArgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ListTcsRequest

// int64 wid = 1;
inline void ListTcsRequest::clear_wid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wid_ = ::int64_t{0};
}
inline ::int64_t ListTcsRequest::wid() const {
  // @@protoc_insertion_point(field_get:bess.pb.ListTcsRequest.wid)
  return _internal_wid();
}
inline void ListTcsRequest::set_wid(::int64_t value) {
  _internal_set_wid(value);
  // @@protoc_insertion_point(field_set:bess.pb.ListTcsRequest.wid)
}
inline ::int64_t ListTcsRequest::_internal_wid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wid_;
}
inline void ListTcsRequest::_internal_set_wid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wid_ = value;
}

// -------------------------------------------------------------------

// ListTcsResponse_TrafficClassStatus

// .bess.pb.TrafficClass class = 1;
inline bool ListTcsResponse_TrafficClassStatus::has_class_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.class__ != nullptr);
  return value;
}
inline void ListTcsResponse_TrafficClassStatus::clear_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.class__ != nullptr) _impl_.class__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::bess::pb::TrafficClass& ListTcsResponse_TrafficClassStatus::_internal_class_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::TrafficClass* p = _impl_.class__;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::TrafficClass&>(::bess::pb::_TrafficClass_default_instance_);
}
inline const ::bess::pb::TrafficClass& ListTcsResponse_TrafficClassStatus::class_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListTcsResponse.TrafficClassStatus.class)
  return _internal_class_();
}
inline void ListTcsResponse_TrafficClassStatus::unsafe_arena_set_allocated_class_(::bess::pb::TrafficClass* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.class__);
  }
  _impl_.class__ = reinterpret_cast<::bess::pb::TrafficClass*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.ListTcsResponse.TrafficClassStatus.class)
}
inline ::bess::pb::TrafficClass* ListTcsResponse_TrafficClassStatus::release_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::TrafficClass* released = _impl_.class__;
  _impl_.class__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::TrafficClass* ListTcsResponse_TrafficClassStatus::unsafe_arena_release_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListTcsResponse.TrafficClassStatus.class)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::TrafficClass* temp = _impl_.class__;
  _impl_.class__ = nullptr;
  return temp;
}
inline ::bess::pb::TrafficClass* ListTcsResponse_TrafficClassStatus::_internal_mutable_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.class__ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::TrafficClass>(GetArena());
    _impl_.class__ = reinterpret_cast<::bess::pb::TrafficClass*>(p);
  }
  return _impl_.class__;
}
inline ::bess::pb::TrafficClass* ListTcsResponse_TrafficClassStatus::mutable_class_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::TrafficClass* _msg = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListTcsResponse.TrafficClassStatus.class)
  return _msg;
}
inline void ListTcsResponse_TrafficClassStatus::set_allocated_class_(::bess::pb::TrafficClass* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::bess::pb::TrafficClass*>(_impl_.class__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::bess::pb::TrafficClass*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.class__ = reinterpret_cast<::bess::pb::TrafficClass*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListTcsResponse.TrafficClassStatus.class)
}

// string parent = 2;
inline void ListTcsResponse_TrafficClassStatus::clear_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListTcsResponse_TrafficClassStatus::parent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListTcsResponse.TrafficClassStatus.parent)
  return _internal_parent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListTcsResponse_TrafficClassStatus::set_parent(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.ListTcsResponse.TrafficClassStatus.parent)
}
inline std::string* ListTcsResponse_TrafficClassStatus::mutable_parent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListTcsResponse.TrafficClassStatus.parent)
  return _s;
}
inline const std::string& ListTcsResponse_TrafficClassStatus::_internal_parent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parent_.Get();
}
inline void ListTcsResponse_TrafficClassStatus::_internal_set_parent(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_.Set(value, GetArena());
}
inline std::string* ListTcsResponse_TrafficClassStatus::_internal_mutable_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.parent_.Mutable( GetArena());
}
inline std::string* ListTcsResponse_TrafficClassStatus::release_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListTcsResponse.TrafficClassStatus.parent)
  return _impl_.parent_.Release();
}
inline void ListTcsResponse_TrafficClassStatus::set_allocated_parent(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_.IsDefault()) {
          _impl_.parent_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListTcsResponse.TrafficClassStatus.parent)
}

// -------------------------------------------------------------------

// ListTcsResponse

// .bess.pb.Error error = 1;
inline bool ListTcsResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& ListTcsResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& ListTcsResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListTcsResponse.error)
  return _internal_error();
}
inline void ListTcsResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.ListTcsResponse.error)
}
inline ::bess::pb::Error* ListTcsResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* ListTcsResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListTcsResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* ListTcsResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* ListTcsResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListTcsResponse.error)
  return _msg;
}
inline void ListTcsResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListTcsResponse.error)
}

// repeated .bess.pb.ListTcsResponse.TrafficClassStatus classes_status = 2;
inline int ListTcsResponse::_internal_classes_status_size() const {
  return _internal_classes_status().size();
}
inline int ListTcsResponse::classes_status_size() const {
  return _internal_classes_status_size();
}
inline void ListTcsResponse::clear_classes_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.classes_status_.Clear();
}
inline ::bess::pb::ListTcsResponse_TrafficClassStatus* ListTcsResponse::mutable_classes_status(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.ListTcsResponse.classes_status)
  return _internal_mutable_classes_status()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::ListTcsResponse_TrafficClassStatus>* ListTcsResponse::mutable_classes_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.ListTcsResponse.classes_status)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_classes_status();
}
inline const ::bess::pb::ListTcsResponse_TrafficClassStatus& ListTcsResponse::classes_status(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListTcsResponse.classes_status)
  return _internal_classes_status().Get(index);
}
inline ::bess::pb::ListTcsResponse_TrafficClassStatus* ListTcsResponse::add_classes_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::bess::pb::ListTcsResponse_TrafficClassStatus* _add = _internal_mutable_classes_status()->Add();
  // @@protoc_insertion_point(field_add:bess.pb.ListTcsResponse.classes_status)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::ListTcsResponse_TrafficClassStatus>& ListTcsResponse::classes_status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.ListTcsResponse.classes_status)
  return _internal_classes_status();
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::ListTcsResponse_TrafficClassStatus>&
ListTcsResponse::_internal_classes_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.classes_status_;
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::ListTcsResponse_TrafficClassStatus>*
ListTcsResponse::_internal_mutable_classes_status() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.classes_status_;
}

// -------------------------------------------------------------------

// CheckSchedulingConstraintsResponse_ViolatingClass

// string name = 1;
inline void CheckSchedulingConstraintsResponse_ViolatingClass::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CheckSchedulingConstraintsResponse_ViolatingClass::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckSchedulingConstraintsResponse_ViolatingClass::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass.name)
}
inline std::string* CheckSchedulingConstraintsResponse_ViolatingClass::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass.name)
  return _s;
}
inline const std::string& CheckSchedulingConstraintsResponse_ViolatingClass::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CheckSchedulingConstraintsResponse_ViolatingClass::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CheckSchedulingConstraintsResponse_ViolatingClass::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CheckSchedulingConstraintsResponse_ViolatingClass::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass.name)
  return _impl_.name_.Release();
}
inline void CheckSchedulingConstraintsResponse_ViolatingClass::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass.name)
}

// int32 constraint = 2;
inline void CheckSchedulingConstraintsResponse_ViolatingClass::clear_constraint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.constraint_ = 0;
}
inline ::int32_t CheckSchedulingConstraintsResponse_ViolatingClass::constraint() const {
  // @@protoc_insertion_point(field_get:bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass.constraint)
  return _internal_constraint();
}
inline void CheckSchedulingConstraintsResponse_ViolatingClass::set_constraint(::int32_t value) {
  _internal_set_constraint(value);
  // @@protoc_insertion_point(field_set:bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass.constraint)
}
inline ::int32_t CheckSchedulingConstraintsResponse_ViolatingClass::_internal_constraint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.constraint_;
}
inline void CheckSchedulingConstraintsResponse_ViolatingClass::_internal_set_constraint(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.constraint_ = value;
}

// int32 assigned_node = 3;
inline void CheckSchedulingConstraintsResponse_ViolatingClass::clear_assigned_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assigned_node_ = 0;
}
inline ::int32_t CheckSchedulingConstraintsResponse_ViolatingClass::assigned_node() const {
  // @@protoc_insertion_point(field_get:bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass.assigned_node)
  return _internal_assigned_node();
}
inline void CheckSchedulingConstraintsResponse_ViolatingClass::set_assigned_node(::int32_t value) {
  _internal_set_assigned_node(value);
  // @@protoc_insertion_point(field_set:bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass.assigned_node)
}
inline ::int32_t CheckSchedulingConstraintsResponse_ViolatingClass::_internal_assigned_node() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assigned_node_;
}
inline void CheckSchedulingConstraintsResponse_ViolatingClass::_internal_set_assigned_node(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.assigned_node_ = value;
}

// int32 assigned_core = 4;
inline void CheckSchedulingConstraintsResponse_ViolatingClass::clear_assigned_core() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assigned_core_ = 0;
}
inline ::int32_t CheckSchedulingConstraintsResponse_ViolatingClass::assigned_core() const {
  // @@protoc_insertion_point(field_get:bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass.assigned_core)
  return _internal_assigned_core();
}
inline void CheckSchedulingConstraintsResponse_ViolatingClass::set_assigned_core(::int32_t value) {
  _internal_set_assigned_core(value);
  // @@protoc_insertion_point(field_set:bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass.assigned_core)
}
inline ::int32_t CheckSchedulingConstraintsResponse_ViolatingClass::_internal_assigned_core() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assigned_core_;
}
inline void CheckSchedulingConstraintsResponse_ViolatingClass::_internal_set_assigned_core(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.assigned_core_ = value;
}

// -------------------------------------------------------------------

// CheckSchedulingConstraintsResponse_ViolatingModule

// string name = 1;
inline void CheckSchedulingConstraintsResponse_ViolatingModule::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CheckSchedulingConstraintsResponse_ViolatingModule::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CheckSchedulingConstraintsResponse.ViolatingModule.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckSchedulingConstraintsResponse_ViolatingModule::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.CheckSchedulingConstraintsResponse.ViolatingModule.name)
}
inline std::string* CheckSchedulingConstraintsResponse_ViolatingModule::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.CheckSchedulingConstraintsResponse.ViolatingModule.name)
  return _s;
}
inline const std::string& CheckSchedulingConstraintsResponse_ViolatingModule::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CheckSchedulingConstraintsResponse_ViolatingModule::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CheckSchedulingConstraintsResponse_ViolatingModule::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CheckSchedulingConstraintsResponse_ViolatingModule::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CheckSchedulingConstraintsResponse.ViolatingModule.name)
  return _impl_.name_.Release();
}
inline void CheckSchedulingConstraintsResponse_ViolatingModule::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CheckSchedulingConstraintsResponse.ViolatingModule.name)
}

// -------------------------------------------------------------------

// CheckSchedulingConstraintsResponse

// .bess.pb.Error error = 1;
inline bool CheckSchedulingConstraintsResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& CheckSchedulingConstraintsResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& CheckSchedulingConstraintsResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CheckSchedulingConstraintsResponse.error)
  return _internal_error();
}
inline void CheckSchedulingConstraintsResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.CheckSchedulingConstraintsResponse.error)
}
inline ::bess::pb::Error* CheckSchedulingConstraintsResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* CheckSchedulingConstraintsResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CheckSchedulingConstraintsResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* CheckSchedulingConstraintsResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* CheckSchedulingConstraintsResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.CheckSchedulingConstraintsResponse.error)
  return _msg;
}
inline void CheckSchedulingConstraintsResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CheckSchedulingConstraintsResponse.error)
}

// bool fatal = 2;
inline void CheckSchedulingConstraintsResponse::clear_fatal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fatal_ = false;
}
inline bool CheckSchedulingConstraintsResponse::fatal() const {
  // @@protoc_insertion_point(field_get:bess.pb.CheckSchedulingConstraintsResponse.fatal)
  return _internal_fatal();
}
inline void CheckSchedulingConstraintsResponse::set_fatal(bool value) {
  _internal_set_fatal(value);
  // @@protoc_insertion_point(field_set:bess.pb.CheckSchedulingConstraintsResponse.fatal)
}
inline bool CheckSchedulingConstraintsResponse::_internal_fatal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fatal_;
}
inline void CheckSchedulingConstraintsResponse::_internal_set_fatal(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fatal_ = value;
}

// repeated .bess.pb.CheckSchedulingConstraintsResponse.ViolatingClass violations = 3;
inline int CheckSchedulingConstraintsResponse::_internal_violations_size() const {
  return _internal_violations().size();
}
inline int CheckSchedulingConstraintsResponse::violations_size() const {
  return _internal_violations_size();
}
inline void CheckSchedulingConstraintsResponse::clear_violations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.violations_.Clear();
}
inline ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass* CheckSchedulingConstraintsResponse::mutable_violations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.CheckSchedulingConstraintsResponse.violations)
  return _internal_mutable_violations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass>* CheckSchedulingConstraintsResponse::mutable_violations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.CheckSchedulingConstraintsResponse.violations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_violations();
}
inline const ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass& CheckSchedulingConstraintsResponse::violations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CheckSchedulingConstraintsResponse.violations)
  return _internal_violations().Get(index);
}
inline ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass* CheckSchedulingConstraintsResponse::add_violations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass* _add = _internal_mutable_violations()->Add();
  // @@protoc_insertion_point(field_add:bess.pb.CheckSchedulingConstraintsResponse.violations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass>& CheckSchedulingConstraintsResponse::violations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.CheckSchedulingConstraintsResponse.violations)
  return _internal_violations();
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass>&
CheckSchedulingConstraintsResponse::_internal_violations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.violations_;
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::CheckSchedulingConstraintsResponse_ViolatingClass>*
CheckSchedulingConstraintsResponse::_internal_mutable_violations() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.violations_;
}

// repeated .bess.pb.CheckSchedulingConstraintsResponse.ViolatingModule modules = 4;
inline int CheckSchedulingConstraintsResponse::_internal_modules_size() const {
  return _internal_modules().size();
}
inline int CheckSchedulingConstraintsResponse::modules_size() const {
  return _internal_modules_size();
}
inline void CheckSchedulingConstraintsResponse::clear_modules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.modules_.Clear();
}
inline ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule* CheckSchedulingConstraintsResponse::mutable_modules(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.CheckSchedulingConstraintsResponse.modules)
  return _internal_mutable_modules()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule>* CheckSchedulingConstraintsResponse::mutable_modules()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.CheckSchedulingConstraintsResponse.modules)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_modules();
}
inline const ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule& CheckSchedulingConstraintsResponse::modules(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CheckSchedulingConstraintsResponse.modules)
  return _internal_modules().Get(index);
}
inline ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule* CheckSchedulingConstraintsResponse::add_modules() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule* _add = _internal_mutable_modules()->Add();
  // @@protoc_insertion_point(field_add:bess.pb.CheckSchedulingConstraintsResponse.modules)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule>& CheckSchedulingConstraintsResponse::modules() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.CheckSchedulingConstraintsResponse.modules)
  return _internal_modules();
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule>&
CheckSchedulingConstraintsResponse::_internal_modules() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modules_;
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::CheckSchedulingConstraintsResponse_ViolatingModule>*
CheckSchedulingConstraintsResponse::_internal_mutable_modules() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.modules_;
}

// -------------------------------------------------------------------

// AddTcRequest

// .bess.pb.TrafficClass class = 1;
inline bool AddTcRequest::has_class_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.class__ != nullptr);
  return value;
}
inline void AddTcRequest::clear_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.class__ != nullptr) _impl_.class__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::bess::pb::TrafficClass& AddTcRequest::_internal_class_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::TrafficClass* p = _impl_.class__;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::TrafficClass&>(::bess::pb::_TrafficClass_default_instance_);
}
inline const ::bess::pb::TrafficClass& AddTcRequest::class_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.AddTcRequest.class)
  return _internal_class_();
}
inline void AddTcRequest::unsafe_arena_set_allocated_class_(::bess::pb::TrafficClass* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.class__);
  }
  _impl_.class__ = reinterpret_cast<::bess::pb::TrafficClass*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.AddTcRequest.class)
}
inline ::bess::pb::TrafficClass* AddTcRequest::release_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::TrafficClass* released = _impl_.class__;
  _impl_.class__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::TrafficClass* AddTcRequest::unsafe_arena_release_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.AddTcRequest.class)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::TrafficClass* temp = _impl_.class__;
  _impl_.class__ = nullptr;
  return temp;
}
inline ::bess::pb::TrafficClass* AddTcRequest::_internal_mutable_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.class__ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::TrafficClass>(GetArena());
    _impl_.class__ = reinterpret_cast<::bess::pb::TrafficClass*>(p);
  }
  return _impl_.class__;
}
inline ::bess::pb::TrafficClass* AddTcRequest::mutable_class_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::TrafficClass* _msg = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:bess.pb.AddTcRequest.class)
  return _msg;
}
inline void AddTcRequest::set_allocated_class_(::bess::pb::TrafficClass* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::bess::pb::TrafficClass*>(_impl_.class__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::bess::pb::TrafficClass*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.class__ = reinterpret_cast<::bess::pb::TrafficClass*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.AddTcRequest.class)
}

// -------------------------------------------------------------------

// UpdateTcParamsRequest

// .bess.pb.TrafficClass class = 1;
inline bool UpdateTcParamsRequest::has_class_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.class__ != nullptr);
  return value;
}
inline void UpdateTcParamsRequest::clear_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.class__ != nullptr) _impl_.class__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::bess::pb::TrafficClass& UpdateTcParamsRequest::_internal_class_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::TrafficClass* p = _impl_.class__;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::TrafficClass&>(::bess::pb::_TrafficClass_default_instance_);
}
inline const ::bess::pb::TrafficClass& UpdateTcParamsRequest::class_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.UpdateTcParamsRequest.class)
  return _internal_class_();
}
inline void UpdateTcParamsRequest::unsafe_arena_set_allocated_class_(::bess::pb::TrafficClass* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.class__);
  }
  _impl_.class__ = reinterpret_cast<::bess::pb::TrafficClass*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.UpdateTcParamsRequest.class)
}
inline ::bess::pb::TrafficClass* UpdateTcParamsRequest::release_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::TrafficClass* released = _impl_.class__;
  _impl_.class__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::TrafficClass* UpdateTcParamsRequest::unsafe_arena_release_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.UpdateTcParamsRequest.class)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::TrafficClass* temp = _impl_.class__;
  _impl_.class__ = nullptr;
  return temp;
}
inline ::bess::pb::TrafficClass* UpdateTcParamsRequest::_internal_mutable_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.class__ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::TrafficClass>(GetArena());
    _impl_.class__ = reinterpret_cast<::bess::pb::TrafficClass*>(p);
  }
  return _impl_.class__;
}
inline ::bess::pb::TrafficClass* UpdateTcParamsRequest::mutable_class_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::TrafficClass* _msg = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:bess.pb.UpdateTcParamsRequest.class)
  return _msg;
}
inline void UpdateTcParamsRequest::set_allocated_class_(::bess::pb::TrafficClass* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::bess::pb::TrafficClass*>(_impl_.class__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::bess::pb::TrafficClass*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.class__ = reinterpret_cast<::bess::pb::TrafficClass*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.UpdateTcParamsRequest.class)
}

// -------------------------------------------------------------------

// UpdateTcParentRequest

// .bess.pb.TrafficClass class = 1;
inline bool UpdateTcParentRequest::has_class_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.class__ != nullptr);
  return value;
}
inline void UpdateTcParentRequest::clear_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.class__ != nullptr) _impl_.class__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::bess::pb::TrafficClass& UpdateTcParentRequest::_internal_class_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::TrafficClass* p = _impl_.class__;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::TrafficClass&>(::bess::pb::_TrafficClass_default_instance_);
}
inline const ::bess::pb::TrafficClass& UpdateTcParentRequest::class_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.UpdateTcParentRequest.class)
  return _internal_class_();
}
inline void UpdateTcParentRequest::unsafe_arena_set_allocated_class_(::bess::pb::TrafficClass* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.class__);
  }
  _impl_.class__ = reinterpret_cast<::bess::pb::TrafficClass*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.UpdateTcParentRequest.class)
}
inline ::bess::pb::TrafficClass* UpdateTcParentRequest::release_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::TrafficClass* released = _impl_.class__;
  _impl_.class__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::TrafficClass* UpdateTcParentRequest::unsafe_arena_release_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.UpdateTcParentRequest.class)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::TrafficClass* temp = _impl_.class__;
  _impl_.class__ = nullptr;
  return temp;
}
inline ::bess::pb::TrafficClass* UpdateTcParentRequest::_internal_mutable_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.class__ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::TrafficClass>(GetArena());
    _impl_.class__ = reinterpret_cast<::bess::pb::TrafficClass*>(p);
  }
  return _impl_.class__;
}
inline ::bess::pb::TrafficClass* UpdateTcParentRequest::mutable_class_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::TrafficClass* _msg = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:bess.pb.UpdateTcParentRequest.class)
  return _msg;
}
inline void UpdateTcParentRequest::set_allocated_class_(::bess::pb::TrafficClass* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::bess::pb::TrafficClass*>(_impl_.class__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::bess::pb::TrafficClass*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.class__ = reinterpret_cast<::bess::pb::TrafficClass*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.UpdateTcParentRequest.class)
}

// -------------------------------------------------------------------

// GetTcStatsRequest

// string name = 1;
inline void GetTcStatsRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetTcStatsRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetTcStatsRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTcStatsRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetTcStatsRequest.name)
}
inline std::string* GetTcStatsRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetTcStatsRequest.name)
  return _s;
}
inline const std::string& GetTcStatsRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetTcStatsRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetTcStatsRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetTcStatsRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetTcStatsRequest.name)
  return _impl_.name_.Release();
}
inline void GetTcStatsRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetTcStatsRequest.name)
}

// -------------------------------------------------------------------

// GetTcStatsResponse

// .bess.pb.Error error = 1;
inline bool GetTcStatsResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& GetTcStatsResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& GetTcStatsResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetTcStatsResponse.error)
  return _internal_error();
}
inline void GetTcStatsResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.GetTcStatsResponse.error)
}
inline ::bess::pb::Error* GetTcStatsResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* GetTcStatsResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetTcStatsResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* GetTcStatsResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* GetTcStatsResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetTcStatsResponse.error)
  return _msg;
}
inline void GetTcStatsResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetTcStatsResponse.error)
}

// double timestamp = 2;
inline void GetTcStatsResponse::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = 0;
}
inline double GetTcStatsResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetTcStatsResponse.timestamp)
  return _internal_timestamp();
}
inline void GetTcStatsResponse::set_timestamp(double value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetTcStatsResponse.timestamp)
}
inline double GetTcStatsResponse::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void GetTcStatsResponse::_internal_set_timestamp(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// uint64 count = 3;
inline void GetTcStatsResponse::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = ::uint64_t{0u};
}
inline ::uint64_t GetTcStatsResponse::count() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetTcStatsResponse.count)
  return _internal_count();
}
inline void GetTcStatsResponse::set_count(::uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetTcStatsResponse.count)
}
inline ::uint64_t GetTcStatsResponse::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void GetTcStatsResponse::_internal_set_count(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.count_ = value;
}

// uint64 cycles = 4;
inline void GetTcStatsResponse::clear_cycles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cycles_ = ::uint64_t{0u};
}
inline ::uint64_t GetTcStatsResponse::cycles() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetTcStatsResponse.cycles)
  return _internal_cycles();
}
inline void GetTcStatsResponse::set_cycles(::uint64_t value) {
  _internal_set_cycles(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetTcStatsResponse.cycles)
}
inline ::uint64_t GetTcStatsResponse::_internal_cycles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cycles_;
}
inline void GetTcStatsResponse::_internal_set_cycles(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cycles_ = value;
}

// uint64 packets = 5;
inline void GetTcStatsResponse::clear_packets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packets_ = ::uint64_t{0u};
}
inline ::uint64_t GetTcStatsResponse::packets() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetTcStatsResponse.packets)
  return _internal_packets();
}
inline void GetTcStatsResponse::set_packets(::uint64_t value) {
  _internal_set_packets(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetTcStatsResponse.packets)
}
inline ::uint64_t GetTcStatsResponse::_internal_packets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packets_;
}
inline void GetTcStatsResponse::_internal_set_packets(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.packets_ = value;
}

// uint64 bits = 6;
inline void GetTcStatsResponse::clear_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bits_ = ::uint64_t{0u};
}
inline ::uint64_t GetTcStatsResponse::bits() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetTcStatsResponse.bits)
  return _internal_bits();
}
inline void GetTcStatsResponse::set_bits(::uint64_t value) {
  _internal_set_bits(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetTcStatsResponse.bits)
}
inline ::uint64_t GetTcStatsResponse::_internal_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bits_;
}
inline void GetTcStatsResponse::_internal_set_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bits_ = value;
}

// -------------------------------------------------------------------

// ListDriversResponse

// .bess.pb.Error error = 1;
inline bool ListDriversResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& ListDriversResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& ListDriversResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListDriversResponse.error)
  return _internal_error();
}
inline void ListDriversResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.ListDriversResponse.error)
}
inline ::bess::pb::Error* ListDriversResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* ListDriversResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListDriversResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* ListDriversResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* ListDriversResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListDriversResponse.error)
  return _msg;
}
inline void ListDriversResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListDriversResponse.error)
}

// repeated string driver_names = 2;
inline int ListDriversResponse::_internal_driver_names_size() const {
  return _internal_driver_names().size();
}
inline int ListDriversResponse::driver_names_size() const {
  return _internal_driver_names_size();
}
inline void ListDriversResponse::clear_driver_names() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.driver_names_.Clear();
}
inline std::string* ListDriversResponse::add_driver_names()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_driver_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:bess.pb.ListDriversResponse.driver_names)
  return _s;
}
inline const std::string& ListDriversResponse::driver_names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListDriversResponse.driver_names)
  return _internal_driver_names().Get(index);
}
inline std::string* ListDriversResponse::mutable_driver_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.ListDriversResponse.driver_names)
  return _internal_mutable_driver_names()->Mutable(index);
}
inline void ListDriversResponse::set_driver_names(int index, const std::string& value) {
  _internal_mutable_driver_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bess.pb.ListDriversResponse.driver_names)
}
inline void ListDriversResponse::set_driver_names(int index, std::string&& value) {
  _internal_mutable_driver_names()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bess.pb.ListDriversResponse.driver_names)
}
inline void ListDriversResponse::set_driver_names(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_driver_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bess.pb.ListDriversResponse.driver_names)
}
inline void ListDriversResponse::set_driver_names(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_driver_names()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bess.pb.ListDriversResponse.driver_names)
}
inline void ListDriversResponse::set_driver_names(int index, absl::string_view value) {
  _internal_mutable_driver_names()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:bess.pb.ListDriversResponse.driver_names)
}
inline void ListDriversResponse::add_driver_names(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_driver_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:bess.pb.ListDriversResponse.driver_names)
}
inline void ListDriversResponse::add_driver_names(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_driver_names()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:bess.pb.ListDriversResponse.driver_names)
}
inline void ListDriversResponse::add_driver_names(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_driver_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bess.pb.ListDriversResponse.driver_names)
}
inline void ListDriversResponse::add_driver_names(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_driver_names()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bess.pb.ListDriversResponse.driver_names)
}
inline void ListDriversResponse::add_driver_names(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_driver_names()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:bess.pb.ListDriversResponse.driver_names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ListDriversResponse::driver_names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.ListDriversResponse.driver_names)
  return _internal_driver_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ListDriversResponse::mutable_driver_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.ListDriversResponse.driver_names)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_driver_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ListDriversResponse::_internal_driver_names() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.driver_names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ListDriversResponse::_internal_mutable_driver_names() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.driver_names_;
}

// -------------------------------------------------------------------

// GetDriverInfoRequest

// string driver_name = 1;
inline void GetDriverInfoRequest::clear_driver_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.driver_name_.ClearToEmpty();
}
inline const std::string& GetDriverInfoRequest::driver_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetDriverInfoRequest.driver_name)
  return _internal_driver_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetDriverInfoRequest::set_driver_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.driver_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetDriverInfoRequest.driver_name)
}
inline std::string* GetDriverInfoRequest::mutable_driver_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_driver_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetDriverInfoRequest.driver_name)
  return _s;
}
inline const std::string& GetDriverInfoRequest::_internal_driver_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.driver_name_.Get();
}
inline void GetDriverInfoRequest::_internal_set_driver_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.driver_name_.Set(value, GetArena());
}
inline std::string* GetDriverInfoRequest::_internal_mutable_driver_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.driver_name_.Mutable( GetArena());
}
inline std::string* GetDriverInfoRequest::release_driver_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetDriverInfoRequest.driver_name)
  return _impl_.driver_name_.Release();
}
inline void GetDriverInfoRequest::set_allocated_driver_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.driver_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.driver_name_.IsDefault()) {
          _impl_.driver_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetDriverInfoRequest.driver_name)
}

// -------------------------------------------------------------------

// GetDriverInfoResponse

// .bess.pb.Error error = 1;
inline bool GetDriverInfoResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& GetDriverInfoResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& GetDriverInfoResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetDriverInfoResponse.error)
  return _internal_error();
}
inline void GetDriverInfoResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.GetDriverInfoResponse.error)
}
inline ::bess::pb::Error* GetDriverInfoResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* GetDriverInfoResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetDriverInfoResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* GetDriverInfoResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* GetDriverInfoResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetDriverInfoResponse.error)
  return _msg;
}
inline void GetDriverInfoResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetDriverInfoResponse.error)
}

// string name = 2;
inline void GetDriverInfoResponse::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetDriverInfoResponse::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetDriverInfoResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetDriverInfoResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetDriverInfoResponse.name)
}
inline std::string* GetDriverInfoResponse::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetDriverInfoResponse.name)
  return _s;
}
inline const std::string& GetDriverInfoResponse::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetDriverInfoResponse::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetDriverInfoResponse::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetDriverInfoResponse::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetDriverInfoResponse.name)
  return _impl_.name_.Release();
}
inline void GetDriverInfoResponse::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetDriverInfoResponse.name)
}

// string help = 3;
inline void GetDriverInfoResponse::clear_help() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.help_.ClearToEmpty();
}
inline const std::string& GetDriverInfoResponse::help() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetDriverInfoResponse.help)
  return _internal_help();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetDriverInfoResponse::set_help(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.help_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetDriverInfoResponse.help)
}
inline std::string* GetDriverInfoResponse::mutable_help() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_help();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetDriverInfoResponse.help)
  return _s;
}
inline const std::string& GetDriverInfoResponse::_internal_help() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.help_.Get();
}
inline void GetDriverInfoResponse::_internal_set_help(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.help_.Set(value, GetArena());
}
inline std::string* GetDriverInfoResponse::_internal_mutable_help() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.help_.Mutable( GetArena());
}
inline std::string* GetDriverInfoResponse::release_help() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetDriverInfoResponse.help)
  return _impl_.help_.Release();
}
inline void GetDriverInfoResponse::set_allocated_help(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.help_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.help_.IsDefault()) {
          _impl_.help_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetDriverInfoResponse.help)
}

// repeated string commands = 4;
inline int GetDriverInfoResponse::_internal_commands_size() const {
  return _internal_commands().size();
}
inline int GetDriverInfoResponse::commands_size() const {
  return _internal_commands_size();
}
inline void GetDriverInfoResponse::clear_commands() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commands_.Clear();
}
inline std::string* GetDriverInfoResponse::add_commands()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_commands()->Add();
  // @@protoc_insertion_point(field_add_mutable:bess.pb.GetDriverInfoResponse.commands)
  return _s;
}
inline const std::string& GetDriverInfoResponse::commands(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetDriverInfoResponse.commands)
  return _internal_commands().Get(index);
}
inline std::string* GetDriverInfoResponse::mutable_commands(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.GetDriverInfoResponse.commands)
  return _internal_mutable_commands()->Mutable(index);
}
inline void GetDriverInfoResponse::set_commands(int index, const std::string& value) {
  _internal_mutable_commands()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetDriverInfoResponse.commands)
}
inline void GetDriverInfoResponse::set_commands(int index, std::string&& value) {
  _internal_mutable_commands()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bess.pb.GetDriverInfoResponse.commands)
}
inline void GetDriverInfoResponse::set_commands(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_commands()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bess.pb.GetDriverInfoResponse.commands)
}
inline void GetDriverInfoResponse::set_commands(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_commands()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bess.pb.GetDriverInfoResponse.commands)
}
inline void GetDriverInfoResponse::set_commands(int index, absl::string_view value) {
  _internal_mutable_commands()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:bess.pb.GetDriverInfoResponse.commands)
}
inline void GetDriverInfoResponse::add_commands(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commands()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:bess.pb.GetDriverInfoResponse.commands)
}
inline void GetDriverInfoResponse::add_commands(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commands()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:bess.pb.GetDriverInfoResponse.commands)
}
inline void GetDriverInfoResponse::add_commands(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commands()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bess.pb.GetDriverInfoResponse.commands)
}
inline void GetDriverInfoResponse::add_commands(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commands()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bess.pb.GetDriverInfoResponse.commands)
}
inline void GetDriverInfoResponse::add_commands(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commands()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:bess.pb.GetDriverInfoResponse.commands)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetDriverInfoResponse::commands() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.GetDriverInfoResponse.commands)
  return _internal_commands();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetDriverInfoResponse::mutable_commands() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.GetDriverInfoResponse.commands)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_commands();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetDriverInfoResponse::_internal_commands() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.commands_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetDriverInfoResponse::_internal_mutable_commands() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.commands_;
}

// -------------------------------------------------------------------

// ListPortsResponse_Port

// string name = 1;
inline void ListPortsResponse_Port::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ListPortsResponse_Port::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListPortsResponse.Port.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListPortsResponse_Port::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.ListPortsResponse.Port.name)
}
inline std::string* ListPortsResponse_Port::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListPortsResponse.Port.name)
  return _s;
}
inline const std::string& ListPortsResponse_Port::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ListPortsResponse_Port::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ListPortsResponse_Port::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ListPortsResponse_Port::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListPortsResponse.Port.name)
  return _impl_.name_.Release();
}
inline void ListPortsResponse_Port::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListPortsResponse.Port.name)
}

// string driver = 2;
inline void ListPortsResponse_Port::clear_driver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.driver_.ClearToEmpty();
}
inline const std::string& ListPortsResponse_Port::driver() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListPortsResponse.Port.driver)
  return _internal_driver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListPortsResponse_Port::set_driver(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.driver_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.ListPortsResponse.Port.driver)
}
inline std::string* ListPortsResponse_Port::mutable_driver() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_driver();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListPortsResponse.Port.driver)
  return _s;
}
inline const std::string& ListPortsResponse_Port::_internal_driver() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.driver_.Get();
}
inline void ListPortsResponse_Port::_internal_set_driver(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.driver_.Set(value, GetArena());
}
inline std::string* ListPortsResponse_Port::_internal_mutable_driver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.driver_.Mutable( GetArena());
}
inline std::string* ListPortsResponse_Port::release_driver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListPortsResponse.Port.driver)
  return _impl_.driver_.Release();
}
inline void ListPortsResponse_Port::set_allocated_driver(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.driver_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.driver_.IsDefault()) {
          _impl_.driver_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListPortsResponse.Port.driver)
}

// string mac_addr = 3;
inline void ListPortsResponse_Port::clear_mac_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_addr_.ClearToEmpty();
}
inline const std::string& ListPortsResponse_Port::mac_addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListPortsResponse.Port.mac_addr)
  return _internal_mac_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListPortsResponse_Port::set_mac_addr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.ListPortsResponse.Port.mac_addr)
}
inline std::string* ListPortsResponse_Port::mutable_mac_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mac_addr();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListPortsResponse.Port.mac_addr)
  return _s;
}
inline const std::string& ListPortsResponse_Port::_internal_mac_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mac_addr_.Get();
}
inline void ListPortsResponse_Port::_internal_set_mac_addr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_addr_.Set(value, GetArena());
}
inline std::string* ListPortsResponse_Port::_internal_mutable_mac_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mac_addr_.Mutable( GetArena());
}
inline std::string* ListPortsResponse_Port::release_mac_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListPortsResponse.Port.mac_addr)
  return _impl_.mac_addr_.Release();
}
inline void ListPortsResponse_Port::set_allocated_mac_addr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mac_addr_.IsDefault()) {
          _impl_.mac_addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListPortsResponse.Port.mac_addr)
}

// uint64 num_inc_q = 4;
inline void ListPortsResponse_Port::clear_num_inc_q() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_inc_q_ = ::uint64_t{0u};
}
inline ::uint64_t ListPortsResponse_Port::num_inc_q() const {
  // @@protoc_insertion_point(field_get:bess.pb.ListPortsResponse.Port.num_inc_q)
  return _internal_num_inc_q();
}
inline void ListPortsResponse_Port::set_num_inc_q(::uint64_t value) {
  _internal_set_num_inc_q(value);
  // @@protoc_insertion_point(field_set:bess.pb.ListPortsResponse.Port.num_inc_q)
}
inline ::uint64_t ListPortsResponse_Port::_internal_num_inc_q() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_inc_q_;
}
inline void ListPortsResponse_Port::_internal_set_num_inc_q(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_inc_q_ = value;
}

// uint64 num_out_q = 5;
inline void ListPortsResponse_Port::clear_num_out_q() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_out_q_ = ::uint64_t{0u};
}
inline ::uint64_t ListPortsResponse_Port::num_out_q() const {
  // @@protoc_insertion_point(field_get:bess.pb.ListPortsResponse.Port.num_out_q)
  return _internal_num_out_q();
}
inline void ListPortsResponse_Port::set_num_out_q(::uint64_t value) {
  _internal_set_num_out_q(value);
  // @@protoc_insertion_point(field_set:bess.pb.ListPortsResponse.Port.num_out_q)
}
inline ::uint64_t ListPortsResponse_Port::_internal_num_out_q() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_out_q_;
}
inline void ListPortsResponse_Port::_internal_set_num_out_q(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_out_q_ = value;
}

// uint64 size_inc_q = 6;
inline void ListPortsResponse_Port::clear_size_inc_q() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_inc_q_ = ::uint64_t{0u};
}
inline ::uint64_t ListPortsResponse_Port::size_inc_q() const {
  // @@protoc_insertion_point(field_get:bess.pb.ListPortsResponse.Port.size_inc_q)
  return _internal_size_inc_q();
}
inline void ListPortsResponse_Port::set_size_inc_q(::uint64_t value) {
  _internal_set_size_inc_q(value);
  // @@protoc_insertion_point(field_set:bess.pb.ListPortsResponse.Port.size_inc_q)
}
inline ::uint64_t ListPortsResponse_Port::_internal_size_inc_q() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_inc_q_;
}
inline void ListPortsResponse_Port::_internal_set_size_inc_q(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_inc_q_ = value;
}

// uint64 size_out_q = 7;
inline void ListPortsResponse_Port::clear_size_out_q() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_out_q_ = ::uint64_t{0u};
}
inline ::uint64_t ListPortsResponse_Port::size_out_q() const {
  // @@protoc_insertion_point(field_get:bess.pb.ListPortsResponse.Port.size_out_q)
  return _internal_size_out_q();
}
inline void ListPortsResponse_Port::set_size_out_q(::uint64_t value) {
  _internal_set_size_out_q(value);
  // @@protoc_insertion_point(field_set:bess.pb.ListPortsResponse.Port.size_out_q)
}
inline ::uint64_t ListPortsResponse_Port::_internal_size_out_q() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_out_q_;
}
inline void ListPortsResponse_Port::_internal_set_size_out_q(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_out_q_ = value;
}

// .google.protobuf.Any driver_arg = 8;
inline bool ListPortsResponse_Port::has_driver_arg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.driver_arg_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& ListPortsResponse_Port::_internal_driver_arg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Any* p = _impl_.driver_arg_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& ListPortsResponse_Port::driver_arg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListPortsResponse.Port.driver_arg)
  return _internal_driver_arg();
}
inline void ListPortsResponse_Port::unsafe_arena_set_allocated_driver_arg(::google::protobuf::Any* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.driver_arg_);
  }
  _impl_.driver_arg_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.ListPortsResponse.Port.driver_arg)
}
inline ::google::protobuf::Any* ListPortsResponse_Port::release_driver_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.driver_arg_;
  _impl_.driver_arg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* ListPortsResponse_Port::unsafe_arena_release_driver_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListPortsResponse.Port.driver_arg)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.driver_arg_;
  _impl_.driver_arg_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* ListPortsResponse_Port::_internal_mutable_driver_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.driver_arg_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArena());
    _impl_.driver_arg_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.driver_arg_;
}
inline ::google::protobuf::Any* ListPortsResponse_Port::mutable_driver_arg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Any* _msg = _internal_mutable_driver_arg();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListPortsResponse.Port.driver_arg)
  return _msg;
}
inline void ListPortsResponse_Port::set_allocated_driver_arg(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.driver_arg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.driver_arg_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListPortsResponse.Port.driver_arg)
}

// -------------------------------------------------------------------

// ListPortsResponse

// .bess.pb.Error error = 1;
inline bool ListPortsResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& ListPortsResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& ListPortsResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListPortsResponse.error)
  return _internal_error();
}
inline void ListPortsResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.ListPortsResponse.error)
}
inline ::bess::pb::Error* ListPortsResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* ListPortsResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListPortsResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* ListPortsResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* ListPortsResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListPortsResponse.error)
  return _msg;
}
inline void ListPortsResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListPortsResponse.error)
}

// repeated .bess.pb.ListPortsResponse.Port ports = 2;
inline int ListPortsResponse::_internal_ports_size() const {
  return _internal_ports().size();
}
inline int ListPortsResponse::ports_size() const {
  return _internal_ports_size();
}
inline void ListPortsResponse::clear_ports() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ports_.Clear();
}
inline ::bess::pb::ListPortsResponse_Port* ListPortsResponse::mutable_ports(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.ListPortsResponse.ports)
  return _internal_mutable_ports()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::ListPortsResponse_Port>* ListPortsResponse::mutable_ports()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.ListPortsResponse.ports)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ports();
}
inline const ::bess::pb::ListPortsResponse_Port& ListPortsResponse::ports(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListPortsResponse.ports)
  return _internal_ports().Get(index);
}
inline ::bess::pb::ListPortsResponse_Port* ListPortsResponse::add_ports() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::bess::pb::ListPortsResponse_Port* _add = _internal_mutable_ports()->Add();
  // @@protoc_insertion_point(field_add:bess.pb.ListPortsResponse.ports)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::ListPortsResponse_Port>& ListPortsResponse::ports() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.ListPortsResponse.ports)
  return _internal_ports();
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::ListPortsResponse_Port>&
ListPortsResponse::_internal_ports() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ports_;
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::ListPortsResponse_Port>*
ListPortsResponse::_internal_mutable_ports() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ports_;
}

// -------------------------------------------------------------------

// CreatePortRequest

// string name = 1;
inline void CreatePortRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreatePortRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CreatePortRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreatePortRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.CreatePortRequest.name)
}
inline std::string* CreatePortRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.CreatePortRequest.name)
  return _s;
}
inline const std::string& CreatePortRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CreatePortRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CreatePortRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CreatePortRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CreatePortRequest.name)
  return _impl_.name_.Release();
}
inline void CreatePortRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CreatePortRequest.name)
}

// string driver = 2;
inline void CreatePortRequest::clear_driver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.driver_.ClearToEmpty();
}
inline const std::string& CreatePortRequest::driver() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CreatePortRequest.driver)
  return _internal_driver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreatePortRequest::set_driver(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.driver_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.CreatePortRequest.driver)
}
inline std::string* CreatePortRequest::mutable_driver() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_driver();
  // @@protoc_insertion_point(field_mutable:bess.pb.CreatePortRequest.driver)
  return _s;
}
inline const std::string& CreatePortRequest::_internal_driver() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.driver_.Get();
}
inline void CreatePortRequest::_internal_set_driver(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.driver_.Set(value, GetArena());
}
inline std::string* CreatePortRequest::_internal_mutable_driver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.driver_.Mutable( GetArena());
}
inline std::string* CreatePortRequest::release_driver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CreatePortRequest.driver)
  return _impl_.driver_.Release();
}
inline void CreatePortRequest::set_allocated_driver(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.driver_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.driver_.IsDefault()) {
          _impl_.driver_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CreatePortRequest.driver)
}

// uint64 num_inc_q = 3;
inline void CreatePortRequest::clear_num_inc_q() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_inc_q_ = ::uint64_t{0u};
}
inline ::uint64_t CreatePortRequest::num_inc_q() const {
  // @@protoc_insertion_point(field_get:bess.pb.CreatePortRequest.num_inc_q)
  return _internal_num_inc_q();
}
inline void CreatePortRequest::set_num_inc_q(::uint64_t value) {
  _internal_set_num_inc_q(value);
  // @@protoc_insertion_point(field_set:bess.pb.CreatePortRequest.num_inc_q)
}
inline ::uint64_t CreatePortRequest::_internal_num_inc_q() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_inc_q_;
}
inline void CreatePortRequest::_internal_set_num_inc_q(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_inc_q_ = value;
}

// uint64 num_out_q = 4;
inline void CreatePortRequest::clear_num_out_q() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_out_q_ = ::uint64_t{0u};
}
inline ::uint64_t CreatePortRequest::num_out_q() const {
  // @@protoc_insertion_point(field_get:bess.pb.CreatePortRequest.num_out_q)
  return _internal_num_out_q();
}
inline void CreatePortRequest::set_num_out_q(::uint64_t value) {
  _internal_set_num_out_q(value);
  // @@protoc_insertion_point(field_set:bess.pb.CreatePortRequest.num_out_q)
}
inline ::uint64_t CreatePortRequest::_internal_num_out_q() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_out_q_;
}
inline void CreatePortRequest::_internal_set_num_out_q(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_out_q_ = value;
}

// uint64 size_inc_q = 5;
inline void CreatePortRequest::clear_size_inc_q() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_inc_q_ = ::uint64_t{0u};
}
inline ::uint64_t CreatePortRequest::size_inc_q() const {
  // @@protoc_insertion_point(field_get:bess.pb.CreatePortRequest.size_inc_q)
  return _internal_size_inc_q();
}
inline void CreatePortRequest::set_size_inc_q(::uint64_t value) {
  _internal_set_size_inc_q(value);
  // @@protoc_insertion_point(field_set:bess.pb.CreatePortRequest.size_inc_q)
}
inline ::uint64_t CreatePortRequest::_internal_size_inc_q() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_inc_q_;
}
inline void CreatePortRequest::_internal_set_size_inc_q(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_inc_q_ = value;
}

// uint64 size_out_q = 6;
inline void CreatePortRequest::clear_size_out_q() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_out_q_ = ::uint64_t{0u};
}
inline ::uint64_t CreatePortRequest::size_out_q() const {
  // @@protoc_insertion_point(field_get:bess.pb.CreatePortRequest.size_out_q)
  return _internal_size_out_q();
}
inline void CreatePortRequest::set_size_out_q(::uint64_t value) {
  _internal_set_size_out_q(value);
  // @@protoc_insertion_point(field_set:bess.pb.CreatePortRequest.size_out_q)
}
inline ::uint64_t CreatePortRequest::_internal_size_out_q() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_out_q_;
}
inline void CreatePortRequest::_internal_set_size_out_q(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_out_q_ = value;
}

// .google.protobuf.Any arg = 7;
inline bool CreatePortRequest::has_arg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arg_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& CreatePortRequest::_internal_arg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Any* p = _impl_.arg_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& CreatePortRequest::arg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CreatePortRequest.arg)
  return _internal_arg();
}
inline void CreatePortRequest::unsafe_arena_set_allocated_arg(::google::protobuf::Any* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arg_);
  }
  _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.CreatePortRequest.arg)
}
inline ::google::protobuf::Any* CreatePortRequest::release_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.arg_;
  _impl_.arg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* CreatePortRequest::unsafe_arena_release_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CreatePortRequest.arg)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.arg_;
  _impl_.arg_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* CreatePortRequest::_internal_mutable_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.arg_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArena());
    _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.arg_;
}
inline ::google::protobuf::Any* CreatePortRequest::mutable_arg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Any* _msg = _internal_mutable_arg();
  // @@protoc_insertion_point(field_mutable:bess.pb.CreatePortRequest.arg)
  return _msg;
}
inline void CreatePortRequest::set_allocated_arg(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CreatePortRequest.arg)
}

// -------------------------------------------------------------------

// PortConf

// string mac_addr = 1;
inline void PortConf::clear_mac_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_addr_.ClearToEmpty();
}
inline const std::string& PortConf::mac_addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.PortConf.mac_addr)
  return _internal_mac_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PortConf::set_mac_addr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.PortConf.mac_addr)
}
inline std::string* PortConf::mutable_mac_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mac_addr();
  // @@protoc_insertion_point(field_mutable:bess.pb.PortConf.mac_addr)
  return _s;
}
inline const std::string& PortConf::_internal_mac_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mac_addr_.Get();
}
inline void PortConf::_internal_set_mac_addr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_addr_.Set(value, GetArena());
}
inline std::string* PortConf::_internal_mutable_mac_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mac_addr_.Mutable( GetArena());
}
inline std::string* PortConf::release_mac_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.PortConf.mac_addr)
  return _impl_.mac_addr_.Release();
}
inline void PortConf::set_allocated_mac_addr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mac_addr_.IsDefault()) {
          _impl_.mac_addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.PortConf.mac_addr)
}

// uint32 mtu = 2;
inline void PortConf::clear_mtu() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mtu_ = 0u;
}
inline ::uint32_t PortConf::mtu() const {
  // @@protoc_insertion_point(field_get:bess.pb.PortConf.mtu)
  return _internal_mtu();
}
inline void PortConf::set_mtu(::uint32_t value) {
  _internal_set_mtu(value);
  // @@protoc_insertion_point(field_set:bess.pb.PortConf.mtu)
}
inline ::uint32_t PortConf::_internal_mtu() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mtu_;
}
inline void PortConf::_internal_set_mtu(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mtu_ = value;
}

// bool admin_up = 3;
inline void PortConf::clear_admin_up() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.admin_up_ = false;
}
inline bool PortConf::admin_up() const {
  // @@protoc_insertion_point(field_get:bess.pb.PortConf.admin_up)
  return _internal_admin_up();
}
inline void PortConf::set_admin_up(bool value) {
  _internal_set_admin_up(value);
  // @@protoc_insertion_point(field_set:bess.pb.PortConf.admin_up)
}
inline bool PortConf::_internal_admin_up() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.admin_up_;
}
inline void PortConf::_internal_set_admin_up(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.admin_up_ = value;
}

// -------------------------------------------------------------------

// SetPortConfRequest

// string name = 1;
inline void SetPortConfRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SetPortConfRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.SetPortConfRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetPortConfRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.SetPortConfRequest.name)
}
inline std::string* SetPortConfRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.SetPortConfRequest.name)
  return _s;
}
inline const std::string& SetPortConfRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void SetPortConfRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* SetPortConfRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* SetPortConfRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.SetPortConfRequest.name)
  return _impl_.name_.Release();
}
inline void SetPortConfRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.SetPortConfRequest.name)
}

// .bess.pb.PortConf conf = 2;
inline bool SetPortConfRequest::has_conf() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conf_ != nullptr);
  return value;
}
inline void SetPortConfRequest::clear_conf() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.conf_ != nullptr) _impl_.conf_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::bess::pb::PortConf& SetPortConfRequest::_internal_conf() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::PortConf* p = _impl_.conf_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::PortConf&>(::bess::pb::_PortConf_default_instance_);
}
inline const ::bess::pb::PortConf& SetPortConfRequest::conf() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.SetPortConfRequest.conf)
  return _internal_conf();
}
inline void SetPortConfRequest::unsafe_arena_set_allocated_conf(::bess::pb::PortConf* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conf_);
  }
  _impl_.conf_ = reinterpret_cast<::bess::pb::PortConf*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.SetPortConfRequest.conf)
}
inline ::bess::pb::PortConf* SetPortConfRequest::release_conf() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::PortConf* released = _impl_.conf_;
  _impl_.conf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::PortConf* SetPortConfRequest::unsafe_arena_release_conf() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.SetPortConfRequest.conf)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::PortConf* temp = _impl_.conf_;
  _impl_.conf_ = nullptr;
  return temp;
}
inline ::bess::pb::PortConf* SetPortConfRequest::_internal_mutable_conf() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.conf_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::PortConf>(GetArena());
    _impl_.conf_ = reinterpret_cast<::bess::pb::PortConf*>(p);
  }
  return _impl_.conf_;
}
inline ::bess::pb::PortConf* SetPortConfRequest::mutable_conf() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::PortConf* _msg = _internal_mutable_conf();
  // @@protoc_insertion_point(field_mutable:bess.pb.SetPortConfRequest.conf)
  return _msg;
}
inline void SetPortConfRequest::set_allocated_conf(::bess::pb::PortConf* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::bess::pb::PortConf*>(_impl_.conf_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::bess::pb::PortConf*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.conf_ = reinterpret_cast<::bess::pb::PortConf*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.SetPortConfRequest.conf)
}

// -------------------------------------------------------------------

// GetPortConfRequest

// string name = 1;
inline void GetPortConfRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetPortConfRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetPortConfRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPortConfRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetPortConfRequest.name)
}
inline std::string* GetPortConfRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetPortConfRequest.name)
  return _s;
}
inline const std::string& GetPortConfRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetPortConfRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetPortConfRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetPortConfRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetPortConfRequest.name)
  return _impl_.name_.Release();
}
inline void GetPortConfRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetPortConfRequest.name)
}

// -------------------------------------------------------------------

// GetPortConfResponse

// .bess.pb.Error error = 1;
inline bool GetPortConfResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& GetPortConfResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& GetPortConfResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetPortConfResponse.error)
  return _internal_error();
}
inline void GetPortConfResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.GetPortConfResponse.error)
}
inline ::bess::pb::Error* GetPortConfResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* GetPortConfResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetPortConfResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* GetPortConfResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* GetPortConfResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetPortConfResponse.error)
  return _msg;
}
inline void GetPortConfResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetPortConfResponse.error)
}

// .bess.pb.PortConf conf = 2;
inline bool GetPortConfResponse::has_conf() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conf_ != nullptr);
  return value;
}
inline void GetPortConfResponse::clear_conf() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.conf_ != nullptr) _impl_.conf_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::bess::pb::PortConf& GetPortConfResponse::_internal_conf() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::PortConf* p = _impl_.conf_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::PortConf&>(::bess::pb::_PortConf_default_instance_);
}
inline const ::bess::pb::PortConf& GetPortConfResponse::conf() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetPortConfResponse.conf)
  return _internal_conf();
}
inline void GetPortConfResponse::unsafe_arena_set_allocated_conf(::bess::pb::PortConf* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.conf_);
  }
  _impl_.conf_ = reinterpret_cast<::bess::pb::PortConf*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.GetPortConfResponse.conf)
}
inline ::bess::pb::PortConf* GetPortConfResponse::release_conf() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::bess::pb::PortConf* released = _impl_.conf_;
  _impl_.conf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::PortConf* GetPortConfResponse::unsafe_arena_release_conf() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetPortConfResponse.conf)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::bess::pb::PortConf* temp = _impl_.conf_;
  _impl_.conf_ = nullptr;
  return temp;
}
inline ::bess::pb::PortConf* GetPortConfResponse::_internal_mutable_conf() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.conf_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::PortConf>(GetArena());
    _impl_.conf_ = reinterpret_cast<::bess::pb::PortConf*>(p);
  }
  return _impl_.conf_;
}
inline ::bess::pb::PortConf* GetPortConfResponse::mutable_conf() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::PortConf* _msg = _internal_mutable_conf();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetPortConfResponse.conf)
  return _msg;
}
inline void GetPortConfResponse::set_allocated_conf(::bess::pb::PortConf* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::bess::pb::PortConf*>(_impl_.conf_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::bess::pb::PortConf*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.conf_ = reinterpret_cast<::bess::pb::PortConf*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetPortConfResponse.conf)
}

// -------------------------------------------------------------------

// CreatePortResponse

// .bess.pb.Error error = 1;
inline bool CreatePortResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& CreatePortResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& CreatePortResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CreatePortResponse.error)
  return _internal_error();
}
inline void CreatePortResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.CreatePortResponse.error)
}
inline ::bess::pb::Error* CreatePortResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* CreatePortResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CreatePortResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* CreatePortResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* CreatePortResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.CreatePortResponse.error)
  return _msg;
}
inline void CreatePortResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CreatePortResponse.error)
}

// string name = 2;
inline void CreatePortResponse::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreatePortResponse::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CreatePortResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreatePortResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.CreatePortResponse.name)
}
inline std::string* CreatePortResponse::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.CreatePortResponse.name)
  return _s;
}
inline const std::string& CreatePortResponse::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CreatePortResponse::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CreatePortResponse::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CreatePortResponse::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CreatePortResponse.name)
  return _impl_.name_.Release();
}
inline void CreatePortResponse::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CreatePortResponse.name)
}

// string mac_addr = 3;
inline void CreatePortResponse::clear_mac_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_addr_.ClearToEmpty();
}
inline const std::string& CreatePortResponse::mac_addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CreatePortResponse.mac_addr)
  return _internal_mac_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreatePortResponse::set_mac_addr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.CreatePortResponse.mac_addr)
}
inline std::string* CreatePortResponse::mutable_mac_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mac_addr();
  // @@protoc_insertion_point(field_mutable:bess.pb.CreatePortResponse.mac_addr)
  return _s;
}
inline const std::string& CreatePortResponse::_internal_mac_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mac_addr_.Get();
}
inline void CreatePortResponse::_internal_set_mac_addr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mac_addr_.Set(value, GetArena());
}
inline std::string* CreatePortResponse::_internal_mutable_mac_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mac_addr_.Mutable( GetArena());
}
inline std::string* CreatePortResponse::release_mac_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CreatePortResponse.mac_addr)
  return _impl_.mac_addr_.Release();
}
inline void CreatePortResponse::set_allocated_mac_addr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mac_addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mac_addr_.IsDefault()) {
          _impl_.mac_addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CreatePortResponse.mac_addr)
}

// -------------------------------------------------------------------

// DestroyPortRequest

// string name = 1;
inline void DestroyPortRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DestroyPortRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.DestroyPortRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DestroyPortRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.DestroyPortRequest.name)
}
inline std::string* DestroyPortRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.DestroyPortRequest.name)
  return _s;
}
inline const std::string& DestroyPortRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void DestroyPortRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* DestroyPortRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* DestroyPortRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.DestroyPortRequest.name)
  return _impl_.name_.Release();
}
inline void DestroyPortRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.DestroyPortRequest.name)
}

// -------------------------------------------------------------------

// GetPortStatsRequest

// string name = 1;
inline void GetPortStatsRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetPortStatsRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetPortStatsRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPortStatsRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetPortStatsRequest.name)
}
inline std::string* GetPortStatsRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetPortStatsRequest.name)
  return _s;
}
inline const std::string& GetPortStatsRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetPortStatsRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetPortStatsRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetPortStatsRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetPortStatsRequest.name)
  return _impl_.name_.Release();
}
inline void GetPortStatsRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetPortStatsRequest.name)
}

// -------------------------------------------------------------------

// GetPortStatsResponse_Stat

// uint64 packets = 1;
inline void GetPortStatsResponse_Stat::clear_packets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packets_ = ::uint64_t{0u};
}
inline ::uint64_t GetPortStatsResponse_Stat::packets() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetPortStatsResponse.Stat.packets)
  return _internal_packets();
}
inline void GetPortStatsResponse_Stat::set_packets(::uint64_t value) {
  _internal_set_packets(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetPortStatsResponse.Stat.packets)
}
inline ::uint64_t GetPortStatsResponse_Stat::_internal_packets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packets_;
}
inline void GetPortStatsResponse_Stat::_internal_set_packets(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.packets_ = value;
}

// uint64 dropped = 2;
inline void GetPortStatsResponse_Stat::clear_dropped() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dropped_ = ::uint64_t{0u};
}
inline ::uint64_t GetPortStatsResponse_Stat::dropped() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetPortStatsResponse.Stat.dropped)
  return _internal_dropped();
}
inline void GetPortStatsResponse_Stat::set_dropped(::uint64_t value) {
  _internal_set_dropped(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetPortStatsResponse.Stat.dropped)
}
inline ::uint64_t GetPortStatsResponse_Stat::_internal_dropped() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dropped_;
}
inline void GetPortStatsResponse_Stat::_internal_set_dropped(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dropped_ = value;
}

// uint64 bytes = 3;
inline void GetPortStatsResponse_Stat::clear_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bytes_ = ::uint64_t{0u};
}
inline ::uint64_t GetPortStatsResponse_Stat::bytes() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetPortStatsResponse.Stat.bytes)
  return _internal_bytes();
}
inline void GetPortStatsResponse_Stat::set_bytes(::uint64_t value) {
  _internal_set_bytes(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetPortStatsResponse.Stat.bytes)
}
inline ::uint64_t GetPortStatsResponse_Stat::_internal_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bytes_;
}
inline void GetPortStatsResponse_Stat::_internal_set_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bytes_ = value;
}

// repeated uint64 requested_hist = 4;
inline int GetPortStatsResponse_Stat::_internal_requested_hist_size() const {
  return _internal_requested_hist().size();
}
inline int GetPortStatsResponse_Stat::requested_hist_size() const {
  return _internal_requested_hist_size();
}
inline void GetPortStatsResponse_Stat::clear_requested_hist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requested_hist_.Clear();
}
inline ::uint64_t GetPortStatsResponse_Stat::requested_hist(int index) const {
  // @@protoc_insertion_point(field_get:bess.pb.GetPortStatsResponse.Stat.requested_hist)
  return _internal_requested_hist().Get(index);
}
inline void GetPortStatsResponse_Stat::set_requested_hist(int index, ::uint64_t value) {
  _internal_mutable_requested_hist()->Set(index, value);
  // @@protoc_insertion_point(field_set:bess.pb.GetPortStatsResponse.Stat.requested_hist)
}
inline void GetPortStatsResponse_Stat::add_requested_hist(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_requested_hist()->Add(value);
  // @@protoc_insertion_point(field_add:bess.pb.GetPortStatsResponse.Stat.requested_hist)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& GetPortStatsResponse_Stat::requested_hist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.GetPortStatsResponse.Stat.requested_hist)
  return _internal_requested_hist();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* GetPortStatsResponse_Stat::mutable_requested_hist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.GetPortStatsResponse.Stat.requested_hist)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_requested_hist();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& GetPortStatsResponse_Stat::_internal_requested_hist()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requested_hist_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* GetPortStatsResponse_Stat::_internal_mutable_requested_hist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.requested_hist_;
}

// repeated uint64 actual_hist = 5;
inline int GetPortStatsResponse_Stat::_internal_actual_hist_size() const {
  return _internal_actual_hist().size();
}
inline int GetPortStatsResponse_Stat::actual_hist_size() const {
  return _internal_actual_hist_size();
}
inline void GetPortStatsResponse_Stat::clear_actual_hist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.actual_hist_.Clear();
}
inline ::uint64_t GetPortStatsResponse_Stat::actual_hist(int index) const {
  // @@protoc_insertion_point(field_get:bess.pb.GetPortStatsResponse.Stat.actual_hist)
  return _internal_actual_hist().Get(index);
}
inline void GetPortStatsResponse_Stat::set_actual_hist(int index, ::uint64_t value) {
  _internal_mutable_actual_hist()->Set(index, value);
  // @@protoc_insertion_point(field_set:bess.pb.GetPortStatsResponse.Stat.actual_hist)
}
inline void GetPortStatsResponse_Stat::add_actual_hist(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_actual_hist()->Add(value);
  // @@protoc_insertion_point(field_add:bess.pb.GetPortStatsResponse.Stat.actual_hist)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& GetPortStatsResponse_Stat::actual_hist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.GetPortStatsResponse.Stat.actual_hist)
  return _internal_actual_hist();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* GetPortStatsResponse_Stat::mutable_actual_hist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.GetPortStatsResponse.Stat.actual_hist)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_actual_hist();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& GetPortStatsResponse_Stat::_internal_actual_hist()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.actual_hist_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* GetPortStatsResponse_Stat::_internal_mutable_actual_hist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.actual_hist_;
}

// repeated uint64 diff_hist = 6;
inline int GetPortStatsResponse_Stat::_internal_diff_hist_size() const {
  return _internal_diff_hist().size();
}
inline int GetPortStatsResponse_Stat::diff_hist_size() const {
  return _internal_diff_hist_size();
}
inline void GetPortStatsResponse_Stat::clear_diff_hist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.diff_hist_.Clear();
}
inline ::uint64_t GetPortStatsResponse_Stat::diff_hist(int index) const {
  // @@protoc_insertion_point(field_get:bess.pb.GetPortStatsResponse.Stat.diff_hist)
  return _internal_diff_hist().Get(index);
}
inline void GetPortStatsResponse_Stat::set_diff_hist(int index, ::uint64_t value) {
  _internal_mutable_diff_hist()->Set(index, value);
  // @@protoc_insertion_point(field_set:bess.pb.GetPortStatsResponse.Stat.diff_hist)
}
inline void GetPortStatsResponse_Stat::add_diff_hist(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_diff_hist()->Add(value);
  // @@protoc_insertion_point(field_add:bess.pb.GetPortStatsResponse.Stat.diff_hist)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& GetPortStatsResponse_Stat::diff_hist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.GetPortStatsResponse.Stat.diff_hist)
  return _internal_diff_hist();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* GetPortStatsResponse_Stat::mutable_diff_hist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.GetPortStatsResponse.Stat.diff_hist)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_diff_hist();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& GetPortStatsResponse_Stat::_internal_diff_hist()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.diff_hist_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* GetPortStatsResponse_Stat::_internal_mutable_diff_hist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.diff_hist_;
}

// -------------------------------------------------------------------

// GetPortStatsResponse

// .bess.pb.Error error = 1;
inline bool GetPortStatsResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& GetPortStatsResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& GetPortStatsResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetPortStatsResponse.error)
  return _internal_error();
}
inline void GetPortStatsResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.GetPortStatsResponse.error)
}
inline ::bess::pb::Error* GetPortStatsResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* GetPortStatsResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetPortStatsResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* GetPortStatsResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* GetPortStatsResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetPortStatsResponse.error)
  return _msg;
}
inline void GetPortStatsResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetPortStatsResponse.error)
}

// .bess.pb.GetPortStatsResponse.Stat inc = 2;
inline bool GetPortStatsResponse::has_inc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inc_ != nullptr);
  return value;
}
inline void GetPortStatsResponse::clear_inc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.inc_ != nullptr) _impl_.inc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::bess::pb::GetPortStatsResponse_Stat& GetPortStatsResponse::_internal_inc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::GetPortStatsResponse_Stat* p = _impl_.inc_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::GetPortStatsResponse_Stat&>(::bess::pb::_GetPortStatsResponse_Stat_default_instance_);
}
inline const ::bess::pb::GetPortStatsResponse_Stat& GetPortStatsResponse::inc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetPortStatsResponse.inc)
  return _internal_inc();
}
inline void GetPortStatsResponse::unsafe_arena_set_allocated_inc(::bess::pb::GetPortStatsResponse_Stat* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inc_);
  }
  _impl_.inc_ = reinterpret_cast<::bess::pb::GetPortStatsResponse_Stat*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.GetPortStatsResponse.inc)
}
inline ::bess::pb::GetPortStatsResponse_Stat* GetPortStatsResponse::release_inc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::bess::pb::GetPortStatsResponse_Stat* released = _impl_.inc_;
  _impl_.inc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::GetPortStatsResponse_Stat* GetPortStatsResponse::unsafe_arena_release_inc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetPortStatsResponse.inc)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::bess::pb::GetPortStatsResponse_Stat* temp = _impl_.inc_;
  _impl_.inc_ = nullptr;
  return temp;
}
inline ::bess::pb::GetPortStatsResponse_Stat* GetPortStatsResponse::_internal_mutable_inc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.inc_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::GetPortStatsResponse_Stat>(GetArena());
    _impl_.inc_ = reinterpret_cast<::bess::pb::GetPortStatsResponse_Stat*>(p);
  }
  return _impl_.inc_;
}
inline ::bess::pb::GetPortStatsResponse_Stat* GetPortStatsResponse::mutable_inc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::GetPortStatsResponse_Stat* _msg = _internal_mutable_inc();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetPortStatsResponse.inc)
  return _msg;
}
inline void GetPortStatsResponse::set_allocated_inc(::bess::pb::GetPortStatsResponse_Stat* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::bess::pb::GetPortStatsResponse_Stat*>(_impl_.inc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::bess::pb::GetPortStatsResponse_Stat*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.inc_ = reinterpret_cast<::bess::pb::GetPortStatsResponse_Stat*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetPortStatsResponse.inc)
}

// .bess.pb.GetPortStatsResponse.Stat out = 3;
inline bool GetPortStatsResponse::has_out() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.out_ != nullptr);
  return value;
}
inline void GetPortStatsResponse::clear_out() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.out_ != nullptr) _impl_.out_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::bess::pb::GetPortStatsResponse_Stat& GetPortStatsResponse::_internal_out() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::GetPortStatsResponse_Stat* p = _impl_.out_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::GetPortStatsResponse_Stat&>(::bess::pb::_GetPortStatsResponse_Stat_default_instance_);
}
inline const ::bess::pb::GetPortStatsResponse_Stat& GetPortStatsResponse::out() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetPortStatsResponse.out)
  return _internal_out();
}
inline void GetPortStatsResponse::unsafe_arena_set_allocated_out(::bess::pb::GetPortStatsResponse_Stat* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.out_);
  }
  _impl_.out_ = reinterpret_cast<::bess::pb::GetPortStatsResponse_Stat*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.GetPortStatsResponse.out)
}
inline ::bess::pb::GetPortStatsResponse_Stat* GetPortStatsResponse::release_out() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::bess::pb::GetPortStatsResponse_Stat* released = _impl_.out_;
  _impl_.out_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::GetPortStatsResponse_Stat* GetPortStatsResponse::unsafe_arena_release_out() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetPortStatsResponse.out)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::bess::pb::GetPortStatsResponse_Stat* temp = _impl_.out_;
  _impl_.out_ = nullptr;
  return temp;
}
inline ::bess::pb::GetPortStatsResponse_Stat* GetPortStatsResponse::_internal_mutable_out() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.out_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::GetPortStatsResponse_Stat>(GetArena());
    _impl_.out_ = reinterpret_cast<::bess::pb::GetPortStatsResponse_Stat*>(p);
  }
  return _impl_.out_;
}
inline ::bess::pb::GetPortStatsResponse_Stat* GetPortStatsResponse::mutable_out() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::GetPortStatsResponse_Stat* _msg = _internal_mutable_out();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetPortStatsResponse.out)
  return _msg;
}
inline void GetPortStatsResponse::set_allocated_out(::bess::pb::GetPortStatsResponse_Stat* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::bess::pb::GetPortStatsResponse_Stat*>(_impl_.out_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::bess::pb::GetPortStatsResponse_Stat*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.out_ = reinterpret_cast<::bess::pb::GetPortStatsResponse_Stat*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetPortStatsResponse.out)
}

// double timestamp = 4;
inline void GetPortStatsResponse::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = 0;
}
inline double GetPortStatsResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetPortStatsResponse.timestamp)
  return _internal_timestamp();
}
inline void GetPortStatsResponse::set_timestamp(double value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetPortStatsResponse.timestamp)
}
inline double GetPortStatsResponse::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void GetPortStatsResponse::_internal_set_timestamp(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// GetLinkStatusRequest

// string name = 1;
inline void GetLinkStatusRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetLinkStatusRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetLinkStatusRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetLinkStatusRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetLinkStatusRequest.name)
}
inline std::string* GetLinkStatusRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetLinkStatusRequest.name)
  return _s;
}
inline const std::string& GetLinkStatusRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetLinkStatusRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetLinkStatusRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetLinkStatusRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetLinkStatusRequest.name)
  return _impl_.name_.Release();
}
inline void GetLinkStatusRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetLinkStatusRequest.name)
}

// -------------------------------------------------------------------

// GetLinkStatusResponse

// .bess.pb.Error error = 1;
inline bool GetLinkStatusResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& GetLinkStatusResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& GetLinkStatusResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetLinkStatusResponse.error)
  return _internal_error();
}
inline void GetLinkStatusResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.GetLinkStatusResponse.error)
}
inline ::bess::pb::Error* GetLinkStatusResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* GetLinkStatusResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetLinkStatusResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* GetLinkStatusResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* GetLinkStatusResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetLinkStatusResponse.error)
  return _msg;
}
inline void GetLinkStatusResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetLinkStatusResponse.error)
}

// uint32 speed = 2;
inline void GetLinkStatusResponse::clear_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_ = 0u;
}
inline ::uint32_t GetLinkStatusResponse::speed() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetLinkStatusResponse.speed)
  return _internal_speed();
}
inline void GetLinkStatusResponse::set_speed(::uint32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetLinkStatusResponse.speed)
}
inline ::uint32_t GetLinkStatusResponse::_internal_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speed_;
}
inline void GetLinkStatusResponse::_internal_set_speed(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.speed_ = value;
}

// bool full_duplex = 3;
inline void GetLinkStatusResponse::clear_full_duplex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.full_duplex_ = false;
}
inline bool GetLinkStatusResponse::full_duplex() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetLinkStatusResponse.full_duplex)
  return _internal_full_duplex();
}
inline void GetLinkStatusResponse::set_full_duplex(bool value) {
  _internal_set_full_duplex(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetLinkStatusResponse.full_duplex)
}
inline bool GetLinkStatusResponse::_internal_full_duplex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.full_duplex_;
}
inline void GetLinkStatusResponse::_internal_set_full_duplex(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.full_duplex_ = value;
}

// bool autoneg = 4;
inline void GetLinkStatusResponse::clear_autoneg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.autoneg_ = false;
}
inline bool GetLinkStatusResponse::autoneg() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetLinkStatusResponse.autoneg)
  return _internal_autoneg();
}
inline void GetLinkStatusResponse::set_autoneg(bool value) {
  _internal_set_autoneg(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetLinkStatusResponse.autoneg)
}
inline bool GetLinkStatusResponse::_internal_autoneg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.autoneg_;
}
inline void GetLinkStatusResponse::_internal_set_autoneg(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.autoneg_ = value;
}

// bool link_up = 5;
inline void GetLinkStatusResponse::clear_link_up() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.link_up_ = false;
}
inline bool GetLinkStatusResponse::link_up() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetLinkStatusResponse.link_up)
  return _internal_link_up();
}
inline void GetLinkStatusResponse::set_link_up(bool value) {
  _internal_set_link_up(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetLinkStatusResponse.link_up)
}
inline bool GetLinkStatusResponse::_internal_link_up() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.link_up_;
}
inline void GetLinkStatusResponse::_internal_set_link_up(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.link_up_ = value;
}

// -------------------------------------------------------------------

// ListMclassResponse

// .bess.pb.Error error = 1;
inline bool ListMclassResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& ListMclassResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& ListMclassResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListMclassResponse.error)
  return _internal_error();
}
inline void ListMclassResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.ListMclassResponse.error)
}
inline ::bess::pb::Error* ListMclassResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* ListMclassResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListMclassResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* ListMclassResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* ListMclassResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListMclassResponse.error)
  return _msg;
}
inline void ListMclassResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListMclassResponse.error)
}

// repeated string names = 2;
inline int ListMclassResponse::_internal_names_size() const {
  return _internal_names().size();
}
inline int ListMclassResponse::names_size() const {
  return _internal_names_size();
}
inline void ListMclassResponse::clear_names() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.names_.Clear();
}
inline std::string* ListMclassResponse::add_names()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:bess.pb.ListMclassResponse.names)
  return _s;
}
inline const std::string& ListMclassResponse::names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListMclassResponse.names)
  return _internal_names().Get(index);
}
inline std::string* ListMclassResponse::mutable_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.ListMclassResponse.names)
  return _internal_mutable_names()->Mutable(index);
}
inline void ListMclassResponse::set_names(int index, const std::string& value) {
  _internal_mutable_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bess.pb.ListMclassResponse.names)
}
inline void ListMclassResponse::set_names(int index, std::string&& value) {
  _internal_mutable_names()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bess.pb.ListMclassResponse.names)
}
inline void ListMclassResponse::set_names(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bess.pb.ListMclassResponse.names)
}
inline void ListMclassResponse::set_names(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_names()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bess.pb.ListMclassResponse.names)
}
inline void ListMclassResponse::set_names(int index, absl::string_view value) {
  _internal_mutable_names()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:bess.pb.ListMclassResponse.names)
}
inline void ListMclassResponse::add_names(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:bess.pb.ListMclassResponse.names)
}
inline void ListMclassResponse::add_names(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:bess.pb.ListMclassResponse.names)
}
inline void ListMclassResponse::add_names(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bess.pb.ListMclassResponse.names)
}
inline void ListMclassResponse::add_names(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bess.pb.ListMclassResponse.names)
}
inline void ListMclassResponse::add_names(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:bess.pb.ListMclassResponse.names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ListMclassResponse::names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.ListMclassResponse.names)
  return _internal_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ListMclassResponse::mutable_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.ListMclassResponse.names)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ListMclassResponse::_internal_names() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ListMclassResponse::_internal_mutable_names() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.names_;
}

// -------------------------------------------------------------------

// GetMclassInfoRequest

// string name = 1;
inline void GetMclassInfoRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetMclassInfoRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetMclassInfoRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetMclassInfoRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetMclassInfoRequest.name)
}
inline std::string* GetMclassInfoRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetMclassInfoRequest.name)
  return _s;
}
inline const std::string& GetMclassInfoRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetMclassInfoRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetMclassInfoRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetMclassInfoRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetMclassInfoRequest.name)
  return _impl_.name_.Release();
}
inline void GetMclassInfoRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetMclassInfoRequest.name)
}

// -------------------------------------------------------------------

// GetMclassInfoResponse

// .bess.pb.Error error = 1;
inline bool GetMclassInfoResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& GetMclassInfoResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& GetMclassInfoResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetMclassInfoResponse.error)
  return _internal_error();
}
inline void GetMclassInfoResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.GetMclassInfoResponse.error)
}
inline ::bess::pb::Error* GetMclassInfoResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* GetMclassInfoResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetMclassInfoResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* GetMclassInfoResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* GetMclassInfoResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetMclassInfoResponse.error)
  return _msg;
}
inline void GetMclassInfoResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetMclassInfoResponse.error)
}

// string name = 2;
inline void GetMclassInfoResponse::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetMclassInfoResponse::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetMclassInfoResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetMclassInfoResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetMclassInfoResponse.name)
}
inline std::string* GetMclassInfoResponse::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetMclassInfoResponse.name)
  return _s;
}
inline const std::string& GetMclassInfoResponse::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetMclassInfoResponse::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetMclassInfoResponse::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetMclassInfoResponse::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetMclassInfoResponse.name)
  return _impl_.name_.Release();
}
inline void GetMclassInfoResponse::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetMclassInfoResponse.name)
}

// string help = 3;
inline void GetMclassInfoResponse::clear_help() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.help_.ClearToEmpty();
}
inline const std::string& GetMclassInfoResponse::help() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetMclassInfoResponse.help)
  return _internal_help();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetMclassInfoResponse::set_help(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.help_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetMclassInfoResponse.help)
}
inline std::string* GetMclassInfoResponse::mutable_help() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_help();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetMclassInfoResponse.help)
  return _s;
}
inline const std::string& GetMclassInfoResponse::_internal_help() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.help_.Get();
}
inline void GetMclassInfoResponse::_internal_set_help(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.help_.Set(value, GetArena());
}
inline std::string* GetMclassInfoResponse::_internal_mutable_help() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.help_.Mutable( GetArena());
}
inline std::string* GetMclassInfoResponse::release_help() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetMclassInfoResponse.help)
  return _impl_.help_.Release();
}
inline void GetMclassInfoResponse::set_allocated_help(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.help_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.help_.IsDefault()) {
          _impl_.help_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetMclassInfoResponse.help)
}

// repeated string cmds = 4;
inline int GetMclassInfoResponse::_internal_cmds_size() const {
  return _internal_cmds().size();
}
inline int GetMclassInfoResponse::cmds_size() const {
  return _internal_cmds_size();
}
inline void GetMclassInfoResponse::clear_cmds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cmds_.Clear();
}
inline std::string* GetMclassInfoResponse::add_cmds()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_cmds()->Add();
  // @@protoc_insertion_point(field_add_mutable:bess.pb.GetMclassInfoResponse.cmds)
  return _s;
}
inline const std::string& GetMclassInfoResponse::cmds(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetMclassInfoResponse.cmds)
  return _internal_cmds().Get(index);
}
inline std::string* GetMclassInfoResponse::mutable_cmds(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.GetMclassInfoResponse.cmds)
  return _internal_mutable_cmds()->Mutable(index);
}
inline void GetMclassInfoResponse::set_cmds(int index, const std::string& value) {
  _internal_mutable_cmds()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetMclassInfoResponse.cmds)
}
inline void GetMclassInfoResponse::set_cmds(int index, std::string&& value) {
  _internal_mutable_cmds()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bess.pb.GetMclassInfoResponse.cmds)
}
inline void GetMclassInfoResponse::set_cmds(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_cmds()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bess.pb.GetMclassInfoResponse.cmds)
}
inline void GetMclassInfoResponse::set_cmds(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_cmds()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bess.pb.GetMclassInfoResponse.cmds)
}
inline void GetMclassInfoResponse::set_cmds(int index, absl::string_view value) {
  _internal_mutable_cmds()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:bess.pb.GetMclassInfoResponse.cmds)
}
inline void GetMclassInfoResponse::add_cmds(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmds()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:bess.pb.GetMclassInfoResponse.cmds)
}
inline void GetMclassInfoResponse::add_cmds(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmds()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:bess.pb.GetMclassInfoResponse.cmds)
}
inline void GetMclassInfoResponse::add_cmds(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmds()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bess.pb.GetMclassInfoResponse.cmds)
}
inline void GetMclassInfoResponse::add_cmds(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmds()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bess.pb.GetMclassInfoResponse.cmds)
}
inline void GetMclassInfoResponse::add_cmds(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmds()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:bess.pb.GetMclassInfoResponse.cmds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetMclassInfoResponse::cmds() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.GetMclassInfoResponse.cmds)
  return _internal_cmds();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetMclassInfoResponse::mutable_cmds() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.GetMclassInfoResponse.cmds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_cmds();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetMclassInfoResponse::_internal_cmds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cmds_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetMclassInfoResponse::_internal_mutable_cmds() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.cmds_;
}

// repeated string cmd_args = 5;
inline int GetMclassInfoResponse::_internal_cmd_args_size() const {
  return _internal_cmd_args().size();
}
inline int GetMclassInfoResponse::cmd_args_size() const {
  return _internal_cmd_args_size();
}
inline void GetMclassInfoResponse::clear_cmd_args() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cmd_args_.Clear();
}
inline std::string* GetMclassInfoResponse::add_cmd_args()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_cmd_args()->Add();
  // @@protoc_insertion_point(field_add_mutable:bess.pb.GetMclassInfoResponse.cmd_args)
  return _s;
}
inline const std::string& GetMclassInfoResponse::cmd_args(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetMclassInfoResponse.cmd_args)
  return _internal_cmd_args().Get(index);
}
inline std::string* GetMclassInfoResponse::mutable_cmd_args(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.GetMclassInfoResponse.cmd_args)
  return _internal_mutable_cmd_args()->Mutable(index);
}
inline void GetMclassInfoResponse::set_cmd_args(int index, const std::string& value) {
  _internal_mutable_cmd_args()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetMclassInfoResponse.cmd_args)
}
inline void GetMclassInfoResponse::set_cmd_args(int index, std::string&& value) {
  _internal_mutable_cmd_args()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bess.pb.GetMclassInfoResponse.cmd_args)
}
inline void GetMclassInfoResponse::set_cmd_args(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_cmd_args()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bess.pb.GetMclassInfoResponse.cmd_args)
}
inline void GetMclassInfoResponse::set_cmd_args(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_cmd_args()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bess.pb.GetMclassInfoResponse.cmd_args)
}
inline void GetMclassInfoResponse::set_cmd_args(int index, absl::string_view value) {
  _internal_mutable_cmd_args()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:bess.pb.GetMclassInfoResponse.cmd_args)
}
inline void GetMclassInfoResponse::add_cmd_args(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmd_args()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:bess.pb.GetMclassInfoResponse.cmd_args)
}
inline void GetMclassInfoResponse::add_cmd_args(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmd_args()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:bess.pb.GetMclassInfoResponse.cmd_args)
}
inline void GetMclassInfoResponse::add_cmd_args(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmd_args()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bess.pb.GetMclassInfoResponse.cmd_args)
}
inline void GetMclassInfoResponse::add_cmd_args(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmd_args()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bess.pb.GetMclassInfoResponse.cmd_args)
}
inline void GetMclassInfoResponse::add_cmd_args(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmd_args()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:bess.pb.GetMclassInfoResponse.cmd_args)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetMclassInfoResponse::cmd_args() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.GetMclassInfoResponse.cmd_args)
  return _internal_cmd_args();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetMclassInfoResponse::mutable_cmd_args() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.GetMclassInfoResponse.cmd_args)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_cmd_args();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetMclassInfoResponse::_internal_cmd_args() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cmd_args_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetMclassInfoResponse::_internal_mutable_cmd_args() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.cmd_args_;
}

// -------------------------------------------------------------------

// ListModulesResponse_Module

// string name = 1;
inline void ListModulesResponse_Module::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ListModulesResponse_Module::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListModulesResponse.Module.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListModulesResponse_Module::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.ListModulesResponse.Module.name)
}
inline std::string* ListModulesResponse_Module::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListModulesResponse.Module.name)
  return _s;
}
inline const std::string& ListModulesResponse_Module::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ListModulesResponse_Module::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ListModulesResponse_Module::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ListModulesResponse_Module::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListModulesResponse.Module.name)
  return _impl_.name_.Release();
}
inline void ListModulesResponse_Module::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListModulesResponse.Module.name)
}

// string mclass = 2;
inline void ListModulesResponse_Module::clear_mclass() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mclass_.ClearToEmpty();
}
inline const std::string& ListModulesResponse_Module::mclass() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListModulesResponse.Module.mclass)
  return _internal_mclass();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListModulesResponse_Module::set_mclass(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mclass_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.ListModulesResponse.Module.mclass)
}
inline std::string* ListModulesResponse_Module::mutable_mclass() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mclass();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListModulesResponse.Module.mclass)
  return _s;
}
inline const std::string& ListModulesResponse_Module::_internal_mclass() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mclass_.Get();
}
inline void ListModulesResponse_Module::_internal_set_mclass(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mclass_.Set(value, GetArena());
}
inline std::string* ListModulesResponse_Module::_internal_mutable_mclass() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mclass_.Mutable( GetArena());
}
inline std::string* ListModulesResponse_Module::release_mclass() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListModulesResponse.Module.mclass)
  return _impl_.mclass_.Release();
}
inline void ListModulesResponse_Module::set_allocated_mclass(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mclass_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mclass_.IsDefault()) {
          _impl_.mclass_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListModulesResponse.Module.mclass)
}

// string desc = 3;
inline void ListModulesResponse_Module::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& ListModulesResponse_Module::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListModulesResponse.Module.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListModulesResponse_Module::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.ListModulesResponse.Module.desc)
}
inline std::string* ListModulesResponse_Module::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListModulesResponse.Module.desc)
  return _s;
}
inline const std::string& ListModulesResponse_Module::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void ListModulesResponse_Module::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* ListModulesResponse_Module::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* ListModulesResponse_Module::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListModulesResponse.Module.desc)
  return _impl_.desc_.Release();
}
inline void ListModulesResponse_Module::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListModulesResponse.Module.desc)
}

// -------------------------------------------------------------------

// ListModulesResponse

// .bess.pb.Error error = 1;
inline bool ListModulesResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& ListModulesResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& ListModulesResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListModulesResponse.error)
  return _internal_error();
}
inline void ListModulesResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.ListModulesResponse.error)
}
inline ::bess::pb::Error* ListModulesResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* ListModulesResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListModulesResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* ListModulesResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* ListModulesResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListModulesResponse.error)
  return _msg;
}
inline void ListModulesResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListModulesResponse.error)
}

// repeated .bess.pb.ListModulesResponse.Module modules = 2;
inline int ListModulesResponse::_internal_modules_size() const {
  return _internal_modules().size();
}
inline int ListModulesResponse::modules_size() const {
  return _internal_modules_size();
}
inline void ListModulesResponse::clear_modules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.modules_.Clear();
}
inline ::bess::pb::ListModulesResponse_Module* ListModulesResponse::mutable_modules(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.ListModulesResponse.modules)
  return _internal_mutable_modules()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::ListModulesResponse_Module>* ListModulesResponse::mutable_modules()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.ListModulesResponse.modules)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_modules();
}
inline const ::bess::pb::ListModulesResponse_Module& ListModulesResponse::modules(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListModulesResponse.modules)
  return _internal_modules().Get(index);
}
inline ::bess::pb::ListModulesResponse_Module* ListModulesResponse::add_modules() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::bess::pb::ListModulesResponse_Module* _add = _internal_mutable_modules()->Add();
  // @@protoc_insertion_point(field_add:bess.pb.ListModulesResponse.modules)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::ListModulesResponse_Module>& ListModulesResponse::modules() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.ListModulesResponse.modules)
  return _internal_modules();
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::ListModulesResponse_Module>&
ListModulesResponse::_internal_modules() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modules_;
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::ListModulesResponse_Module>*
ListModulesResponse::_internal_mutable_modules() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.modules_;
}

// -------------------------------------------------------------------

// CreateModuleRequest

// string name = 1;
inline void CreateModuleRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateModuleRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CreateModuleRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateModuleRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.CreateModuleRequest.name)
}
inline std::string* CreateModuleRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.CreateModuleRequest.name)
  return _s;
}
inline const std::string& CreateModuleRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CreateModuleRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CreateModuleRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CreateModuleRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CreateModuleRequest.name)
  return _impl_.name_.Release();
}
inline void CreateModuleRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CreateModuleRequest.name)
}

// string mclass = 2;
inline void CreateModuleRequest::clear_mclass() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mclass_.ClearToEmpty();
}
inline const std::string& CreateModuleRequest::mclass() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CreateModuleRequest.mclass)
  return _internal_mclass();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateModuleRequest::set_mclass(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mclass_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.CreateModuleRequest.mclass)
}
inline std::string* CreateModuleRequest::mutable_mclass() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mclass();
  // @@protoc_insertion_point(field_mutable:bess.pb.CreateModuleRequest.mclass)
  return _s;
}
inline const std::string& CreateModuleRequest::_internal_mclass() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mclass_.Get();
}
inline void CreateModuleRequest::_internal_set_mclass(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mclass_.Set(value, GetArena());
}
inline std::string* CreateModuleRequest::_internal_mutable_mclass() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mclass_.Mutable( GetArena());
}
inline std::string* CreateModuleRequest::release_mclass() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CreateModuleRequest.mclass)
  return _impl_.mclass_.Release();
}
inline void CreateModuleRequest::set_allocated_mclass(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mclass_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mclass_.IsDefault()) {
          _impl_.mclass_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CreateModuleRequest.mclass)
}

// .google.protobuf.Any arg = 3;
inline bool CreateModuleRequest::has_arg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arg_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& CreateModuleRequest::_internal_arg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Any* p = _impl_.arg_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& CreateModuleRequest::arg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CreateModuleRequest.arg)
  return _internal_arg();
}
inline void CreateModuleRequest::unsafe_arena_set_allocated_arg(::google::protobuf::Any* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arg_);
  }
  _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.CreateModuleRequest.arg)
}
inline ::google::protobuf::Any* CreateModuleRequest::release_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.arg_;
  _impl_.arg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* CreateModuleRequest::unsafe_arena_release_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CreateModuleRequest.arg)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.arg_;
  _impl_.arg_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* CreateModuleRequest::_internal_mutable_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.arg_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArena());
    _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.arg_;
}
inline ::google::protobuf::Any* CreateModuleRequest::mutable_arg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Any* _msg = _internal_mutable_arg();
  // @@protoc_insertion_point(field_mutable:bess.pb.CreateModuleRequest.arg)
  return _msg;
}
inline void CreateModuleRequest::set_allocated_arg(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CreateModuleRequest.arg)
}

// -------------------------------------------------------------------

// CreateModuleResponse

// .bess.pb.Error error = 1;
inline bool CreateModuleResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& CreateModuleResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& CreateModuleResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CreateModuleResponse.error)
  return _internal_error();
}
inline void CreateModuleResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.CreateModuleResponse.error)
}
inline ::bess::pb::Error* CreateModuleResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* CreateModuleResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CreateModuleResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* CreateModuleResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* CreateModuleResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.CreateModuleResponse.error)
  return _msg;
}
inline void CreateModuleResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CreateModuleResponse.error)
}

// string name = 2;
inline void CreateModuleResponse::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateModuleResponse::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CreateModuleResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateModuleResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.CreateModuleResponse.name)
}
inline std::string* CreateModuleResponse::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.CreateModuleResponse.name)
  return _s;
}
inline const std::string& CreateModuleResponse::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CreateModuleResponse::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CreateModuleResponse::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CreateModuleResponse::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CreateModuleResponse.name)
  return _impl_.name_.Release();
}
inline void CreateModuleResponse::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CreateModuleResponse.name)
}

// -------------------------------------------------------------------

// DestroyModuleRequest

// string name = 1;
inline void DestroyModuleRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DestroyModuleRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.DestroyModuleRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DestroyModuleRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.DestroyModuleRequest.name)
}
inline std::string* DestroyModuleRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.DestroyModuleRequest.name)
  return _s;
}
inline const std::string& DestroyModuleRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void DestroyModuleRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* DestroyModuleRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* DestroyModuleRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.DestroyModuleRequest.name)
  return _impl_.name_.Release();
}
inline void DestroyModuleRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.DestroyModuleRequest.name)
}

// -------------------------------------------------------------------

// GetModuleInfoRequest

// string name = 1;
inline void GetModuleInfoRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetModuleInfoRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetModuleInfoRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoRequest.name)
}
inline std::string* GetModuleInfoRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoRequest.name)
  return _s;
}
inline const std::string& GetModuleInfoRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetModuleInfoRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetModuleInfoRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetModuleInfoRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetModuleInfoRequest.name)
  return _impl_.name_.Release();
}
inline void GetModuleInfoRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetModuleInfoRequest.name)
}

// -------------------------------------------------------------------

// GetModuleInfoResponse_GateHook

// string class_name = 1;
inline void GetModuleInfoResponse_GateHook::clear_class_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.class_name_.ClearToEmpty();
}
inline const std::string& GetModuleInfoResponse_GateHook::class_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.GateHook.class_name)
  return _internal_class_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetModuleInfoResponse_GateHook::set_class_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.class_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.GateHook.class_name)
}
inline std::string* GetModuleInfoResponse_GateHook::mutable_class_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.GateHook.class_name)
  return _s;
}
inline const std::string& GetModuleInfoResponse_GateHook::_internal_class_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.class_name_.Get();
}
inline void GetModuleInfoResponse_GateHook::_internal_set_class_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.class_name_.Set(value, GetArena());
}
inline std::string* GetModuleInfoResponse_GateHook::_internal_mutable_class_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.class_name_.Mutable( GetArena());
}
inline std::string* GetModuleInfoResponse_GateHook::release_class_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetModuleInfoResponse.GateHook.class_name)
  return _impl_.class_name_.Release();
}
inline void GetModuleInfoResponse_GateHook::set_allocated_class_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.class_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.class_name_.IsDefault()) {
          _impl_.class_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetModuleInfoResponse.GateHook.class_name)
}

// string hook_name = 2;
inline void GetModuleInfoResponse_GateHook::clear_hook_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hook_name_.ClearToEmpty();
}
inline const std::string& GetModuleInfoResponse_GateHook::hook_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.GateHook.hook_name)
  return _internal_hook_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetModuleInfoResponse_GateHook::set_hook_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hook_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.GateHook.hook_name)
}
inline std::string* GetModuleInfoResponse_GateHook::mutable_hook_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hook_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.GateHook.hook_name)
  return _s;
}
inline const std::string& GetModuleInfoResponse_GateHook::_internal_hook_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hook_name_.Get();
}
inline void GetModuleInfoResponse_GateHook::_internal_set_hook_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hook_name_.Set(value, GetArena());
}
inline std::string* GetModuleInfoResponse_GateHook::_internal_mutable_hook_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.hook_name_.Mutable( GetArena());
}
inline std::string* GetModuleInfoResponse_GateHook::release_hook_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetModuleInfoResponse.GateHook.hook_name)
  return _impl_.hook_name_.Release();
}
inline void GetModuleInfoResponse_GateHook::set_allocated_hook_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hook_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hook_name_.IsDefault()) {
          _impl_.hook_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetModuleInfoResponse.GateHook.hook_name)
}

// -------------------------------------------------------------------

// GetModuleInfoResponse_IGate_OGate

// uint64 ogate = 1;
inline void GetModuleInfoResponse_IGate_OGate::clear_ogate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ogate_ = ::uint64_t{0u};
}
inline ::uint64_t GetModuleInfoResponse_IGate_OGate::ogate() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.IGate.OGate.ogate)
  return _internal_ogate();
}
inline void GetModuleInfoResponse_IGate_OGate::set_ogate(::uint64_t value) {
  _internal_set_ogate(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.IGate.OGate.ogate)
}
inline ::uint64_t GetModuleInfoResponse_IGate_OGate::_internal_ogate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ogate_;
}
inline void GetModuleInfoResponse_IGate_OGate::_internal_set_ogate(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ogate_ = value;
}

// string name = 2;
inline void GetModuleInfoResponse_IGate_OGate::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetModuleInfoResponse_IGate_OGate::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.IGate.OGate.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetModuleInfoResponse_IGate_OGate::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.IGate.OGate.name)
}
inline std::string* GetModuleInfoResponse_IGate_OGate::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.IGate.OGate.name)
  return _s;
}
inline const std::string& GetModuleInfoResponse_IGate_OGate::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetModuleInfoResponse_IGate_OGate::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetModuleInfoResponse_IGate_OGate::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetModuleInfoResponse_IGate_OGate::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetModuleInfoResponse.IGate.OGate.name)
  return _impl_.name_.Release();
}
inline void GetModuleInfoResponse_IGate_OGate::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetModuleInfoResponse.IGate.OGate.name)
}

// -------------------------------------------------------------------

// GetModuleInfoResponse_IGate

// uint64 igate = 1;
inline void GetModuleInfoResponse_IGate::clear_igate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.igate_ = ::uint64_t{0u};
}
inline ::uint64_t GetModuleInfoResponse_IGate::igate() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.IGate.igate)
  return _internal_igate();
}
inline void GetModuleInfoResponse_IGate::set_igate(::uint64_t value) {
  _internal_set_igate(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.IGate.igate)
}
inline ::uint64_t GetModuleInfoResponse_IGate::_internal_igate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.igate_;
}
inline void GetModuleInfoResponse_IGate::_internal_set_igate(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.igate_ = value;
}

// repeated .bess.pb.GetModuleInfoResponse.IGate.OGate ogates = 2;
inline int GetModuleInfoResponse_IGate::_internal_ogates_size() const {
  return _internal_ogates().size();
}
inline int GetModuleInfoResponse_IGate::ogates_size() const {
  return _internal_ogates_size();
}
inline void GetModuleInfoResponse_IGate::clear_ogates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ogates_.Clear();
}
inline ::bess::pb::GetModuleInfoResponse_IGate_OGate* GetModuleInfoResponse_IGate::mutable_ogates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.IGate.ogates)
  return _internal_mutable_ogates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_IGate_OGate>* GetModuleInfoResponse_IGate::mutable_ogates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.GetModuleInfoResponse.IGate.ogates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ogates();
}
inline const ::bess::pb::GetModuleInfoResponse_IGate_OGate& GetModuleInfoResponse_IGate::ogates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.IGate.ogates)
  return _internal_ogates().Get(index);
}
inline ::bess::pb::GetModuleInfoResponse_IGate_OGate* GetModuleInfoResponse_IGate::add_ogates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::bess::pb::GetModuleInfoResponse_IGate_OGate* _add = _internal_mutable_ogates()->Add();
  // @@protoc_insertion_point(field_add:bess.pb.GetModuleInfoResponse.IGate.ogates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_IGate_OGate>& GetModuleInfoResponse_IGate::ogates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.GetModuleInfoResponse.IGate.ogates)
  return _internal_ogates();
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_IGate_OGate>&
GetModuleInfoResponse_IGate::_internal_ogates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ogates_;
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_IGate_OGate>*
GetModuleInfoResponse_IGate::_internal_mutable_ogates() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ogates_;
}

// uint64 cnt = 3;
inline void GetModuleInfoResponse_IGate::clear_cnt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cnt_ = ::uint64_t{0u};
}
inline ::uint64_t GetModuleInfoResponse_IGate::cnt() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.IGate.cnt)
  return _internal_cnt();
}
inline void GetModuleInfoResponse_IGate::set_cnt(::uint64_t value) {
  _internal_set_cnt(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.IGate.cnt)
}
inline ::uint64_t GetModuleInfoResponse_IGate::_internal_cnt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cnt_;
}
inline void GetModuleInfoResponse_IGate::_internal_set_cnt(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cnt_ = value;
}

// uint64 pkts = 4;
inline void GetModuleInfoResponse_IGate::clear_pkts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pkts_ = ::uint64_t{0u};
}
inline ::uint64_t GetModuleInfoResponse_IGate::pkts() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.IGate.pkts)
  return _internal_pkts();
}
inline void GetModuleInfoResponse_IGate::set_pkts(::uint64_t value) {
  _internal_set_pkts(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.IGate.pkts)
}
inline ::uint64_t GetModuleInfoResponse_IGate::_internal_pkts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pkts_;
}
inline void GetModuleInfoResponse_IGate::_internal_set_pkts(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pkts_ = value;
}

// uint64 bytes = 5;
inline void GetModuleInfoResponse_IGate::clear_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bytes_ = ::uint64_t{0u};
}
inline ::uint64_t GetModuleInfoResponse_IGate::bytes() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.IGate.bytes)
  return _internal_bytes();
}
inline void GetModuleInfoResponse_IGate::set_bytes(::uint64_t value) {
  _internal_set_bytes(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.IGate.bytes)
}
inline ::uint64_t GetModuleInfoResponse_IGate::_internal_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bytes_;
}
inline void GetModuleInfoResponse_IGate::_internal_set_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bytes_ = value;
}

// double timestamp = 6;
inline void GetModuleInfoResponse_IGate::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = 0;
}
inline double GetModuleInfoResponse_IGate::timestamp() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.IGate.timestamp)
  return _internal_timestamp();
}
inline void GetModuleInfoResponse_IGate::set_timestamp(double value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.IGate.timestamp)
}
inline double GetModuleInfoResponse_IGate::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void GetModuleInfoResponse_IGate::_internal_set_timestamp(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// repeated .bess.pb.GetModuleInfoResponse.GateHook gatehooks = 8;
inline int GetModuleInfoResponse_IGate::_internal_gatehooks_size() const {
  return _internal_gatehooks().size();
}
inline int GetModuleInfoResponse_IGate::gatehooks_size() const {
  return _internal_gatehooks_size();
}
inline void GetModuleInfoResponse_IGate::clear_gatehooks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gatehooks_.Clear();
}
inline ::bess::pb::GetModuleInfoResponse_GateHook* GetModuleInfoResponse_IGate::mutable_gatehooks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.IGate.gatehooks)
  return _internal_mutable_gatehooks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_GateHook>* GetModuleInfoResponse_IGate::mutable_gatehooks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.GetModuleInfoResponse.IGate.gatehooks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_gatehooks();
}
inline const ::bess::pb::GetModuleInfoResponse_GateHook& GetModuleInfoResponse_IGate::gatehooks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.IGate.gatehooks)
  return _internal_gatehooks().Get(index);
}
inline ::bess::pb::GetModuleInfoResponse_GateHook* GetModuleInfoResponse_IGate::add_gatehooks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::bess::pb::GetModuleInfoResponse_GateHook* _add = _internal_mutable_gatehooks()->Add();
  // @@protoc_insertion_point(field_add:bess.pb.GetModuleInfoResponse.IGate.gatehooks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_GateHook>& GetModuleInfoResponse_IGate::gatehooks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.GetModuleInfoResponse.IGate.gatehooks)
  return _internal_gatehooks();
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_GateHook>&
GetModuleInfoResponse_IGate::_internal_gatehooks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gatehooks_;
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_GateHook>*
GetModuleInfoResponse_IGate::_internal_mutable_gatehooks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.gatehooks_;
}

// -------------------------------------------------------------------

// GetModuleInfoResponse_OGate

// uint64 ogate = 1;
inline void GetModuleInfoResponse_OGate::clear_ogate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ogate_ = ::uint64_t{0u};
}
inline ::uint64_t GetModuleInfoResponse_OGate::ogate() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.OGate.ogate)
  return _internal_ogate();
}
inline void GetModuleInfoResponse_OGate::set_ogate(::uint64_t value) {
  _internal_set_ogate(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.OGate.ogate)
}
inline ::uint64_t GetModuleInfoResponse_OGate::_internal_ogate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ogate_;
}
inline void GetModuleInfoResponse_OGate::_internal_set_ogate(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ogate_ = value;
}

// uint64 cnt = 2;
inline void GetModuleInfoResponse_OGate::clear_cnt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cnt_ = ::uint64_t{0u};
}
inline ::uint64_t GetModuleInfoResponse_OGate::cnt() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.OGate.cnt)
  return _internal_cnt();
}
inline void GetModuleInfoResponse_OGate::set_cnt(::uint64_t value) {
  _internal_set_cnt(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.OGate.cnt)
}
inline ::uint64_t GetModuleInfoResponse_OGate::_internal_cnt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cnt_;
}
inline void GetModuleInfoResponse_OGate::_internal_set_cnt(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cnt_ = value;
}

// uint64 pkts = 3;
inline void GetModuleInfoResponse_OGate::clear_pkts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pkts_ = ::uint64_t{0u};
}
inline ::uint64_t GetModuleInfoResponse_OGate::pkts() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.OGate.pkts)
  return _internal_pkts();
}
inline void GetModuleInfoResponse_OGate::set_pkts(::uint64_t value) {
  _internal_set_pkts(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.OGate.pkts)
}
inline ::uint64_t GetModuleInfoResponse_OGate::_internal_pkts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pkts_;
}
inline void GetModuleInfoResponse_OGate::_internal_set_pkts(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pkts_ = value;
}

// uint64 bytes = 4;
inline void GetModuleInfoResponse_OGate::clear_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bytes_ = ::uint64_t{0u};
}
inline ::uint64_t GetModuleInfoResponse_OGate::bytes() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.OGate.bytes)
  return _internal_bytes();
}
inline void GetModuleInfoResponse_OGate::set_bytes(::uint64_t value) {
  _internal_set_bytes(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.OGate.bytes)
}
inline ::uint64_t GetModuleInfoResponse_OGate::_internal_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bytes_;
}
inline void GetModuleInfoResponse_OGate::_internal_set_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bytes_ = value;
}

// double timestamp = 5;
inline void GetModuleInfoResponse_OGate::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ = 0;
}
inline double GetModuleInfoResponse_OGate::timestamp() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.OGate.timestamp)
  return _internal_timestamp();
}
inline void GetModuleInfoResponse_OGate::set_timestamp(double value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.OGate.timestamp)
}
inline double GetModuleInfoResponse_OGate::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_;
}
inline void GetModuleInfoResponse_OGate::_internal_set_timestamp(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.timestamp_ = value;
}

// string name = 6;
inline void GetModuleInfoResponse_OGate::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetModuleInfoResponse_OGate::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.OGate.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetModuleInfoResponse_OGate::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.OGate.name)
}
inline std::string* GetModuleInfoResponse_OGate::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.OGate.name)
  return _s;
}
inline const std::string& GetModuleInfoResponse_OGate::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetModuleInfoResponse_OGate::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetModuleInfoResponse_OGate::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetModuleInfoResponse_OGate::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetModuleInfoResponse.OGate.name)
  return _impl_.name_.Release();
}
inline void GetModuleInfoResponse_OGate::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetModuleInfoResponse.OGate.name)
}

// uint64 igate = 7;
inline void GetModuleInfoResponse_OGate::clear_igate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.igate_ = ::uint64_t{0u};
}
inline ::uint64_t GetModuleInfoResponse_OGate::igate() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.OGate.igate)
  return _internal_igate();
}
inline void GetModuleInfoResponse_OGate::set_igate(::uint64_t value) {
  _internal_set_igate(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.OGate.igate)
}
inline ::uint64_t GetModuleInfoResponse_OGate::_internal_igate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.igate_;
}
inline void GetModuleInfoResponse_OGate::_internal_set_igate(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.igate_ = value;
}

// repeated .bess.pb.GetModuleInfoResponse.GateHook gatehooks = 9;
inline int GetModuleInfoResponse_OGate::_internal_gatehooks_size() const {
  return _internal_gatehooks().size();
}
inline int GetModuleInfoResponse_OGate::gatehooks_size() const {
  return _internal_gatehooks_size();
}
inline void GetModuleInfoResponse_OGate::clear_gatehooks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gatehooks_.Clear();
}
inline ::bess::pb::GetModuleInfoResponse_GateHook* GetModuleInfoResponse_OGate::mutable_gatehooks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.OGate.gatehooks)
  return _internal_mutable_gatehooks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_GateHook>* GetModuleInfoResponse_OGate::mutable_gatehooks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.GetModuleInfoResponse.OGate.gatehooks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_gatehooks();
}
inline const ::bess::pb::GetModuleInfoResponse_GateHook& GetModuleInfoResponse_OGate::gatehooks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.OGate.gatehooks)
  return _internal_gatehooks().Get(index);
}
inline ::bess::pb::GetModuleInfoResponse_GateHook* GetModuleInfoResponse_OGate::add_gatehooks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::bess::pb::GetModuleInfoResponse_GateHook* _add = _internal_mutable_gatehooks()->Add();
  // @@protoc_insertion_point(field_add:bess.pb.GetModuleInfoResponse.OGate.gatehooks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_GateHook>& GetModuleInfoResponse_OGate::gatehooks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.GetModuleInfoResponse.OGate.gatehooks)
  return _internal_gatehooks();
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_GateHook>&
GetModuleInfoResponse_OGate::_internal_gatehooks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gatehooks_;
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_GateHook>*
GetModuleInfoResponse_OGate::_internal_mutable_gatehooks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.gatehooks_;
}

// -------------------------------------------------------------------

// GetModuleInfoResponse_Attribute

// string name = 1;
inline void GetModuleInfoResponse_Attribute::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetModuleInfoResponse_Attribute::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.Attribute.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetModuleInfoResponse_Attribute::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.Attribute.name)
}
inline std::string* GetModuleInfoResponse_Attribute::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.Attribute.name)
  return _s;
}
inline const std::string& GetModuleInfoResponse_Attribute::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetModuleInfoResponse_Attribute::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetModuleInfoResponse_Attribute::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetModuleInfoResponse_Attribute::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetModuleInfoResponse.Attribute.name)
  return _impl_.name_.Release();
}
inline void GetModuleInfoResponse_Attribute::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetModuleInfoResponse.Attribute.name)
}

// uint64 size = 2;
inline void GetModuleInfoResponse_Attribute::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_ = ::uint64_t{0u};
}
inline ::uint64_t GetModuleInfoResponse_Attribute::size() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.Attribute.size)
  return _internal_size();
}
inline void GetModuleInfoResponse_Attribute::set_size(::uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.Attribute.size)
}
inline ::uint64_t GetModuleInfoResponse_Attribute::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void GetModuleInfoResponse_Attribute::_internal_set_size(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_ = value;
}

// string mode = 3;
inline void GetModuleInfoResponse_Attribute::clear_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mode_.ClearToEmpty();
}
inline const std::string& GetModuleInfoResponse_Attribute::mode() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.Attribute.mode)
  return _internal_mode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetModuleInfoResponse_Attribute::set_mode(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mode_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.Attribute.mode)
}
inline std::string* GetModuleInfoResponse_Attribute::mutable_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.Attribute.mode)
  return _s;
}
inline const std::string& GetModuleInfoResponse_Attribute::_internal_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mode_.Get();
}
inline void GetModuleInfoResponse_Attribute::_internal_set_mode(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mode_.Set(value, GetArena());
}
inline std::string* GetModuleInfoResponse_Attribute::_internal_mutable_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mode_.Mutable( GetArena());
}
inline std::string* GetModuleInfoResponse_Attribute::release_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetModuleInfoResponse.Attribute.mode)
  return _impl_.mode_.Release();
}
inline void GetModuleInfoResponse_Attribute::set_allocated_mode(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mode_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mode_.IsDefault()) {
          _impl_.mode_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetModuleInfoResponse.Attribute.mode)
}

// int64 offset = 4;
inline void GetModuleInfoResponse_Attribute::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = ::int64_t{0};
}
inline ::int64_t GetModuleInfoResponse_Attribute::offset() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.Attribute.offset)
  return _internal_offset();
}
inline void GetModuleInfoResponse_Attribute::set_offset(::int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.Attribute.offset)
}
inline ::int64_t GetModuleInfoResponse_Attribute::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void GetModuleInfoResponse_Attribute::_internal_set_offset(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.offset_ = value;
}

// -------------------------------------------------------------------

// GetModuleInfoResponse

// .bess.pb.Error error = 1;
inline bool GetModuleInfoResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& GetModuleInfoResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& GetModuleInfoResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.error)
  return _internal_error();
}
inline void GetModuleInfoResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.GetModuleInfoResponse.error)
}
inline ::bess::pb::Error* GetModuleInfoResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* GetModuleInfoResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetModuleInfoResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* GetModuleInfoResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* GetModuleInfoResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.error)
  return _msg;
}
inline void GetModuleInfoResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetModuleInfoResponse.error)
}

// string name = 2;
inline void GetModuleInfoResponse::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetModuleInfoResponse::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetModuleInfoResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.name)
}
inline std::string* GetModuleInfoResponse::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.name)
  return _s;
}
inline const std::string& GetModuleInfoResponse::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetModuleInfoResponse::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetModuleInfoResponse::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetModuleInfoResponse::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetModuleInfoResponse.name)
  return _impl_.name_.Release();
}
inline void GetModuleInfoResponse::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetModuleInfoResponse.name)
}

// string mclass = 3;
inline void GetModuleInfoResponse::clear_mclass() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mclass_.ClearToEmpty();
}
inline const std::string& GetModuleInfoResponse::mclass() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.mclass)
  return _internal_mclass();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetModuleInfoResponse::set_mclass(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mclass_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.mclass)
}
inline std::string* GetModuleInfoResponse::mutable_mclass() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mclass();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.mclass)
  return _s;
}
inline const std::string& GetModuleInfoResponse::_internal_mclass() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mclass_.Get();
}
inline void GetModuleInfoResponse::_internal_set_mclass(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mclass_.Set(value, GetArena());
}
inline std::string* GetModuleInfoResponse::_internal_mutable_mclass() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mclass_.Mutable( GetArena());
}
inline std::string* GetModuleInfoResponse::release_mclass() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetModuleInfoResponse.mclass)
  return _impl_.mclass_.Release();
}
inline void GetModuleInfoResponse::set_allocated_mclass(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mclass_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mclass_.IsDefault()) {
          _impl_.mclass_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetModuleInfoResponse.mclass)
}

// string desc = 4;
inline void GetModuleInfoResponse::clear_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& GetModuleInfoResponse::desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.desc)
  return _internal_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetModuleInfoResponse::set_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.desc)
}
inline std::string* GetModuleInfoResponse::mutable_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.desc)
  return _s;
}
inline const std::string& GetModuleInfoResponse::_internal_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.desc_.Get();
}
inline void GetModuleInfoResponse::_internal_set_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.desc_.Set(value, GetArena());
}
inline std::string* GetModuleInfoResponse::_internal_mutable_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.desc_.Mutable( GetArena());
}
inline std::string* GetModuleInfoResponse::release_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetModuleInfoResponse.desc)
  return _impl_.desc_.Release();
}
inline void GetModuleInfoResponse::set_allocated_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.desc_.IsDefault()) {
          _impl_.desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetModuleInfoResponse.desc)
}

// repeated .bess.pb.GetModuleInfoResponse.IGate igates = 6;
inline int GetModuleInfoResponse::_internal_igates_size() const {
  return _internal_igates().size();
}
inline int GetModuleInfoResponse::igates_size() const {
  return _internal_igates_size();
}
inline void GetModuleInfoResponse::clear_igates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.igates_.Clear();
}
inline ::bess::pb::GetModuleInfoResponse_IGate* GetModuleInfoResponse::mutable_igates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.igates)
  return _internal_mutable_igates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_IGate>* GetModuleInfoResponse::mutable_igates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.GetModuleInfoResponse.igates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_igates();
}
inline const ::bess::pb::GetModuleInfoResponse_IGate& GetModuleInfoResponse::igates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.igates)
  return _internal_igates().Get(index);
}
inline ::bess::pb::GetModuleInfoResponse_IGate* GetModuleInfoResponse::add_igates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::bess::pb::GetModuleInfoResponse_IGate* _add = _internal_mutable_igates()->Add();
  // @@protoc_insertion_point(field_add:bess.pb.GetModuleInfoResponse.igates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_IGate>& GetModuleInfoResponse::igates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.GetModuleInfoResponse.igates)
  return _internal_igates();
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_IGate>&
GetModuleInfoResponse::_internal_igates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.igates_;
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_IGate>*
GetModuleInfoResponse::_internal_mutable_igates() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.igates_;
}

// repeated .bess.pb.GetModuleInfoResponse.OGate ogates = 7;
inline int GetModuleInfoResponse::_internal_ogates_size() const {
  return _internal_ogates().size();
}
inline int GetModuleInfoResponse::ogates_size() const {
  return _internal_ogates_size();
}
inline void GetModuleInfoResponse::clear_ogates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ogates_.Clear();
}
inline ::bess::pb::GetModuleInfoResponse_OGate* GetModuleInfoResponse::mutable_ogates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.ogates)
  return _internal_mutable_ogates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_OGate>* GetModuleInfoResponse::mutable_ogates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.GetModuleInfoResponse.ogates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ogates();
}
inline const ::bess::pb::GetModuleInfoResponse_OGate& GetModuleInfoResponse::ogates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.ogates)
  return _internal_ogates().Get(index);
}
inline ::bess::pb::GetModuleInfoResponse_OGate* GetModuleInfoResponse::add_ogates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::bess::pb::GetModuleInfoResponse_OGate* _add = _internal_mutable_ogates()->Add();
  // @@protoc_insertion_point(field_add:bess.pb.GetModuleInfoResponse.ogates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_OGate>& GetModuleInfoResponse::ogates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.GetModuleInfoResponse.ogates)
  return _internal_ogates();
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_OGate>&
GetModuleInfoResponse::_internal_ogates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ogates_;
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_OGate>*
GetModuleInfoResponse::_internal_mutable_ogates() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ogates_;
}

// repeated .bess.pb.GetModuleInfoResponse.Attribute metadata = 8;
inline int GetModuleInfoResponse::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int GetModuleInfoResponse::metadata_size() const {
  return _internal_metadata_size();
}
inline void GetModuleInfoResponse::clear_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metadata_.Clear();
}
inline ::bess::pb::GetModuleInfoResponse_Attribute* GetModuleInfoResponse::mutable_metadata(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.GetModuleInfoResponse.metadata)
  return _internal_mutable_metadata()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_Attribute>* GetModuleInfoResponse::mutable_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.GetModuleInfoResponse.metadata)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_metadata();
}
inline const ::bess::pb::GetModuleInfoResponse_Attribute& GetModuleInfoResponse::metadata(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.metadata)
  return _internal_metadata().Get(index);
}
inline ::bess::pb::GetModuleInfoResponse_Attribute* GetModuleInfoResponse::add_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::bess::pb::GetModuleInfoResponse_Attribute* _add = _internal_mutable_metadata()->Add();
  // @@protoc_insertion_point(field_add:bess.pb.GetModuleInfoResponse.metadata)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_Attribute>& GetModuleInfoResponse::metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.GetModuleInfoResponse.metadata)
  return _internal_metadata();
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_Attribute>&
GetModuleInfoResponse::_internal_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metadata_;
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::GetModuleInfoResponse_Attribute>*
GetModuleInfoResponse::_internal_mutable_metadata() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.metadata_;
}

// uint64 deadends = 9;
inline void GetModuleInfoResponse::clear_deadends() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadends_ = ::uint64_t{0u};
}
inline ::uint64_t GetModuleInfoResponse::deadends() const {
  // @@protoc_insertion_point(field_get:bess.pb.GetModuleInfoResponse.deadends)
  return _internal_deadends();
}
inline void GetModuleInfoResponse::set_deadends(::uint64_t value) {
  _internal_set_deadends(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetModuleInfoResponse.deadends)
}
inline ::uint64_t GetModuleInfoResponse::_internal_deadends() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deadends_;
}
inline void GetModuleInfoResponse::_internal_set_deadends(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.deadends_ = value;
}

// -------------------------------------------------------------------

// ConnectModulesRequest

// string m1 = 1;
inline void ConnectModulesRequest::clear_m1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.m1_.ClearToEmpty();
}
inline const std::string& ConnectModulesRequest::m1() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ConnectModulesRequest.m1)
  return _internal_m1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectModulesRequest::set_m1(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.m1_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.ConnectModulesRequest.m1)
}
inline std::string* ConnectModulesRequest::mutable_m1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_m1();
  // @@protoc_insertion_point(field_mutable:bess.pb.ConnectModulesRequest.m1)
  return _s;
}
inline const std::string& ConnectModulesRequest::_internal_m1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.m1_.Get();
}
inline void ConnectModulesRequest::_internal_set_m1(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.m1_.Set(value, GetArena());
}
inline std::string* ConnectModulesRequest::_internal_mutable_m1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.m1_.Mutable( GetArena());
}
inline std::string* ConnectModulesRequest::release_m1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ConnectModulesRequest.m1)
  return _impl_.m1_.Release();
}
inline void ConnectModulesRequest::set_allocated_m1(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.m1_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.m1_.IsDefault()) {
          _impl_.m1_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ConnectModulesRequest.m1)
}

// string m2 = 2;
inline void ConnectModulesRequest::clear_m2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.m2_.ClearToEmpty();
}
inline const std::string& ConnectModulesRequest::m2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ConnectModulesRequest.m2)
  return _internal_m2();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectModulesRequest::set_m2(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.m2_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.ConnectModulesRequest.m2)
}
inline std::string* ConnectModulesRequest::mutable_m2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_m2();
  // @@protoc_insertion_point(field_mutable:bess.pb.ConnectModulesRequest.m2)
  return _s;
}
inline const std::string& ConnectModulesRequest::_internal_m2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.m2_.Get();
}
inline void ConnectModulesRequest::_internal_set_m2(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.m2_.Set(value, GetArena());
}
inline std::string* ConnectModulesRequest::_internal_mutable_m2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.m2_.Mutable( GetArena());
}
inline std::string* ConnectModulesRequest::release_m2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ConnectModulesRequest.m2)
  return _impl_.m2_.Release();
}
inline void ConnectModulesRequest::set_allocated_m2(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.m2_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.m2_.IsDefault()) {
          _impl_.m2_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ConnectModulesRequest.m2)
}

// uint64 ogate = 3;
inline void ConnectModulesRequest::clear_ogate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ogate_ = ::uint64_t{0u};
}
inline ::uint64_t ConnectModulesRequest::ogate() const {
  // @@protoc_insertion_point(field_get:bess.pb.ConnectModulesRequest.ogate)
  return _internal_ogate();
}
inline void ConnectModulesRequest::set_ogate(::uint64_t value) {
  _internal_set_ogate(value);
  // @@protoc_insertion_point(field_set:bess.pb.ConnectModulesRequest.ogate)
}
inline ::uint64_t ConnectModulesRequest::_internal_ogate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ogate_;
}
inline void ConnectModulesRequest::_internal_set_ogate(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ogate_ = value;
}

// uint64 igate = 4;
inline void ConnectModulesRequest::clear_igate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.igate_ = ::uint64_t{0u};
}
inline ::uint64_t ConnectModulesRequest::igate() const {
  // @@protoc_insertion_point(field_get:bess.pb.ConnectModulesRequest.igate)
  return _internal_igate();
}
inline void ConnectModulesRequest::set_igate(::uint64_t value) {
  _internal_set_igate(value);
  // @@protoc_insertion_point(field_set:bess.pb.ConnectModulesRequest.igate)
}
inline ::uint64_t ConnectModulesRequest::_internal_igate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.igate_;
}
inline void ConnectModulesRequest::_internal_set_igate(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.igate_ = value;
}

// bool skip_default_hooks = 5;
inline void ConnectModulesRequest::clear_skip_default_hooks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skip_default_hooks_ = false;
}
inline bool ConnectModulesRequest::skip_default_hooks() const {
  // @@protoc_insertion_point(field_get:bess.pb.ConnectModulesRequest.skip_default_hooks)
  return _internal_skip_default_hooks();
}
inline void ConnectModulesRequest::set_skip_default_hooks(bool value) {
  _internal_set_skip_default_hooks(value);
  // @@protoc_insertion_point(field_set:bess.pb.ConnectModulesRequest.skip_default_hooks)
}
inline bool ConnectModulesRequest::_internal_skip_default_hooks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skip_default_hooks_;
}
inline void ConnectModulesRequest::_internal_set_skip_default_hooks(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.skip_default_hooks_ = value;
}

// -------------------------------------------------------------------

// DisconnectModulesRequest

// string name = 1;
inline void DisconnectModulesRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DisconnectModulesRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.DisconnectModulesRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DisconnectModulesRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.DisconnectModulesRequest.name)
}
inline std::string* DisconnectModulesRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.DisconnectModulesRequest.name)
  return _s;
}
inline const std::string& DisconnectModulesRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void DisconnectModulesRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* DisconnectModulesRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* DisconnectModulesRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.DisconnectModulesRequest.name)
  return _impl_.name_.Release();
}
inline void DisconnectModulesRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.DisconnectModulesRequest.name)
}

// uint64 ogate = 2;
inline void DisconnectModulesRequest::clear_ogate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ogate_ = ::uint64_t{0u};
}
inline ::uint64_t DisconnectModulesRequest::ogate() const {
  // @@protoc_insertion_point(field_get:bess.pb.DisconnectModulesRequest.ogate)
  return _internal_ogate();
}
inline void DisconnectModulesRequest::set_ogate(::uint64_t value) {
  _internal_set_ogate(value);
  // @@protoc_insertion_point(field_set:bess.pb.DisconnectModulesRequest.ogate)
}
inline ::uint64_t DisconnectModulesRequest::_internal_ogate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ogate_;
}
inline void DisconnectModulesRequest::_internal_set_ogate(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ogate_ = value;
}

// -------------------------------------------------------------------

// MempoolDump

// int32 socket = 1;
inline void MempoolDump::clear_socket() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.socket_ = 0;
}
inline ::int32_t MempoolDump::socket() const {
  // @@protoc_insertion_point(field_get:bess.pb.MempoolDump.socket)
  return _internal_socket();
}
inline void MempoolDump::set_socket(::int32_t value) {
  _internal_set_socket(value);
  // @@protoc_insertion_point(field_set:bess.pb.MempoolDump.socket)
}
inline ::int32_t MempoolDump::_internal_socket() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.socket_;
}
inline void MempoolDump::_internal_set_socket(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.socket_ = value;
}

// bool initialized = 2;
inline void MempoolDump::clear_initialized() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.initialized_ = false;
}
inline bool MempoolDump::initialized() const {
  // @@protoc_insertion_point(field_get:bess.pb.MempoolDump.initialized)
  return _internal_initialized();
}
inline void MempoolDump::set_initialized(bool value) {
  _internal_set_initialized(value);
  // @@protoc_insertion_point(field_set:bess.pb.MempoolDump.initialized)
}
inline bool MempoolDump::_internal_initialized() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.initialized_;
}
inline void MempoolDump::_internal_set_initialized(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.initialized_ = value;
}

// uint32 mp_size = 3;
inline void MempoolDump::clear_mp_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mp_size_ = 0u;
}
inline ::uint32_t MempoolDump::mp_size() const {
  // @@protoc_insertion_point(field_get:bess.pb.MempoolDump.mp_size)
  return _internal_mp_size();
}
inline void MempoolDump::set_mp_size(::uint32_t value) {
  _internal_set_mp_size(value);
  // @@protoc_insertion_point(field_set:bess.pb.MempoolDump.mp_size)
}
inline ::uint32_t MempoolDump::_internal_mp_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mp_size_;
}
inline void MempoolDump::_internal_set_mp_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mp_size_ = value;
}

// uint32 mp_cache_size = 4;
inline void MempoolDump::clear_mp_cache_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mp_cache_size_ = 0u;
}
inline ::uint32_t MempoolDump::mp_cache_size() const {
  // @@protoc_insertion_point(field_get:bess.pb.MempoolDump.mp_cache_size)
  return _internal_mp_cache_size();
}
inline void MempoolDump::set_mp_cache_size(::uint32_t value) {
  _internal_set_mp_cache_size(value);
  // @@protoc_insertion_point(field_set:bess.pb.MempoolDump.mp_cache_size)
}
inline ::uint32_t MempoolDump::_internal_mp_cache_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mp_cache_size_;
}
inline void MempoolDump::_internal_set_mp_cache_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mp_cache_size_ = value;
}

// uint32 mp_element_size = 5;
inline void MempoolDump::clear_mp_element_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mp_element_size_ = 0u;
}
inline ::uint32_t MempoolDump::mp_element_size() const {
  // @@protoc_insertion_point(field_get:bess.pb.MempoolDump.mp_element_size)
  return _internal_mp_element_size();
}
inline void MempoolDump::set_mp_element_size(::uint32_t value) {
  _internal_set_mp_element_size(value);
  // @@protoc_insertion_point(field_set:bess.pb.MempoolDump.mp_element_size)
}
inline ::uint32_t MempoolDump::_internal_mp_element_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mp_element_size_;
}
inline void MempoolDump::_internal_set_mp_element_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mp_element_size_ = value;
}

// uint32 mp_populated_size = 6;
inline void MempoolDump::clear_mp_populated_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mp_populated_size_ = 0u;
}
inline ::uint32_t MempoolDump::mp_populated_size() const {
  // @@protoc_insertion_point(field_get:bess.pb.MempoolDump.mp_populated_size)
  return _internal_mp_populated_size();
}
inline void MempoolDump::set_mp_populated_size(::uint32_t value) {
  _internal_set_mp_populated_size(value);
  // @@protoc_insertion_point(field_set:bess.pb.MempoolDump.mp_populated_size)
}
inline ::uint32_t MempoolDump::_internal_mp_populated_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mp_populated_size_;
}
inline void MempoolDump::_internal_set_mp_populated_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mp_populated_size_ = value;
}

// uint32 mp_available_count = 7;
inline void MempoolDump::clear_mp_available_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mp_available_count_ = 0u;
}
inline ::uint32_t MempoolDump::mp_available_count() const {
  // @@protoc_insertion_point(field_get:bess.pb.MempoolDump.mp_available_count)
  return _internal_mp_available_count();
}
inline void MempoolDump::set_mp_available_count(::uint32_t value) {
  _internal_set_mp_available_count(value);
  // @@protoc_insertion_point(field_set:bess.pb.MempoolDump.mp_available_count)
}
inline ::uint32_t MempoolDump::_internal_mp_available_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mp_available_count_;
}
inline void MempoolDump::_internal_set_mp_available_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mp_available_count_ = value;
}

// uint32 mp_in_use_count = 8;
inline void MempoolDump::clear_mp_in_use_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mp_in_use_count_ = 0u;
}
inline ::uint32_t MempoolDump::mp_in_use_count() const {
  // @@protoc_insertion_point(field_get:bess.pb.MempoolDump.mp_in_use_count)
  return _internal_mp_in_use_count();
}
inline void MempoolDump::set_mp_in_use_count(::uint32_t value) {
  _internal_set_mp_in_use_count(value);
  // @@protoc_insertion_point(field_set:bess.pb.MempoolDump.mp_in_use_count)
}
inline ::uint32_t MempoolDump::_internal_mp_in_use_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mp_in_use_count_;
}
inline void MempoolDump::_internal_set_mp_in_use_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mp_in_use_count_ = value;
}

// uint32 ring_count = 9;
inline void MempoolDump::clear_ring_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ring_count_ = 0u;
}
inline ::uint32_t MempoolDump::ring_count() const {
  // @@protoc_insertion_point(field_get:bess.pb.MempoolDump.ring_count)
  return _internal_ring_count();
}
inline void MempoolDump::set_ring_count(::uint32_t value) {
  _internal_set_ring_count(value);
  // @@protoc_insertion_point(field_set:bess.pb.MempoolDump.ring_count)
}
inline ::uint32_t MempoolDump::_internal_ring_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ring_count_;
}
inline void MempoolDump::_internal_set_ring_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ring_count_ = value;
}

// uint32 ring_free_count = 10;
inline void MempoolDump::clear_ring_free_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ring_free_count_ = 0u;
}
inline ::uint32_t MempoolDump::ring_free_count() const {
  // @@protoc_insertion_point(field_get:bess.pb.MempoolDump.ring_free_count)
  return _internal_ring_free_count();
}
inline void MempoolDump::set_ring_free_count(::uint32_t value) {
  _internal_set_ring_free_count(value);
  // @@protoc_insertion_point(field_set:bess.pb.MempoolDump.ring_free_count)
}
inline ::uint32_t MempoolDump::_internal_ring_free_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ring_free_count_;
}
inline void MempoolDump::_internal_set_ring_free_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ring_free_count_ = value;
}

// uint64 ring_bytes = 11;
inline void MempoolDump::clear_ring_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ring_bytes_ = ::uint64_t{0u};
}
inline ::uint64_t MempoolDump::ring_bytes() const {
  // @@protoc_insertion_point(field_get:bess.pb.MempoolDump.ring_bytes)
  return _internal_ring_bytes();
}
inline void MempoolDump::set_ring_bytes(::uint64_t value) {
  _internal_set_ring_bytes(value);
  // @@protoc_insertion_point(field_set:bess.pb.MempoolDump.ring_bytes)
}
inline ::uint64_t MempoolDump::_internal_ring_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ring_bytes_;
}
inline void MempoolDump::_internal_set_ring_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ring_bytes_ = value;
}

// -------------------------------------------------------------------

// DumpMempoolRequest

// int32 socket = 1;
inline void DumpMempoolRequest::clear_socket() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.socket_ = 0;
}
inline ::int32_t DumpMempoolRequest::socket() const {
  // @@protoc_insertion_point(field_get:bess.pb.DumpMempoolRequest.socket)
  return _internal_socket();
}
inline void DumpMempoolRequest::set_socket(::int32_t value) {
  _internal_set_socket(value);
  // @@protoc_insertion_point(field_set:bess.pb.DumpMempoolRequest.socket)
}
inline ::int32_t DumpMempoolRequest::_internal_socket() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.socket_;
}
inline void DumpMempoolRequest::_internal_set_socket(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.socket_ = value;
}

// -------------------------------------------------------------------

// DumpMempoolResponse

// .bess.pb.Error error = 1;
inline bool DumpMempoolResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& DumpMempoolResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& DumpMempoolResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.DumpMempoolResponse.error)
  return _internal_error();
}
inline void DumpMempoolResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.DumpMempoolResponse.error)
}
inline ::bess::pb::Error* DumpMempoolResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* DumpMempoolResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.DumpMempoolResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* DumpMempoolResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* DumpMempoolResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.DumpMempoolResponse.error)
  return _msg;
}
inline void DumpMempoolResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.DumpMempoolResponse.error)
}

// repeated .bess.pb.MempoolDump dumps = 2;
inline int DumpMempoolResponse::_internal_dumps_size() const {
  return _internal_dumps().size();
}
inline int DumpMempoolResponse::dumps_size() const {
  return _internal_dumps_size();
}
inline void DumpMempoolResponse::clear_dumps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dumps_.Clear();
}
inline ::bess::pb::MempoolDump* DumpMempoolResponse::mutable_dumps(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.DumpMempoolResponse.dumps)
  return _internal_mutable_dumps()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::MempoolDump>* DumpMempoolResponse::mutable_dumps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.DumpMempoolResponse.dumps)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dumps();
}
inline const ::bess::pb::MempoolDump& DumpMempoolResponse::dumps(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.DumpMempoolResponse.dumps)
  return _internal_dumps().Get(index);
}
inline ::bess::pb::MempoolDump* DumpMempoolResponse::add_dumps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::bess::pb::MempoolDump* _add = _internal_mutable_dumps()->Add();
  // @@protoc_insertion_point(field_add:bess.pb.DumpMempoolResponse.dumps)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::MempoolDump>& DumpMempoolResponse::dumps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.DumpMempoolResponse.dumps)
  return _internal_dumps();
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::MempoolDump>&
DumpMempoolResponse::_internal_dumps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dumps_;
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::MempoolDump>*
DumpMempoolResponse::_internal_mutable_dumps() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dumps_;
}

// -------------------------------------------------------------------

// CommandRequest

// string name = 1;
inline void CommandRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CommandRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CommandRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.CommandRequest.name)
}
inline std::string* CommandRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.CommandRequest.name)
  return _s;
}
inline const std::string& CommandRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CommandRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CommandRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CommandRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CommandRequest.name)
  return _impl_.name_.Release();
}
inline void CommandRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CommandRequest.name)
}

// string cmd = 2;
inline void CommandRequest::clear_cmd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cmd_.ClearToEmpty();
}
inline const std::string& CommandRequest::cmd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CommandRequest.cmd)
  return _internal_cmd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandRequest::set_cmd(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cmd_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.CommandRequest.cmd)
}
inline std::string* CommandRequest::mutable_cmd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cmd();
  // @@protoc_insertion_point(field_mutable:bess.pb.CommandRequest.cmd)
  return _s;
}
inline const std::string& CommandRequest::_internal_cmd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cmd_.Get();
}
inline void CommandRequest::_internal_set_cmd(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cmd_.Set(value, GetArena());
}
inline std::string* CommandRequest::_internal_mutable_cmd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.cmd_.Mutable( GetArena());
}
inline std::string* CommandRequest::release_cmd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CommandRequest.cmd)
  return _impl_.cmd_.Release();
}
inline void CommandRequest::set_allocated_cmd(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cmd_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cmd_.IsDefault()) {
          _impl_.cmd_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CommandRequest.cmd)
}

// .google.protobuf.Any arg = 3;
inline bool CommandRequest::has_arg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arg_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& CommandRequest::_internal_arg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Any* p = _impl_.arg_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& CommandRequest::arg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CommandRequest.arg)
  return _internal_arg();
}
inline void CommandRequest::unsafe_arena_set_allocated_arg(::google::protobuf::Any* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arg_);
  }
  _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.CommandRequest.arg)
}
inline ::google::protobuf::Any* CommandRequest::release_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.arg_;
  _impl_.arg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* CommandRequest::unsafe_arena_release_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CommandRequest.arg)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.arg_;
  _impl_.arg_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* CommandRequest::_internal_mutable_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.arg_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArena());
    _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.arg_;
}
inline ::google::protobuf::Any* CommandRequest::mutable_arg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Any* _msg = _internal_mutable_arg();
  // @@protoc_insertion_point(field_mutable:bess.pb.CommandRequest.arg)
  return _msg;
}
inline void CommandRequest::set_allocated_arg(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CommandRequest.arg)
}

// -------------------------------------------------------------------

// CommandResponse

// .bess.pb.Error error = 1;
inline bool CommandResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& CommandResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& CommandResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CommandResponse.error)
  return _internal_error();
}
inline void CommandResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.CommandResponse.error)
}
inline ::bess::pb::Error* CommandResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* CommandResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CommandResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* CommandResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* CommandResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.CommandResponse.error)
  return _msg;
}
inline void CommandResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CommandResponse.error)
}

// .google.protobuf.Any data = 2;
inline bool CommandResponse::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& CommandResponse::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Any* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& CommandResponse::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.CommandResponse.data)
  return _internal_data();
}
inline void CommandResponse::unsafe_arena_set_allocated_data(::google::protobuf::Any* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.CommandResponse.data)
}
inline ::google::protobuf::Any* CommandResponse::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Any* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* CommandResponse::unsafe_arena_release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.CommandResponse.data)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Any* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* CommandResponse::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArena());
    _impl_.data_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.data_;
}
inline ::google::protobuf::Any* CommandResponse::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Any* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:bess.pb.CommandResponse.data)
  return _msg;
}
inline void CommandResponse::set_allocated_data(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.data_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.CommandResponse.data)
}

// -------------------------------------------------------------------

// ListGateHookClassResponse

// .bess.pb.Error error = 1;
inline bool ListGateHookClassResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& ListGateHookClassResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& ListGateHookClassResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListGateHookClassResponse.error)
  return _internal_error();
}
inline void ListGateHookClassResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.ListGateHookClassResponse.error)
}
inline ::bess::pb::Error* ListGateHookClassResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* ListGateHookClassResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListGateHookClassResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* ListGateHookClassResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* ListGateHookClassResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListGateHookClassResponse.error)
  return _msg;
}
inline void ListGateHookClassResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListGateHookClassResponse.error)
}

// repeated string names = 2;
inline int ListGateHookClassResponse::_internal_names_size() const {
  return _internal_names().size();
}
inline int ListGateHookClassResponse::names_size() const {
  return _internal_names_size();
}
inline void ListGateHookClassResponse::clear_names() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.names_.Clear();
}
inline std::string* ListGateHookClassResponse::add_names()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:bess.pb.ListGateHookClassResponse.names)
  return _s;
}
inline const std::string& ListGateHookClassResponse::names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListGateHookClassResponse.names)
  return _internal_names().Get(index);
}
inline std::string* ListGateHookClassResponse::mutable_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.ListGateHookClassResponse.names)
  return _internal_mutable_names()->Mutable(index);
}
inline void ListGateHookClassResponse::set_names(int index, const std::string& value) {
  _internal_mutable_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bess.pb.ListGateHookClassResponse.names)
}
inline void ListGateHookClassResponse::set_names(int index, std::string&& value) {
  _internal_mutable_names()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bess.pb.ListGateHookClassResponse.names)
}
inline void ListGateHookClassResponse::set_names(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bess.pb.ListGateHookClassResponse.names)
}
inline void ListGateHookClassResponse::set_names(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_names()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bess.pb.ListGateHookClassResponse.names)
}
inline void ListGateHookClassResponse::set_names(int index, absl::string_view value) {
  _internal_mutable_names()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:bess.pb.ListGateHookClassResponse.names)
}
inline void ListGateHookClassResponse::add_names(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:bess.pb.ListGateHookClassResponse.names)
}
inline void ListGateHookClassResponse::add_names(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:bess.pb.ListGateHookClassResponse.names)
}
inline void ListGateHookClassResponse::add_names(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bess.pb.ListGateHookClassResponse.names)
}
inline void ListGateHookClassResponse::add_names(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bess.pb.ListGateHookClassResponse.names)
}
inline void ListGateHookClassResponse::add_names(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:bess.pb.ListGateHookClassResponse.names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ListGateHookClassResponse::names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.ListGateHookClassResponse.names)
  return _internal_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ListGateHookClassResponse::mutable_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.ListGateHookClassResponse.names)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ListGateHookClassResponse::_internal_names() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ListGateHookClassResponse::_internal_mutable_names() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.names_;
}

// -------------------------------------------------------------------

// GetGateHookClassInfoRequest

// string name = 1;
inline void GetGateHookClassInfoRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetGateHookClassInfoRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetGateHookClassInfoRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetGateHookClassInfoRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetGateHookClassInfoRequest.name)
}
inline std::string* GetGateHookClassInfoRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetGateHookClassInfoRequest.name)
  return _s;
}
inline const std::string& GetGateHookClassInfoRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetGateHookClassInfoRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetGateHookClassInfoRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetGateHookClassInfoRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetGateHookClassInfoRequest.name)
  return _impl_.name_.Release();
}
inline void GetGateHookClassInfoRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetGateHookClassInfoRequest.name)
}

// -------------------------------------------------------------------

// GetGateHookClassInfoResponse

// .bess.pb.Error error = 1;
inline bool GetGateHookClassInfoResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& GetGateHookClassInfoResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& GetGateHookClassInfoResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetGateHookClassInfoResponse.error)
  return _internal_error();
}
inline void GetGateHookClassInfoResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.GetGateHookClassInfoResponse.error)
}
inline ::bess::pb::Error* GetGateHookClassInfoResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* GetGateHookClassInfoResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetGateHookClassInfoResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* GetGateHookClassInfoResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* GetGateHookClassInfoResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetGateHookClassInfoResponse.error)
  return _msg;
}
inline void GetGateHookClassInfoResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetGateHookClassInfoResponse.error)
}

// string name = 2;
inline void GetGateHookClassInfoResponse::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetGateHookClassInfoResponse::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetGateHookClassInfoResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetGateHookClassInfoResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetGateHookClassInfoResponse.name)
}
inline std::string* GetGateHookClassInfoResponse::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetGateHookClassInfoResponse.name)
  return _s;
}
inline const std::string& GetGateHookClassInfoResponse::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetGateHookClassInfoResponse::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetGateHookClassInfoResponse::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetGateHookClassInfoResponse::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetGateHookClassInfoResponse.name)
  return _impl_.name_.Release();
}
inline void GetGateHookClassInfoResponse::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetGateHookClassInfoResponse.name)
}

// string help = 3;
inline void GetGateHookClassInfoResponse::clear_help() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.help_.ClearToEmpty();
}
inline const std::string& GetGateHookClassInfoResponse::help() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetGateHookClassInfoResponse.help)
  return _internal_help();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetGateHookClassInfoResponse::set_help(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.help_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GetGateHookClassInfoResponse.help)
}
inline std::string* GetGateHookClassInfoResponse::mutable_help() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_help();
  // @@protoc_insertion_point(field_mutable:bess.pb.GetGateHookClassInfoResponse.help)
  return _s;
}
inline const std::string& GetGateHookClassInfoResponse::_internal_help() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.help_.Get();
}
inline void GetGateHookClassInfoResponse::_internal_set_help(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.help_.Set(value, GetArena());
}
inline std::string* GetGateHookClassInfoResponse::_internal_mutable_help() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.help_.Mutable( GetArena());
}
inline std::string* GetGateHookClassInfoResponse::release_help() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GetGateHookClassInfoResponse.help)
  return _impl_.help_.Release();
}
inline void GetGateHookClassInfoResponse::set_allocated_help(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.help_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.help_.IsDefault()) {
          _impl_.help_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GetGateHookClassInfoResponse.help)
}

// repeated string cmds = 4;
inline int GetGateHookClassInfoResponse::_internal_cmds_size() const {
  return _internal_cmds().size();
}
inline int GetGateHookClassInfoResponse::cmds_size() const {
  return _internal_cmds_size();
}
inline void GetGateHookClassInfoResponse::clear_cmds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cmds_.Clear();
}
inline std::string* GetGateHookClassInfoResponse::add_cmds()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_cmds()->Add();
  // @@protoc_insertion_point(field_add_mutable:bess.pb.GetGateHookClassInfoResponse.cmds)
  return _s;
}
inline const std::string& GetGateHookClassInfoResponse::cmds(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetGateHookClassInfoResponse.cmds)
  return _internal_cmds().Get(index);
}
inline std::string* GetGateHookClassInfoResponse::mutable_cmds(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.GetGateHookClassInfoResponse.cmds)
  return _internal_mutable_cmds()->Mutable(index);
}
inline void GetGateHookClassInfoResponse::set_cmds(int index, const std::string& value) {
  _internal_mutable_cmds()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetGateHookClassInfoResponse.cmds)
}
inline void GetGateHookClassInfoResponse::set_cmds(int index, std::string&& value) {
  _internal_mutable_cmds()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bess.pb.GetGateHookClassInfoResponse.cmds)
}
inline void GetGateHookClassInfoResponse::set_cmds(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_cmds()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bess.pb.GetGateHookClassInfoResponse.cmds)
}
inline void GetGateHookClassInfoResponse::set_cmds(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_cmds()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bess.pb.GetGateHookClassInfoResponse.cmds)
}
inline void GetGateHookClassInfoResponse::set_cmds(int index, absl::string_view value) {
  _internal_mutable_cmds()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:bess.pb.GetGateHookClassInfoResponse.cmds)
}
inline void GetGateHookClassInfoResponse::add_cmds(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmds()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:bess.pb.GetGateHookClassInfoResponse.cmds)
}
inline void GetGateHookClassInfoResponse::add_cmds(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmds()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:bess.pb.GetGateHookClassInfoResponse.cmds)
}
inline void GetGateHookClassInfoResponse::add_cmds(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmds()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bess.pb.GetGateHookClassInfoResponse.cmds)
}
inline void GetGateHookClassInfoResponse::add_cmds(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmds()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bess.pb.GetGateHookClassInfoResponse.cmds)
}
inline void GetGateHookClassInfoResponse::add_cmds(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmds()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:bess.pb.GetGateHookClassInfoResponse.cmds)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetGateHookClassInfoResponse::cmds() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.GetGateHookClassInfoResponse.cmds)
  return _internal_cmds();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetGateHookClassInfoResponse::mutable_cmds() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.GetGateHookClassInfoResponse.cmds)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_cmds();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetGateHookClassInfoResponse::_internal_cmds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cmds_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetGateHookClassInfoResponse::_internal_mutable_cmds() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.cmds_;
}

// repeated string cmd_args = 5;
inline int GetGateHookClassInfoResponse::_internal_cmd_args_size() const {
  return _internal_cmd_args().size();
}
inline int GetGateHookClassInfoResponse::cmd_args_size() const {
  return _internal_cmd_args_size();
}
inline void GetGateHookClassInfoResponse::clear_cmd_args() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cmd_args_.Clear();
}
inline std::string* GetGateHookClassInfoResponse::add_cmd_args()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_cmd_args()->Add();
  // @@protoc_insertion_point(field_add_mutable:bess.pb.GetGateHookClassInfoResponse.cmd_args)
  return _s;
}
inline const std::string& GetGateHookClassInfoResponse::cmd_args(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GetGateHookClassInfoResponse.cmd_args)
  return _internal_cmd_args().Get(index);
}
inline std::string* GetGateHookClassInfoResponse::mutable_cmd_args(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.GetGateHookClassInfoResponse.cmd_args)
  return _internal_mutable_cmd_args()->Mutable(index);
}
inline void GetGateHookClassInfoResponse::set_cmd_args(int index, const std::string& value) {
  _internal_mutable_cmd_args()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bess.pb.GetGateHookClassInfoResponse.cmd_args)
}
inline void GetGateHookClassInfoResponse::set_cmd_args(int index, std::string&& value) {
  _internal_mutable_cmd_args()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bess.pb.GetGateHookClassInfoResponse.cmd_args)
}
inline void GetGateHookClassInfoResponse::set_cmd_args(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_cmd_args()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bess.pb.GetGateHookClassInfoResponse.cmd_args)
}
inline void GetGateHookClassInfoResponse::set_cmd_args(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_cmd_args()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bess.pb.GetGateHookClassInfoResponse.cmd_args)
}
inline void GetGateHookClassInfoResponse::set_cmd_args(int index, absl::string_view value) {
  _internal_mutable_cmd_args()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:bess.pb.GetGateHookClassInfoResponse.cmd_args)
}
inline void GetGateHookClassInfoResponse::add_cmd_args(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmd_args()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:bess.pb.GetGateHookClassInfoResponse.cmd_args)
}
inline void GetGateHookClassInfoResponse::add_cmd_args(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmd_args()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:bess.pb.GetGateHookClassInfoResponse.cmd_args)
}
inline void GetGateHookClassInfoResponse::add_cmd_args(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmd_args()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bess.pb.GetGateHookClassInfoResponse.cmd_args)
}
inline void GetGateHookClassInfoResponse::add_cmd_args(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmd_args()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bess.pb.GetGateHookClassInfoResponse.cmd_args)
}
inline void GetGateHookClassInfoResponse::add_cmd_args(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cmd_args()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:bess.pb.GetGateHookClassInfoResponse.cmd_args)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetGateHookClassInfoResponse::cmd_args() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.GetGateHookClassInfoResponse.cmd_args)
  return _internal_cmd_args();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetGateHookClassInfoResponse::mutable_cmd_args() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.GetGateHookClassInfoResponse.cmd_args)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_cmd_args();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetGateHookClassInfoResponse::_internal_cmd_args() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cmd_args_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetGateHookClassInfoResponse::_internal_mutable_cmd_args() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.cmd_args_;
}

// -------------------------------------------------------------------

// TrackArg

// bool bits = 5;
inline void TrackArg::clear_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bits_ = false;
}
inline bool TrackArg::bits() const {
  // @@protoc_insertion_point(field_get:bess.pb.TrackArg.bits)
  return _internal_bits();
}
inline void TrackArg::set_bits(bool value) {
  _internal_set_bits(value);
  // @@protoc_insertion_point(field_set:bess.pb.TrackArg.bits)
}
inline bool TrackArg::_internal_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bits_;
}
inline void TrackArg::_internal_set_bits(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bits_ = value;
}

// -------------------------------------------------------------------

// TcpdumpArg

// string fifo = 5;
inline void TcpdumpArg::clear_fifo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fifo_.ClearToEmpty();
}
inline const std::string& TcpdumpArg::fifo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.TcpdumpArg.fifo)
  return _internal_fifo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TcpdumpArg::set_fifo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fifo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.TcpdumpArg.fifo)
}
inline std::string* TcpdumpArg::mutable_fifo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fifo();
  // @@protoc_insertion_point(field_mutable:bess.pb.TcpdumpArg.fifo)
  return _s;
}
inline const std::string& TcpdumpArg::_internal_fifo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fifo_.Get();
}
inline void TcpdumpArg::_internal_set_fifo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fifo_.Set(value, GetArena());
}
inline std::string* TcpdumpArg::_internal_mutable_fifo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.fifo_.Mutable( GetArena());
}
inline std::string* TcpdumpArg::release_fifo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.TcpdumpArg.fifo)
  return _impl_.fifo_.Release();
}
inline void TcpdumpArg::set_allocated_fifo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fifo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fifo_.IsDefault()) {
          _impl_.fifo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.TcpdumpArg.fifo)
}

// bool defer = 6;
inline void TcpdumpArg::clear_defer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.defer_ = false;
}
inline bool TcpdumpArg::defer() const {
  // @@protoc_insertion_point(field_get:bess.pb.TcpdumpArg.defer)
  return _internal_defer();
}
inline void TcpdumpArg::set_defer(bool value) {
  _internal_set_defer(value);
  // @@protoc_insertion_point(field_set:bess.pb.TcpdumpArg.defer)
}
inline bool TcpdumpArg::_internal_defer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.defer_;
}
inline void TcpdumpArg::_internal_set_defer(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.defer_ = value;
}

// bool reconnect = 7;
inline void TcpdumpArg::clear_reconnect() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reconnect_ = false;
}
inline bool TcpdumpArg::reconnect() const {
  // @@protoc_insertion_point(field_get:bess.pb.TcpdumpArg.reconnect)
  return _internal_reconnect();
}
inline void TcpdumpArg::set_reconnect(bool value) {
  _internal_set_reconnect(value);
  // @@protoc_insertion_point(field_set:bess.pb.TcpdumpArg.reconnect)
}
inline bool TcpdumpArg::_internal_reconnect() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reconnect_;
}
inline void TcpdumpArg::_internal_set_reconnect(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reconnect_ = value;
}

// -------------------------------------------------------------------

// PcapngArg

// string fifo = 5;
inline void PcapngArg::clear_fifo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fifo_.ClearToEmpty();
}
inline const std::string& PcapngArg::fifo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.PcapngArg.fifo)
  return _internal_fifo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PcapngArg::set_fifo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fifo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.PcapngArg.fifo)
}
inline std::string* PcapngArg::mutable_fifo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fifo();
  // @@protoc_insertion_point(field_mutable:bess.pb.PcapngArg.fifo)
  return _s;
}
inline const std::string& PcapngArg::_internal_fifo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fifo_.Get();
}
inline void PcapngArg::_internal_set_fifo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fifo_.Set(value, GetArena());
}
inline std::string* PcapngArg::_internal_mutable_fifo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.fifo_.Mutable( GetArena());
}
inline std::string* PcapngArg::release_fifo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.PcapngArg.fifo)
  return _impl_.fifo_.Release();
}
inline void PcapngArg::set_allocated_fifo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fifo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fifo_.IsDefault()) {
          _impl_.fifo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.PcapngArg.fifo)
}

// bool defer = 6;
inline void PcapngArg::clear_defer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.defer_ = false;
}
inline bool PcapngArg::defer() const {
  // @@protoc_insertion_point(field_get:bess.pb.PcapngArg.defer)
  return _internal_defer();
}
inline void PcapngArg::set_defer(bool value) {
  _internal_set_defer(value);
  // @@protoc_insertion_point(field_set:bess.pb.PcapngArg.defer)
}
inline bool PcapngArg::_internal_defer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.defer_;
}
inline void PcapngArg::_internal_set_defer(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.defer_ = value;
}

// bool reconnect = 7;
inline void PcapngArg::clear_reconnect() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reconnect_ = false;
}
inline bool PcapngArg::reconnect() const {
  // @@protoc_insertion_point(field_get:bess.pb.PcapngArg.reconnect)
  return _internal_reconnect();
}
inline void PcapngArg::set_reconnect(bool value) {
  _internal_set_reconnect(value);
  // @@protoc_insertion_point(field_set:bess.pb.PcapngArg.reconnect)
}
inline bool PcapngArg::_internal_reconnect() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reconnect_;
}
inline void PcapngArg::_internal_set_reconnect(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reconnect_ = value;
}

// -------------------------------------------------------------------

// GateHookInfo

// string class_name = 1;
inline void GateHookInfo::clear_class_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.class_name_.ClearToEmpty();
}
inline const std::string& GateHookInfo::class_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GateHookInfo.class_name)
  return _internal_class_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GateHookInfo::set_class_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.class_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GateHookInfo.class_name)
}
inline std::string* GateHookInfo::mutable_class_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GateHookInfo.class_name)
  return _s;
}
inline const std::string& GateHookInfo::_internal_class_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.class_name_.Get();
}
inline void GateHookInfo::_internal_set_class_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.class_name_.Set(value, GetArena());
}
inline std::string* GateHookInfo::_internal_mutable_class_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.class_name_.Mutable( GetArena());
}
inline std::string* GateHookInfo::release_class_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GateHookInfo.class_name)
  return _impl_.class_name_.Release();
}
inline void GateHookInfo::set_allocated_class_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.class_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.class_name_.IsDefault()) {
          _impl_.class_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GateHookInfo.class_name)
}

// string hook_name = 2;
inline void GateHookInfo::clear_hook_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hook_name_.ClearToEmpty();
}
inline const std::string& GateHookInfo::hook_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GateHookInfo.hook_name)
  return _internal_hook_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GateHookInfo::set_hook_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hook_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GateHookInfo.hook_name)
}
inline std::string* GateHookInfo::mutable_hook_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hook_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GateHookInfo.hook_name)
  return _s;
}
inline const std::string& GateHookInfo::_internal_hook_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hook_name_.Get();
}
inline void GateHookInfo::_internal_set_hook_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hook_name_.Set(value, GetArena());
}
inline std::string* GateHookInfo::_internal_mutable_hook_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.hook_name_.Mutable( GetArena());
}
inline std::string* GateHookInfo::release_hook_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GateHookInfo.hook_name)
  return _impl_.hook_name_.Release();
}
inline void GateHookInfo::set_allocated_hook_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hook_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hook_name_.IsDefault()) {
          _impl_.hook_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GateHookInfo.hook_name)
}

// string module_name = 3;
inline void GateHookInfo::clear_module_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.module_name_.ClearToEmpty();
}
inline const std::string& GateHookInfo::module_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GateHookInfo.module_name)
  return _internal_module_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GateHookInfo::set_module_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.module_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GateHookInfo.module_name)
}
inline std::string* GateHookInfo::mutable_module_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_module_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.GateHookInfo.module_name)
  return _s;
}
inline const std::string& GateHookInfo::_internal_module_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.module_name_.Get();
}
inline void GateHookInfo::_internal_set_module_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.module_name_.Set(value, GetArena());
}
inline std::string* GateHookInfo::_internal_mutable_module_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.module_name_.Mutable( GetArena());
}
inline std::string* GateHookInfo::release_module_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GateHookInfo.module_name)
  return _impl_.module_name_.Release();
}
inline void GateHookInfo::set_allocated_module_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.module_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.module_name_.IsDefault()) {
          _impl_.module_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GateHookInfo.module_name)
}

// int64 igate = 4;
inline bool GateHookInfo::has_igate() const {
  return gate_case() == kIgate;
}
inline void GateHookInfo::set_has_igate() {
  _impl_._oneof_case_[0] = kIgate;
}
inline void GateHookInfo::clear_igate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (gate_case() == kIgate) {
    _impl_.gate_.igate_ = ::int64_t{0};
    clear_has_gate();
  }
}
inline ::int64_t GateHookInfo::igate() const {
  // @@protoc_insertion_point(field_get:bess.pb.GateHookInfo.igate)
  return _internal_igate();
}
inline void GateHookInfo::set_igate(::int64_t value) {
  _internal_set_igate(value);
  // @@protoc_insertion_point(field_set:bess.pb.GateHookInfo.igate)
}
inline ::int64_t GateHookInfo::_internal_igate() const {
  if (gate_case() == kIgate) {
    return _impl_.gate_.igate_;
  }
  return ::int64_t{0};
}
inline void GateHookInfo::_internal_set_igate(::int64_t value) {
  if (gate_case() != kIgate) {
    clear_gate();
    set_has_igate();
  }
  _impl_.gate_.igate_ = value;
}

// int64 ogate = 5;
inline bool GateHookInfo::has_ogate() const {
  return gate_case() == kOgate;
}
inline void GateHookInfo::set_has_ogate() {
  _impl_._oneof_case_[0] = kOgate;
}
inline void GateHookInfo::clear_ogate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (gate_case() == kOgate) {
    _impl_.gate_.ogate_ = ::int64_t{0};
    clear_has_gate();
  }
}
inline ::int64_t GateHookInfo::ogate() const {
  // @@protoc_insertion_point(field_get:bess.pb.GateHookInfo.ogate)
  return _internal_ogate();
}
inline void GateHookInfo::set_ogate(::int64_t value) {
  _internal_set_ogate(value);
  // @@protoc_insertion_point(field_set:bess.pb.GateHookInfo.ogate)
}
inline ::int64_t GateHookInfo::_internal_ogate() const {
  if (gate_case() == kOgate) {
    return _impl_.gate_.ogate_;
  }
  return ::int64_t{0};
}
inline void GateHookInfo::_internal_set_ogate(::int64_t value) {
  if (gate_case() != kOgate) {
    clear_gate();
    set_has_ogate();
  }
  _impl_.gate_.ogate_ = value;
}

// .google.protobuf.Any arg = 6;
inline bool GateHookInfo::has_arg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arg_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& GateHookInfo::_internal_arg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Any* p = _impl_.arg_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& GateHookInfo::arg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GateHookInfo.arg)
  return _internal_arg();
}
inline void GateHookInfo::unsafe_arena_set_allocated_arg(::google::protobuf::Any* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arg_);
  }
  _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.GateHookInfo.arg)
}
inline ::google::protobuf::Any* GateHookInfo::release_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.arg_;
  _impl_.arg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* GateHookInfo::unsafe_arena_release_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GateHookInfo.arg)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.arg_;
  _impl_.arg_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* GateHookInfo::_internal_mutable_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.arg_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArena());
    _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.arg_;
}
inline ::google::protobuf::Any* GateHookInfo::mutable_arg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Any* _msg = _internal_mutable_arg();
  // @@protoc_insertion_point(field_mutable:bess.pb.GateHookInfo.arg)
  return _msg;
}
inline void GateHookInfo::set_allocated_arg(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GateHookInfo.arg)
}

inline bool GateHookInfo::has_gate() const {
  return gate_case() != GATE_NOT_SET;
}
inline void GateHookInfo::clear_has_gate() {
  _impl_._oneof_case_[0] = GATE_NOT_SET;
}
inline GateHookInfo::GateCase GateHookInfo::gate_case() const {
  return GateHookInfo::GateCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConfigureGateHookRequest

// .bess.pb.GateHookInfo hook = 1;
inline bool ConfigureGateHookRequest::has_hook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hook_ != nullptr);
  return value;
}
inline void ConfigureGateHookRequest::clear_hook() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.hook_ != nullptr) _impl_.hook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::bess::pb::GateHookInfo& ConfigureGateHookRequest::_internal_hook() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::GateHookInfo* p = _impl_.hook_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::GateHookInfo&>(::bess::pb::_GateHookInfo_default_instance_);
}
inline const ::bess::pb::GateHookInfo& ConfigureGateHookRequest::hook() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ConfigureGateHookRequest.hook)
  return _internal_hook();
}
inline void ConfigureGateHookRequest::unsafe_arena_set_allocated_hook(::bess::pb::GateHookInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hook_);
  }
  _impl_.hook_ = reinterpret_cast<::bess::pb::GateHookInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.ConfigureGateHookRequest.hook)
}
inline ::bess::pb::GateHookInfo* ConfigureGateHookRequest::release_hook() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::GateHookInfo* released = _impl_.hook_;
  _impl_.hook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::GateHookInfo* ConfigureGateHookRequest::unsafe_arena_release_hook() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ConfigureGateHookRequest.hook)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::GateHookInfo* temp = _impl_.hook_;
  _impl_.hook_ = nullptr;
  return temp;
}
inline ::bess::pb::GateHookInfo* ConfigureGateHookRequest::_internal_mutable_hook() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.hook_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::GateHookInfo>(GetArena());
    _impl_.hook_ = reinterpret_cast<::bess::pb::GateHookInfo*>(p);
  }
  return _impl_.hook_;
}
inline ::bess::pb::GateHookInfo* ConfigureGateHookRequest::mutable_hook() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::GateHookInfo* _msg = _internal_mutable_hook();
  // @@protoc_insertion_point(field_mutable:bess.pb.ConfigureGateHookRequest.hook)
  return _msg;
}
inline void ConfigureGateHookRequest::set_allocated_hook(::bess::pb::GateHookInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::bess::pb::GateHookInfo*>(_impl_.hook_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::bess::pb::GateHookInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hook_ = reinterpret_cast<::bess::pb::GateHookInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ConfigureGateHookRequest.hook)
}

// bool enable = 2;
inline void ConfigureGateHookRequest::clear_enable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_ = false;
}
inline bool ConfigureGateHookRequest::enable() const {
  // @@protoc_insertion_point(field_get:bess.pb.ConfigureGateHookRequest.enable)
  return _internal_enable();
}
inline void ConfigureGateHookRequest::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:bess.pb.ConfigureGateHookRequest.enable)
}
inline bool ConfigureGateHookRequest::_internal_enable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_;
}
inline void ConfigureGateHookRequest::_internal_set_enable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_ = value;
}

// -------------------------------------------------------------------

// ConfigureGateHookResponse

// .bess.pb.Error error = 1;
inline bool ConfigureGateHookResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& ConfigureGateHookResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& ConfigureGateHookResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ConfigureGateHookResponse.error)
  return _internal_error();
}
inline void ConfigureGateHookResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.ConfigureGateHookResponse.error)
}
inline ::bess::pb::Error* ConfigureGateHookResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* ConfigureGateHookResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ConfigureGateHookResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* ConfigureGateHookResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* ConfigureGateHookResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.ConfigureGateHookResponse.error)
  return _msg;
}
inline void ConfigureGateHookResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ConfigureGateHookResponse.error)
}

// string name = 2;
inline void ConfigureGateHookResponse::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ConfigureGateHookResponse::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ConfigureGateHookResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConfigureGateHookResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.ConfigureGateHookResponse.name)
}
inline std::string* ConfigureGateHookResponse::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.ConfigureGateHookResponse.name)
  return _s;
}
inline const std::string& ConfigureGateHookResponse::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ConfigureGateHookResponse::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ConfigureGateHookResponse::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ConfigureGateHookResponse::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ConfigureGateHookResponse.name)
  return _impl_.name_.Release();
}
inline void ConfigureGateHookResponse::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ConfigureGateHookResponse.name)
}

// -------------------------------------------------------------------

// ListGateHooksResponse

// .bess.pb.Error error = 1;
inline bool ListGateHooksResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::bess::pb::Error& ListGateHooksResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::Error&>(::bess::pb::_Error_default_instance_);
}
inline const ::bess::pb::Error& ListGateHooksResponse::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListGateHooksResponse.error)
  return _internal_error();
}
inline void ListGateHooksResponse::unsafe_arena_set_allocated_error(::bess::pb::Error* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.ListGateHooksResponse.error)
}
inline ::bess::pb::Error* ListGateHooksResponse::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::Error* ListGateHooksResponse::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ListGateHooksResponse.error)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::bess::pb::Error* ListGateHooksResponse::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::Error>(GetArena());
    _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(p);
  }
  return _impl_.error_;
}
inline ::bess::pb::Error* ListGateHooksResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:bess.pb.ListGateHooksResponse.error)
  return _msg;
}
inline void ListGateHooksResponse::set_allocated_error(::bess::pb::Error* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.error_ = reinterpret_cast<::bess::pb::Error*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ListGateHooksResponse.error)
}

// repeated .bess.pb.GateHookInfo hooks = 2;
inline int ListGateHooksResponse::_internal_hooks_size() const {
  return _internal_hooks().size();
}
inline int ListGateHooksResponse::hooks_size() const {
  return _internal_hooks_size();
}
inline void ListGateHooksResponse::clear_hooks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hooks_.Clear();
}
inline ::bess::pb::GateHookInfo* ListGateHooksResponse::mutable_hooks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:bess.pb.ListGateHooksResponse.hooks)
  return _internal_mutable_hooks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::GateHookInfo>* ListGateHooksResponse::mutable_hooks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:bess.pb.ListGateHooksResponse.hooks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_hooks();
}
inline const ::bess::pb::GateHookInfo& ListGateHooksResponse::hooks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ListGateHooksResponse.hooks)
  return _internal_hooks().Get(index);
}
inline ::bess::pb::GateHookInfo* ListGateHooksResponse::add_hooks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::bess::pb::GateHookInfo* _add = _internal_mutable_hooks()->Add();
  // @@protoc_insertion_point(field_add:bess.pb.ListGateHooksResponse.hooks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::GateHookInfo>& ListGateHooksResponse::hooks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:bess.pb.ListGateHooksResponse.hooks)
  return _internal_hooks();
}
inline const ::google::protobuf::RepeatedPtrField<::bess::pb::GateHookInfo>&
ListGateHooksResponse::_internal_hooks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hooks_;
}
inline ::google::protobuf::RepeatedPtrField<::bess::pb::GateHookInfo>*
ListGateHooksResponse::_internal_mutable_hooks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.hooks_;
}

// -------------------------------------------------------------------

// GateHookCommandRequest

// .bess.pb.GateHookInfo hook = 1;
inline bool GateHookCommandRequest::has_hook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hook_ != nullptr);
  return value;
}
inline void GateHookCommandRequest::clear_hook() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.hook_ != nullptr) _impl_.hook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::bess::pb::GateHookInfo& GateHookCommandRequest::_internal_hook() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::bess::pb::GateHookInfo* p = _impl_.hook_;
  return p != nullptr ? *p : reinterpret_cast<const ::bess::pb::GateHookInfo&>(::bess::pb::_GateHookInfo_default_instance_);
}
inline const ::bess::pb::GateHookInfo& GateHookCommandRequest::hook() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GateHookCommandRequest.hook)
  return _internal_hook();
}
inline void GateHookCommandRequest::unsafe_arena_set_allocated_hook(::bess::pb::GateHookInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hook_);
  }
  _impl_.hook_ = reinterpret_cast<::bess::pb::GateHookInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.GateHookCommandRequest.hook)
}
inline ::bess::pb::GateHookInfo* GateHookCommandRequest::release_hook() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::GateHookInfo* released = _impl_.hook_;
  _impl_.hook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::bess::pb::GateHookInfo* GateHookCommandRequest::unsafe_arena_release_hook() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GateHookCommandRequest.hook)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::bess::pb::GateHookInfo* temp = _impl_.hook_;
  _impl_.hook_ = nullptr;
  return temp;
}
inline ::bess::pb::GateHookInfo* GateHookCommandRequest::_internal_mutable_hook() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.hook_ == nullptr) {
    auto* p = CreateMaybeMessage<::bess::pb::GateHookInfo>(GetArena());
    _impl_.hook_ = reinterpret_cast<::bess::pb::GateHookInfo*>(p);
  }
  return _impl_.hook_;
}
inline ::bess::pb::GateHookInfo* GateHookCommandRequest::mutable_hook() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::bess::pb::GateHookInfo* _msg = _internal_mutable_hook();
  // @@protoc_insertion_point(field_mutable:bess.pb.GateHookCommandRequest.hook)
  return _msg;
}
inline void GateHookCommandRequest::set_allocated_hook(::bess::pb::GateHookInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::bess::pb::GateHookInfo*>(_impl_.hook_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::bess::pb::GateHookInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hook_ = reinterpret_cast<::bess::pb::GateHookInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GateHookCommandRequest.hook)
}

// string cmd = 2;
inline void GateHookCommandRequest::clear_cmd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cmd_.ClearToEmpty();
}
inline const std::string& GateHookCommandRequest::cmd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.GateHookCommandRequest.cmd)
  return _internal_cmd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GateHookCommandRequest::set_cmd(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cmd_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.GateHookCommandRequest.cmd)
}
inline std::string* GateHookCommandRequest::mutable_cmd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cmd();
  // @@protoc_insertion_point(field_mutable:bess.pb.GateHookCommandRequest.cmd)
  return _s;
}
inline const std::string& GateHookCommandRequest::_internal_cmd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cmd_.Get();
}
inline void GateHookCommandRequest::_internal_set_cmd(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cmd_.Set(value, GetArena());
}
inline std::string* GateHookCommandRequest::_internal_mutable_cmd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.cmd_.Mutable( GetArena());
}
inline std::string* GateHookCommandRequest::release_cmd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.GateHookCommandRequest.cmd)
  return _impl_.cmd_.Release();
}
inline void GateHookCommandRequest::set_allocated_cmd(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cmd_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cmd_.IsDefault()) {
          _impl_.cmd_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.GateHookCommandRequest.cmd)
}

// -------------------------------------------------------------------

// ConfigureResumeHookRequest

// string hook_name = 1;
inline void ConfigureResumeHookRequest::clear_hook_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hook_name_.ClearToEmpty();
}
inline const std::string& ConfigureResumeHookRequest::hook_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ConfigureResumeHookRequest.hook_name)
  return _internal_hook_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConfigureResumeHookRequest::set_hook_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hook_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:bess.pb.ConfigureResumeHookRequest.hook_name)
}
inline std::string* ConfigureResumeHookRequest::mutable_hook_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hook_name();
  // @@protoc_insertion_point(field_mutable:bess.pb.ConfigureResumeHookRequest.hook_name)
  return _s;
}
inline const std::string& ConfigureResumeHookRequest::_internal_hook_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hook_name_.Get();
}
inline void ConfigureResumeHookRequest::_internal_set_hook_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hook_name_.Set(value, GetArena());
}
inline std::string* ConfigureResumeHookRequest::_internal_mutable_hook_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.hook_name_.Mutable( GetArena());
}
inline std::string* ConfigureResumeHookRequest::release_hook_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ConfigureResumeHookRequest.hook_name)
  return _impl_.hook_name_.Release();
}
inline void ConfigureResumeHookRequest::set_allocated_hook_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hook_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hook_name_.IsDefault()) {
          _impl_.hook_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ConfigureResumeHookRequest.hook_name)
}

// bool enable = 2;
inline void ConfigureResumeHookRequest::clear_enable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_ = false;
}
inline bool ConfigureResumeHookRequest::enable() const {
  // @@protoc_insertion_point(field_get:bess.pb.ConfigureResumeHookRequest.enable)
  return _internal_enable();
}
inline void ConfigureResumeHookRequest::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:bess.pb.ConfigureResumeHookRequest.enable)
}
inline bool ConfigureResumeHookRequest::_internal_enable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_;
}
inline void ConfigureResumeHookRequest::_internal_set_enable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_ = value;
}

// .google.protobuf.Any arg = 3;
inline bool ConfigureResumeHookRequest::has_arg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arg_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& ConfigureResumeHookRequest::_internal_arg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Any* p = _impl_.arg_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& ConfigureResumeHookRequest::arg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:bess.pb.ConfigureResumeHookRequest.arg)
  return _internal_arg();
}
inline void ConfigureResumeHookRequest::unsafe_arena_set_allocated_arg(::google::protobuf::Any* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arg_);
  }
  _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bess.pb.ConfigureResumeHookRequest.arg)
}
inline ::google::protobuf::Any* ConfigureResumeHookRequest::release_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.arg_;
  _impl_.arg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Any* ConfigureResumeHookRequest::unsafe_arena_release_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:bess.pb.ConfigureResumeHookRequest.arg)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.arg_;
  _impl_.arg_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* ConfigureResumeHookRequest::_internal_mutable_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.arg_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArena());
    _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.arg_;
}
inline ::google::protobuf::Any* ConfigureResumeHookRequest::mutable_arg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Any* _msg = _internal_mutable_arg();
  // @@protoc_insertion_point(field_mutable:bess.pb.ConfigureResumeHookRequest.arg)
  return _msg;
}
inline void ConfigureResumeHookRequest::set_allocated_arg(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.arg_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:bess.pb.ConfigureResumeHookRequest.arg)
}

// -------------------------------------------------------------------

// PauseWorkerRequest

// int64 wid = 1;
inline void PauseWorkerRequest::clear_wid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wid_ = ::int64_t{0};
}
inline ::int64_t PauseWorkerRequest::wid() const {
  // @@protoc_insertion_point(field_get:bess.pb.PauseWorkerRequest.wid)
  return _internal_wid();
}
inline void PauseWorkerRequest::set_wid(::int64_t value) {
  _internal_set_wid(value);
  // @@protoc_insertion_point(field_set:bess.pb.PauseWorkerRequest.wid)
}
inline ::int64_t PauseWorkerRequest::_internal_wid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wid_;
}
inline void PauseWorkerRequest::_internal_set_wid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wid_ = value;
}

// -------------------------------------------------------------------

// ResumeWorkerRequest

// int64 wid = 1;
inline void ResumeWorkerRequest::clear_wid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wid_ = ::int64_t{0};
}
inline ::int64_t ResumeWorkerRequest::wid() const {
  // @@protoc_insertion_point(field_get:bess.pb.ResumeWorkerRequest.wid)
  return _internal_wid();
}
inline void ResumeWorkerRequest::set_wid(::int64_t value) {
  _internal_set_wid(value);
  // @@protoc_insertion_point(field_set:bess.pb.ResumeWorkerRequest.wid)
}
inline ::int64_t ResumeWorkerRequest::_internal_wid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wid_;
}
inline void ResumeWorkerRequest::_internal_set_wid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wid_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace pb
}  // namespace bess


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_bess_5fmsg_2eproto_2epb_2eh
